
bin/Debug/modul_uno.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001e8  00800100  00003798  0000384c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003798  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000042  008002e8  008002e8  00003a34  2**0
                  ALLOC
  3 .fuse         00000003  00820000  00820000  00003a34  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         000060e4  00000000  00000000  00003a38  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00001e0b  00000000  00000000  00009b1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .comment      00000011  00000000  00000000  0000b927  2**0
                  CONTENTS, READONLY
  7 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000b938  2**2
                  CONTENTS, READONLY
  8 .debug_info   000005f4  00000000  00000000  0000b978  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 000005a2  00000000  00000000  0000bf6c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   0000001a  00000000  00000000  0000c50e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000208  00000000  00000000  0000c528  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 88 00 	jmp	0x110	; 0x110 <__ctors_end>
       4:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
       8:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
       c:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
      10:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
      14:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
      18:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
      1c:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
      20:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
      24:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
      28:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
      2c:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
      30:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
      34:	0c 94 d4 0e 	jmp	0x1da8	; 0x1da8 <__vector_13>
      38:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
      3c:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
      40:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
      44:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
      48:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
      4c:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
      50:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
      54:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
      58:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
      5c:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
      60:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
      64:	0c 94 a5 00 	jmp	0x14a	; 0x14a <__bad_interrupt>
      68:	ee 16       	cp	r14, r30
      6a:	f6 16       	cp	r15, r22
      6c:	f6 16       	cp	r15, r22
      6e:	f6 16       	cp	r15, r22
      70:	f6 16       	cp	r15, r22
      72:	f6 16       	cp	r15, r22
      74:	f6 16       	cp	r15, r22
      76:	f6 16       	cp	r15, r22
      78:	f6 16       	cp	r15, r22
      7a:	f6 16       	cp	r15, r22
      7c:	f6 16       	cp	r15, r22
      7e:	f6 16       	cp	r15, r22
      80:	f6 16       	cp	r15, r22
      82:	f6 16       	cp	r15, r22
      84:	f6 16       	cp	r15, r22
      86:	f6 16       	cp	r15, r22
      88:	f6 16       	cp	r15, r22
      8a:	f6 16       	cp	r15, r22
      8c:	f6 16       	cp	r15, r22
      8e:	f6 16       	cp	r15, r22
      90:	f6 16       	cp	r15, r22
      92:	f6 16       	cp	r15, r22
      94:	f6 16       	cp	r15, r22
      96:	f6 16       	cp	r15, r22
      98:	f6 16       	cp	r15, r22
      9a:	f6 16       	cp	r15, r22
      9c:	f6 16       	cp	r15, r22
      9e:	f6 16       	cp	r15, r22
      a0:	f6 16       	cp	r15, r22
      a2:	a4 16       	cp	r10, r20
      a4:	b8 15       	cp	r27, r8
      a6:	ee 15       	cp	r30, r14
      a8:	f6 16       	cp	r15, r22
      aa:	c4 16       	cp	r12, r20
      ac:	f6 16       	cp	r15, r22
      ae:	f6 16       	cp	r15, r22
      b0:	f6 16       	cp	r15, r22
      b2:	f6 16       	cp	r15, r22
      b4:	f6 16       	cp	r15, r22
      b6:	f6 16       	cp	r15, r22
      b8:	f6 16       	cp	r15, r22
      ba:	f6 16       	cp	r15, r22
      bc:	f6 16       	cp	r15, r22
      be:	f6 16       	cp	r15, r22
      c0:	f6 16       	cp	r15, r22
      c2:	f6 16       	cp	r15, r22
      c4:	dd 16       	cp	r13, r29
      c6:	f6 16       	cp	r15, r22
      c8:	39 16       	cp	r3, r25
      ca:	f6 16       	cp	r15, r22
      cc:	f6 16       	cp	r15, r22
      ce:	6c 16       	cp	r6, r28
      d0:	f6 16       	cp	r15, r22
      d2:	f6 16       	cp	r15, r22
      d4:	f6 16       	cp	r15, r22
      d6:	f6 16       	cp	r15, r22
      d8:	f6 16       	cp	r15, r22
      da:	f6 16       	cp	r15, r22
      dc:	f6 16       	cp	r15, r22
      de:	f6 16       	cp	r15, r22
      e0:	f6 16       	cp	r15, r22
      e2:	87 16       	cp	r8, r23
      e4:	b8 15       	cp	r27, r8
      e6:	c7 15       	cp	r28, r7
      e8:	f6 16       	cp	r15, r22
      ea:	c4 16       	cp	r12, r20
      ec:	f6 16       	cp	r15, r22
      ee:	f6 16       	cp	r15, r22
      f0:	f6 16       	cp	r15, r22
      f2:	f6 16       	cp	r15, r22
      f4:	f6 16       	cp	r15, r22
      f6:	f6 16       	cp	r15, r22
      f8:	f6 16       	cp	r15, r22
      fa:	f6 16       	cp	r15, r22
      fc:	f6 16       	cp	r15, r22
      fe:	f6 16       	cp	r15, r22
     100:	f6 16       	cp	r15, r22
     102:	f6 16       	cp	r15, r22
     104:	dd 16       	cp	r13, r29
     106:	f6 16       	cp	r15, r22
     108:	21 16       	cp	r2, r17
     10a:	f6 16       	cp	r15, r22
     10c:	f6 16       	cp	r15, r22
     10e:	54 16       	cp	r5, r20

00000110 <__ctors_end>:
     110:	11 24       	eor	r1, r1
     112:	1f be       	out	0x3f, r1	; 63
     114:	cf ef       	ldi	r28, 0xFF	; 255
     116:	d8 e0       	ldi	r29, 0x08	; 8
     118:	de bf       	out	0x3e, r29	; 62
     11a:	cd bf       	out	0x3d, r28	; 61

0000011c <__do_copy_data>:
     11c:	12 e0       	ldi	r17, 0x02	; 2
     11e:	a0 e0       	ldi	r26, 0x00	; 0
     120:	b1 e0       	ldi	r27, 0x01	; 1
     122:	e8 e9       	ldi	r30, 0x98	; 152
     124:	f7 e3       	ldi	r31, 0x37	; 55
     126:	02 c0       	rjmp	.+4      	; 0x12c <__do_copy_data+0x10>
     128:	05 90       	lpm	r0, Z+
     12a:	0d 92       	st	X+, r0
     12c:	a8 3e       	cpi	r26, 0xE8	; 232
     12e:	b1 07       	cpc	r27, r17
     130:	d9 f7       	brne	.-10     	; 0x128 <__do_copy_data+0xc>

00000132 <__do_clear_bss>:
     132:	23 e0       	ldi	r18, 0x03	; 3
     134:	a8 ee       	ldi	r26, 0xE8	; 232
     136:	b2 e0       	ldi	r27, 0x02	; 2
     138:	01 c0       	rjmp	.+2      	; 0x13c <.do_clear_bss_start>

0000013a <.do_clear_bss_loop>:
     13a:	1d 92       	st	X+, r1

0000013c <.do_clear_bss_start>:
     13c:	aa 32       	cpi	r26, 0x2A	; 42
     13e:	b2 07       	cpc	r27, r18
     140:	e1 f7       	brne	.-8      	; 0x13a <.do_clear_bss_loop>
     142:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <main>
     146:	0c 94 ca 1b 	jmp	0x3794	; 0x3794 <_exit>

0000014a <__bad_interrupt>:
     14a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000014e <i2c_init>:
#include "i2c.h"

static bool masterMode;

void i2c_init(void)
{
     14e:	cf 93       	push	r28
     150:	df 93       	push	r29
     152:	cd b7       	in	r28, 0x3d	; 61
     154:	de b7       	in	r29, 0x3e	; 62
    TWSR &= ~((1 << TWPS1) | (1 << TWPS0)); // pre-scalar 1
     156:	89 eb       	ldi	r24, 0xB9	; 185
     158:	90 e0       	ldi	r25, 0x00	; 0
     15a:	29 eb       	ldi	r18, 0xB9	; 185
     15c:	30 e0       	ldi	r19, 0x00	; 0
     15e:	f9 01       	movw	r30, r18
     160:	20 81       	ld	r18, Z
     162:	2c 7f       	andi	r18, 0xFC	; 252
     164:	fc 01       	movw	r30, r24
     166:	20 83       	st	Z, r18
    TWBR = ((F_CPU / F_I2C) - 16) / 2; // baud rate factor 12
     168:	88 eb       	ldi	r24, 0xB8	; 184
     16a:	90 e0       	ldi	r25, 0x00	; 0
     16c:	28 e3       	ldi	r18, 0x38	; 56
     16e:	fc 01       	movw	r30, r24
     170:	20 83       	st	Z, r18
}
     172:	00 00       	nop
     174:	df 91       	pop	r29
     176:	cf 91       	pop	r28
     178:	08 95       	ret

0000017a <i2c_tx_start>:

uint8_t i2c_tx_start(bool mode)
{
     17a:	cf 93       	push	r28
     17c:	df 93       	push	r29
     17e:	00 d0       	rcall	.+0      	; 0x180 <i2c_tx_start+0x6>
     180:	cd b7       	in	r28, 0x3d	; 61
     182:	de b7       	in	r29, 0x3e	; 62
     184:	8a 83       	std	Y+2, r24	; 0x02
    int8_t status = 0;
     186:	19 82       	std	Y+1, r1	; 0x01
    masterMode = mode; // set global state of R/W bit
     188:	8a 81       	ldd	r24, Y+2	; 0x02
     18a:	80 93 e8 02 	sts	0x02E8, r24	; 0x8002e8 <__data_end>

    /* clear interrupt flag, issue start command (gain control of bus as
       master), enable I2C (SCL and SDA are automatically reconfigured) */
    TWCR |=  (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
     18e:	8c eb       	ldi	r24, 0xBC	; 188
     190:	90 e0       	ldi	r25, 0x00	; 0
     192:	2c eb       	ldi	r18, 0xBC	; 188
     194:	30 e0       	ldi	r19, 0x00	; 0
     196:	f9 01       	movw	r30, r18
     198:	20 81       	ld	r18, Z
     19a:	24 6a       	ori	r18, 0xA4	; 164
     19c:	fc 01       	movw	r30, r24
     19e:	20 83       	st	Z, r18

    /* wait until start transmitted */
    while (!(TWCR & (1 << TWINT)));
     1a0:	00 00       	nop
     1a2:	8c eb       	ldi	r24, 0xBC	; 188
     1a4:	90 e0       	ldi	r25, 0x00	; 0
     1a6:	fc 01       	movw	r30, r24
     1a8:	80 81       	ld	r24, Z
     1aa:	88 23       	and	r24, r24
     1ac:	d4 f7       	brge	.-12     	; 0x1a2 <i2c_tx_start+0x28>

    switch (TWSR & 0xF8) {
     1ae:	89 eb       	ldi	r24, 0xB9	; 185
     1b0:	90 e0       	ldi	r25, 0x00	; 0
     1b2:	fc 01       	movw	r30, r24
     1b4:	80 81       	ld	r24, Z
     1b6:	88 2f       	mov	r24, r24
     1b8:	90 e0       	ldi	r25, 0x00	; 0
     1ba:	88 7f       	andi	r24, 0xF8	; 248
     1bc:	99 27       	eor	r25, r25
     1be:	88 30       	cpi	r24, 0x08	; 8
     1c0:	91 05       	cpc	r25, r1
     1c2:	19 f0       	breq	.+6      	; 0x1ca <i2c_tx_start+0x50>
     1c4:	40 97       	sbiw	r24, 0x10	; 16
     1c6:	21 f0       	breq	.+8      	; 0x1d0 <i2c_tx_start+0x56>
     1c8:	06 c0       	rjmp	.+12     	; 0x1d6 <i2c_tx_start+0x5c>
        /* start condition sent from master */
        case 0x08:
            status = TRANSMISSION_SUCCESS;
     1ca:	8f ef       	ldi	r24, 0xFF	; 255
     1cc:	89 83       	std	Y+1, r24	; 0x01
            break;
     1ce:	06 c0       	rjmp	.+12     	; 0x1dc <i2c_tx_start+0x62>

        /* repeat start condition sent from master */
        case 0x10:
            status = TRANSMISSION_SUCCESS;
     1d0:	8f ef       	ldi	r24, 0xFF	; 255
     1d2:	89 83       	std	Y+1, r24	; 0x01
            break;
     1d4:	03 c0       	rjmp	.+6      	; 0x1dc <i2c_tx_start+0x62>

        default:
            status = TRANSMISSION_ERROR;
     1d6:	8e ef       	ldi	r24, 0xFE	; 254
     1d8:	89 83       	std	Y+1, r24	; 0x01
            break;
     1da:	00 00       	nop
    }

    return status;
     1dc:	89 81       	ldd	r24, Y+1	; 0x01
}
     1de:	0f 90       	pop	r0
     1e0:	0f 90       	pop	r0
     1e2:	df 91       	pop	r29
     1e4:	cf 91       	pop	r28
     1e6:	08 95       	ret

000001e8 <i2c_tx_address>:

uint8_t i2c_tx_address(uint8_t address)
{
     1e8:	cf 93       	push	r28
     1ea:	df 93       	push	r29
     1ec:	00 d0       	rcall	.+0      	; 0x1ee <i2c_tx_address+0x6>
     1ee:	cd b7       	in	r28, 0x3d	; 61
     1f0:	de b7       	in	r29, 0x3e	; 62
     1f2:	8a 83       	std	Y+2, r24	; 0x02
    int8_t status = 0;
     1f4:	19 82       	std	Y+1, r1	; 0x01

    TWDR = (address << 1) | masterMode;
     1f6:	8b eb       	ldi	r24, 0xBB	; 187
     1f8:	90 e0       	ldi	r25, 0x00	; 0
     1fa:	2a 81       	ldd	r18, Y+2	; 0x02
     1fc:	22 2f       	mov	r18, r18
     1fe:	30 e0       	ldi	r19, 0x00	; 0
     200:	22 0f       	add	r18, r18
     202:	33 1f       	adc	r19, r19
     204:	32 2f       	mov	r19, r18
     206:	20 91 e8 02 	lds	r18, 0x02E8	; 0x8002e8 <__data_end>
     20a:	23 2b       	or	r18, r19
     20c:	fc 01       	movw	r30, r24
     20e:	20 83       	st	Z, r18
    /* clear start command to release bus as master */
    TWCR &= ~(1 << TWSTA);
     210:	8c eb       	ldi	r24, 0xBC	; 188
     212:	90 e0       	ldi	r25, 0x00	; 0
     214:	2c eb       	ldi	r18, 0xBC	; 188
     216:	30 e0       	ldi	r19, 0x00	; 0
     218:	f9 01       	movw	r30, r18
     21a:	20 81       	ld	r18, Z
     21c:	2f 7d       	andi	r18, 0xDF	; 223
     21e:	fc 01       	movw	r30, r24
     220:	20 83       	st	Z, r18
    /* clear interrupt flag */
    TWCR |=  (1 << TWINT);
     222:	8c eb       	ldi	r24, 0xBC	; 188
     224:	90 e0       	ldi	r25, 0x00	; 0
     226:	2c eb       	ldi	r18, 0xBC	; 188
     228:	30 e0       	ldi	r19, 0x00	; 0
     22a:	f9 01       	movw	r30, r18
     22c:	20 81       	ld	r18, Z
     22e:	20 68       	ori	r18, 0x80	; 128
     230:	fc 01       	movw	r30, r24
     232:	20 83       	st	Z, r18

    /* wait until address transmitted */
    while (!(TWCR & (1 << TWINT)));
     234:	00 00       	nop
     236:	8c eb       	ldi	r24, 0xBC	; 188
     238:	90 e0       	ldi	r25, 0x00	; 0
     23a:	fc 01       	movw	r30, r24
     23c:	80 81       	ld	r24, Z
     23e:	88 23       	and	r24, r24
     240:	d4 f7       	brge	.-12     	; 0x236 <i2c_tx_address+0x4e>

    if (masterMode == MASTER_TRANSMITTER) {
     242:	80 91 e8 02 	lds	r24, 0x02E8	; 0x8002e8 <__data_end>
     246:	88 23       	and	r24, r24
     248:	e9 f4       	brne	.+58     	; 0x284 <i2c_tx_address+0x9c>
        switch (TWSR & 0xF8) {
     24a:	89 eb       	ldi	r24, 0xB9	; 185
     24c:	90 e0       	ldi	r25, 0x00	; 0
     24e:	fc 01       	movw	r30, r24
     250:	80 81       	ld	r24, Z
     252:	88 2f       	mov	r24, r24
     254:	90 e0       	ldi	r25, 0x00	; 0
     256:	88 7f       	andi	r24, 0xF8	; 248
     258:	99 27       	eor	r25, r25
     25a:	80 32       	cpi	r24, 0x20	; 32
     25c:	91 05       	cpc	r25, r1
     25e:	41 f0       	breq	.+16     	; 0x270 <i2c_tx_address+0x88>
     260:	88 33       	cpi	r24, 0x38	; 56
     262:	91 05       	cpc	r25, r1
     264:	41 f0       	breq	.+16     	; 0x276 <i2c_tx_address+0x8e>
     266:	48 97       	sbiw	r24, 0x18	; 24
     268:	49 f4       	brne	.+18     	; 0x27c <i2c_tx_address+0x94>
            /* address|write sent and ACK returned */
            case 0x18:
                status = TRANSMISSION_SUCCESS;
     26a:	8f ef       	ldi	r24, 0xFF	; 255
     26c:	89 83       	std	Y+1, r24	; 0x01
                break;
     26e:	2b c0       	rjmp	.+86     	; 0x2c6 <i2c_tx_address+0xde>

           /* address|write sent and NACK returned slave */
           case 0x20:
                status = TRANSMISSION_ERROR;
     270:	8e ef       	ldi	r24, 0xFE	; 254
     272:	89 83       	std	Y+1, r24	; 0x01
                break;
     274:	28 c0       	rjmp	.+80     	; 0x2c6 <i2c_tx_address+0xde>

            /* address|write sent and bus failure detected */
            case 0x38:
                status = TRANSMISSION_ERROR;
     276:	8e ef       	ldi	r24, 0xFE	; 254
     278:	89 83       	std	Y+1, r24	; 0x01
                break;
     27a:	25 c0       	rjmp	.+74     	; 0x2c6 <i2c_tx_address+0xde>

            default:
                status = TRANSMISSION_ERROR;
     27c:	8e ef       	ldi	r24, 0xFE	; 254
     27e:	89 83       	std	Y+1, r24	; 0x01
                break;
     280:	00 00       	nop
     282:	21 c0       	rjmp	.+66     	; 0x2c6 <i2c_tx_address+0xde>
        }
    } else if (masterMode == MASTER_RECEIVER) {
     284:	80 91 e8 02 	lds	r24, 0x02E8	; 0x8002e8 <__data_end>
     288:	81 30       	cpi	r24, 0x01	; 1
     28a:	e9 f4       	brne	.+58     	; 0x2c6 <i2c_tx_address+0xde>
        switch (TWSR & 0xF8) {
     28c:	89 eb       	ldi	r24, 0xB9	; 185
     28e:	90 e0       	ldi	r25, 0x00	; 0
     290:	fc 01       	movw	r30, r24
     292:	80 81       	ld	r24, Z
     294:	88 2f       	mov	r24, r24
     296:	90 e0       	ldi	r25, 0x00	; 0
     298:	88 7f       	andi	r24, 0xF8	; 248
     29a:	99 27       	eor	r25, r25
     29c:	80 34       	cpi	r24, 0x40	; 64
     29e:	91 05       	cpc	r25, r1
     2a0:	31 f0       	breq	.+12     	; 0x2ae <i2c_tx_address+0xc6>
     2a2:	88 34       	cpi	r24, 0x48	; 72
     2a4:	91 05       	cpc	r25, r1
     2a6:	31 f0       	breq	.+12     	; 0x2b4 <i2c_tx_address+0xcc>
     2a8:	c8 97       	sbiw	r24, 0x38	; 56
     2aa:	39 f0       	breq	.+14     	; 0x2ba <i2c_tx_address+0xd2>
     2ac:	09 c0       	rjmp	.+18     	; 0x2c0 <i2c_tx_address+0xd8>
            /* address|read sent and ACK returned */
            case 0x40:
                status = TRANSMISSION_SUCCESS;
     2ae:	8f ef       	ldi	r24, 0xFF	; 255
     2b0:	89 83       	std	Y+1, r24	; 0x01
                break;
     2b2:	09 c0       	rjmp	.+18     	; 0x2c6 <i2c_tx_address+0xde>

            /* address|read sent and NACK returned */
            case 0x48:
                status = TRANSMISSION_ERROR;
     2b4:	8e ef       	ldi	r24, 0xFE	; 254
     2b6:	89 83       	std	Y+1, r24	; 0x01
                break;
     2b8:	06 c0       	rjmp	.+12     	; 0x2c6 <i2c_tx_address+0xde>

            case 0x38:
                status = TRANSMISSION_ERROR;
     2ba:	8e ef       	ldi	r24, 0xFE	; 254
     2bc:	89 83       	std	Y+1, r24	; 0x01
                break;
     2be:	03 c0       	rjmp	.+6      	; 0x2c6 <i2c_tx_address+0xde>

            default:
                status = TRANSMISSION_ERROR;
     2c0:	8e ef       	ldi	r24, 0xFE	; 254
     2c2:	89 83       	std	Y+1, r24	; 0x01
                break;
     2c4:	00 00       	nop
        }
    }

    return status;
     2c6:	89 81       	ldd	r24, Y+1	; 0x01
}
     2c8:	0f 90       	pop	r0
     2ca:	0f 90       	pop	r0
     2cc:	df 91       	pop	r29
     2ce:	cf 91       	pop	r28
     2d0:	08 95       	ret

000002d2 <i2c_tx_byte>:

uint8_t i2c_tx_byte(uint8_t byteData)
{
     2d2:	cf 93       	push	r28
     2d4:	df 93       	push	r29
     2d6:	00 d0       	rcall	.+0      	; 0x2d8 <i2c_tx_byte+0x6>
     2d8:	cd b7       	in	r28, 0x3d	; 61
     2da:	de b7       	in	r29, 0x3e	; 62
     2dc:	8a 83       	std	Y+2, r24	; 0x02
    int8_t status = 0;
     2de:	19 82       	std	Y+1, r1	; 0x01
    TWDR  = byteData; // load data buffer with data to be transmitted
     2e0:	8b eb       	ldi	r24, 0xBB	; 187
     2e2:	90 e0       	ldi	r25, 0x00	; 0
     2e4:	2a 81       	ldd	r18, Y+2	; 0x02
     2e6:	fc 01       	movw	r30, r24
     2e8:	20 83       	st	Z, r18
    TWCR |= (1 << TWINT); // clear interrupt flag
     2ea:	8c eb       	ldi	r24, 0xBC	; 188
     2ec:	90 e0       	ldi	r25, 0x00	; 0
     2ee:	2c eb       	ldi	r18, 0xBC	; 188
     2f0:	30 e0       	ldi	r19, 0x00	; 0
     2f2:	f9 01       	movw	r30, r18
     2f4:	20 81       	ld	r18, Z
     2f6:	20 68       	ori	r18, 0x80	; 128
     2f8:	fc 01       	movw	r30, r24
     2fa:	20 83       	st	Z, r18

    /* wait until data transmitted */
    while (!(TWCR & (1 << TWINT)));
     2fc:	00 00       	nop
     2fe:	8c eb       	ldi	r24, 0xBC	; 188
     300:	90 e0       	ldi	r25, 0x00	; 0
     302:	fc 01       	movw	r30, r24
     304:	80 81       	ld	r24, Z
     306:	88 23       	and	r24, r24
     308:	d4 f7       	brge	.-12     	; 0x2fe <i2c_tx_byte+0x2c>

    /* retrieve transmission status codes */
    switch (TWSR & 0xF8) {
     30a:	89 eb       	ldi	r24, 0xB9	; 185
     30c:	90 e0       	ldi	r25, 0x00	; 0
     30e:	fc 01       	movw	r30, r24
     310:	80 81       	ld	r24, Z
     312:	88 2f       	mov	r24, r24
     314:	90 e0       	ldi	r25, 0x00	; 0
     316:	88 7f       	andi	r24, 0xF8	; 248
     318:	99 27       	eor	r25, r25
     31a:	80 33       	cpi	r24, 0x30	; 48
     31c:	91 05       	cpc	r25, r1
     31e:	41 f0       	breq	.+16     	; 0x330 <i2c_tx_byte+0x5e>
     320:	88 33       	cpi	r24, 0x38	; 56
     322:	91 05       	cpc	r25, r1
     324:	41 f0       	breq	.+16     	; 0x336 <i2c_tx_byte+0x64>
     326:	88 97       	sbiw	r24, 0x28	; 40
     328:	49 f4       	brne	.+18     	; 0x33c <i2c_tx_byte+0x6a>
        /* byte sent and ACK returned */
        case 0x28:
            status = TRANSMISSION_SUCCESS;
     32a:	8f ef       	ldi	r24, 0xFF	; 255
     32c:	89 83       	std	Y+1, r24	; 0x01
            break;
     32e:	09 c0       	rjmp	.+18     	; 0x342 <i2c_tx_byte+0x70>

        /* byte sent and NACK returned */
        case 0x30:
            status = TRANSMISSION_ERROR;
     330:	8e ef       	ldi	r24, 0xFE	; 254
     332:	89 83       	std	Y+1, r24	; 0x01
            break;
     334:	06 c0       	rjmp	.+12     	; 0x342 <i2c_tx_byte+0x70>

        /* byte sent and bus failure detected */
        case 0x38:
            status = TRANSMISSION_ERROR;
     336:	8e ef       	ldi	r24, 0xFE	; 254
     338:	89 83       	std	Y+1, r24	; 0x01
            break;
     33a:	03 c0       	rjmp	.+6      	; 0x342 <i2c_tx_byte+0x70>

        default:
            status = TRANSMISSION_ERROR;
     33c:	8e ef       	ldi	r24, 0xFE	; 254
     33e:	89 83       	std	Y+1, r24	; 0x01
            break;
     340:	00 00       	nop
    }

    return status;
     342:	89 81       	ldd	r24, Y+1	; 0x01
}
     344:	0f 90       	pop	r0
     346:	0f 90       	pop	r0
     348:	df 91       	pop	r29
     34a:	cf 91       	pop	r28
     34c:	08 95       	ret

0000034e <i2c_timeout>:

bool i2c_timeout(void)
{
     34e:	cf 93       	push	r28
     350:	df 93       	push	r29
     352:	00 d0       	rcall	.+0      	; 0x354 <i2c_timeout+0x6>
     354:	cd b7       	in	r28, 0x3d	; 61
     356:	de b7       	in	r29, 0x3e	; 62
    uint8_t time = TIMEOUT;
     358:	82 e3       	ldi	r24, 0x32	; 50
     35a:	89 83       	std	Y+1, r24	; 0x01
    int8_t status = BUS_DISCONNECTED;
     35c:	8c ef       	ldi	r24, 0xFC	; 252
     35e:	8a 83       	std	Y+2, r24	; 0x02

    while (time-- > 0) {
     360:	09 c0       	rjmp	.+18     	; 0x374 <i2c_timeout+0x26>
        /* check to see if bus is ready */
        if ((TWCR & (1 << TWINT))) {
     362:	8c eb       	ldi	r24, 0xBC	; 188
     364:	90 e0       	ldi	r25, 0x00	; 0
     366:	fc 01       	movw	r30, r24
     368:	80 81       	ld	r24, Z
     36a:	88 23       	and	r24, r24
     36c:	1c f4       	brge	.+6      	; 0x374 <i2c_timeout+0x26>
            status = BUS_CONNECTED;
     36e:	8d ef       	ldi	r24, 0xFD	; 253
     370:	8a 83       	std	Y+2, r24	; 0x02
            break;
     372:	06 c0       	rjmp	.+12     	; 0x380 <i2c_timeout+0x32>
bool i2c_timeout(void)
{
    uint8_t time = TIMEOUT;
    int8_t status = BUS_DISCONNECTED;

    while (time-- > 0) {
     374:	89 81       	ldd	r24, Y+1	; 0x01
     376:	9f ef       	ldi	r25, 0xFF	; 255
     378:	98 0f       	add	r25, r24
     37a:	99 83       	std	Y+1, r25	; 0x01
     37c:	88 23       	and	r24, r24
     37e:	89 f7       	brne	.-30     	; 0x362 <i2c_timeout+0x14>
            status = BUS_CONNECTED;
            break;
        }
    }

    return status;
     380:	8a 81       	ldd	r24, Y+2	; 0x02
}
     382:	0f 90       	pop	r0
     384:	0f 90       	pop	r0
     386:	df 91       	pop	r29
     388:	cf 91       	pop	r28
     38a:	08 95       	ret

0000038c <i2c_rx_byte>:

uint8_t i2c_rx_byte(bool response)
{
     38c:	cf 93       	push	r28
     38e:	df 93       	push	r29
     390:	00 d0       	rcall	.+0      	; 0x392 <i2c_rx_byte+0x6>
     392:	cd b7       	in	r28, 0x3d	; 61
     394:	de b7       	in	r29, 0x3e	; 62
     396:	8a 83       	std	Y+2, r24	; 0x02
    int8_t status;

    if (response == ACK) {
     398:	8a 81       	ldd	r24, Y+2	; 0x02
     39a:	88 23       	and	r24, r24
     39c:	51 f4       	brne	.+20     	; 0x3b2 <i2c_rx_byte+0x26>
        TWCR |= (1 << TWEA); // generate ACK
     39e:	8c eb       	ldi	r24, 0xBC	; 188
     3a0:	90 e0       	ldi	r25, 0x00	; 0
     3a2:	2c eb       	ldi	r18, 0xBC	; 188
     3a4:	30 e0       	ldi	r19, 0x00	; 0
     3a6:	f9 01       	movw	r30, r18
     3a8:	20 81       	ld	r18, Z
     3aa:	20 64       	ori	r18, 0x40	; 64
     3ac:	fc 01       	movw	r30, r24
     3ae:	20 83       	st	Z, r18
     3b0:	09 c0       	rjmp	.+18     	; 0x3c4 <i2c_rx_byte+0x38>
    } else {
        TWCR &= ~(1 << TWEA); // generate NACK
     3b2:	8c eb       	ldi	r24, 0xBC	; 188
     3b4:	90 e0       	ldi	r25, 0x00	; 0
     3b6:	2c eb       	ldi	r18, 0xBC	; 188
     3b8:	30 e0       	ldi	r19, 0x00	; 0
     3ba:	f9 01       	movw	r30, r18
     3bc:	20 81       	ld	r18, Z
     3be:	2f 7b       	andi	r18, 0xBF	; 191
     3c0:	fc 01       	movw	r30, r24
     3c2:	20 83       	st	Z, r18
    }

    /* clear interrupt flag */
    TWCR |= (1 << TWINT);
     3c4:	8c eb       	ldi	r24, 0xBC	; 188
     3c6:	90 e0       	ldi	r25, 0x00	; 0
     3c8:	2c eb       	ldi	r18, 0xBC	; 188
     3ca:	30 e0       	ldi	r19, 0x00	; 0
     3cc:	f9 01       	movw	r30, r18
     3ce:	20 81       	ld	r18, Z
     3d0:	20 68       	ori	r18, 0x80	; 128
     3d2:	fc 01       	movw	r30, r24
     3d4:	20 83       	st	Z, r18

    /* detect bus time-out */
    if (i2c_timeout() != BUS_DISCONNECTED) {
     3d6:	0e 94 a7 01 	call	0x34e	; 0x34e <i2c_timeout>
        /* retrieve transmission status codes or received data */
        switch (TWSR & 0xF8) {
     3da:	89 eb       	ldi	r24, 0xB9	; 185
     3dc:	90 e0       	ldi	r25, 0x00	; 0
     3de:	fc 01       	movw	r30, r24
     3e0:	80 81       	ld	r24, Z
     3e2:	88 2f       	mov	r24, r24
     3e4:	90 e0       	ldi	r25, 0x00	; 0
     3e6:	88 7f       	andi	r24, 0xF8	; 248
     3e8:	99 27       	eor	r25, r25
     3ea:	80 35       	cpi	r24, 0x50	; 80
     3ec:	91 05       	cpc	r25, r1
     3ee:	31 f0       	breq	.+12     	; 0x3fc <i2c_rx_byte+0x70>
     3f0:	88 35       	cpi	r24, 0x58	; 88
     3f2:	91 05       	cpc	r25, r1
     3f4:	49 f0       	breq	.+18     	; 0x408 <__LOCK_REGION_LENGTH__+0x8>
     3f6:	c8 97       	sbiw	r24, 0x38	; 56
     3f8:	69 f0       	breq	.+26     	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
     3fa:	0f c0       	rjmp	.+30     	; 0x41a <__LOCK_REGION_LENGTH__+0x1a>
            /* data byte read and ACK returned by master */
            case 0x50:
                status = TWDR;
     3fc:	8b eb       	ldi	r24, 0xBB	; 187
     3fe:	90 e0       	ldi	r25, 0x00	; 0
     400:	fc 01       	movw	r30, r24
     402:	80 81       	ld	r24, Z
     404:	89 83       	std	Y+1, r24	; 0x01
                break;
     406:	0c c0       	rjmp	.+24     	; 0x420 <__LOCK_REGION_LENGTH__+0x20>

            /* data byte read and NACK returned by master */
            case 0x58:
                status = TWDR;
     408:	8b eb       	ldi	r24, 0xBB	; 187
     40a:	90 e0       	ldi	r25, 0x00	; 0
     40c:	fc 01       	movw	r30, r24
     40e:	80 81       	ld	r24, Z
     410:	89 83       	std	Y+1, r24	; 0x01
                break;
     412:	06 c0       	rjmp	.+12     	; 0x420 <__LOCK_REGION_LENGTH__+0x20>

            /* bus failure detected */
            case 0x38:
                status = TRANSMISSION_ERROR;
     414:	8e ef       	ldi	r24, 0xFE	; 254
     416:	89 83       	std	Y+1, r24	; 0x01
                break;
     418:	03 c0       	rjmp	.+6      	; 0x420 <__LOCK_REGION_LENGTH__+0x20>

            default:
                status = TRANSMISSION_ERROR;
     41a:	8e ef       	ldi	r24, 0xFE	; 254
     41c:	89 83       	std	Y+1, r24	; 0x01
                break;
     41e:	00 00       	nop
        }
    } else {
        status = TRANSMISSION_ERROR;
    }

    return status;
     420:	89 81       	ldd	r24, Y+1	; 0x01
}
     422:	0f 90       	pop	r0
     424:	0f 90       	pop	r0
     426:	df 91       	pop	r29
     428:	cf 91       	pop	r28
     42a:	08 95       	ret

0000042c <i2c_tx_stop>:

void i2c_tx_stop(void)
{
     42c:	cf 93       	push	r28
     42e:	df 93       	push	r29
     430:	cd b7       	in	r28, 0x3d	; 61
     432:	de b7       	in	r29, 0x3e	; 62
    /* clear interrupt flag, issue stop command (cleared automatically) */
    TWCR |= (1 << TWINT) | (1 << TWSTO);
     434:	8c eb       	ldi	r24, 0xBC	; 188
     436:	90 e0       	ldi	r25, 0x00	; 0
     438:	2c eb       	ldi	r18, 0xBC	; 188
     43a:	30 e0       	ldi	r19, 0x00	; 0
     43c:	f9 01       	movw	r30, r18
     43e:	20 81       	ld	r18, Z
     440:	20 69       	ori	r18, 0x90	; 144
     442:	fc 01       	movw	r30, r24
     444:	20 83       	st	Z, r18

    while (!(TWCR & (1 << TWSTO))); // wait until stop transmitted
     446:	00 00       	nop
     448:	8c eb       	ldi	r24, 0xBC	; 188
     44a:	90 e0       	ldi	r25, 0x00	; 0
     44c:	fc 01       	movw	r30, r24
     44e:	80 81       	ld	r24, Z
     450:	88 2f       	mov	r24, r24
     452:	90 e0       	ldi	r25, 0x00	; 0
     454:	80 71       	andi	r24, 0x10	; 16
     456:	99 27       	eor	r25, r25
     458:	89 2b       	or	r24, r25
     45a:	b1 f3       	breq	.-20     	; 0x448 <i2c_tx_stop+0x1c>
}
     45c:	00 00       	nop
     45e:	df 91       	pop	r29
     460:	cf 91       	pop	r28
     462:	08 95       	ret

00000464 <lcd_port_init_4Bit>:
 */ 
#include "lcd.h"


void lcd_port_init_4Bit()
{
     464:	cf 93       	push	r28
     466:	df 93       	push	r29
     468:	cd b7       	in	r28, 0x3d	; 61
     46a:	de b7       	in	r29, 0x3e	; 62
	DDR(RS_PORT) |= 1<<RS_PIN;
     46c:	8a e2       	ldi	r24, 0x2A	; 42
     46e:	90 e0       	ldi	r25, 0x00	; 0
     470:	2a e2       	ldi	r18, 0x2A	; 42
     472:	30 e0       	ldi	r19, 0x00	; 0
     474:	f9 01       	movw	r30, r18
     476:	20 81       	ld	r18, Z
     478:	24 60       	ori	r18, 0x04	; 4
     47a:	fc 01       	movw	r30, r24
     47c:	20 83       	st	Z, r18
	DDR(RW_PORT) |= 1<<RW_PIN;
     47e:	8a e2       	ldi	r24, 0x2A	; 42
     480:	90 e0       	ldi	r25, 0x00	; 0
     482:	2a e2       	ldi	r18, 0x2A	; 42
     484:	30 e0       	ldi	r19, 0x00	; 0
     486:	f9 01       	movw	r30, r18
     488:	20 81       	ld	r18, Z
     48a:	22 60       	ori	r18, 0x02	; 2
     48c:	fc 01       	movw	r30, r24
     48e:	20 83       	st	Z, r18
	DDR(EN_PORT) |= 1<<EN_PIN;
     490:	8a e2       	ldi	r24, 0x2A	; 42
     492:	90 e0       	ldi	r25, 0x00	; 0
     494:	2a e2       	ldi	r18, 0x2A	; 42
     496:	30 e0       	ldi	r19, 0x00	; 0
     498:	f9 01       	movw	r30, r18
     49a:	20 81       	ld	r18, Z
     49c:	21 60       	ori	r18, 0x01	; 1
     49e:	fc 01       	movw	r30, r24
     4a0:	20 83       	st	Z, r18
	
	DDR(D4_PORT) |= 1<<D4_PIN;
     4a2:	8a e2       	ldi	r24, 0x2A	; 42
     4a4:	90 e0       	ldi	r25, 0x00	; 0
     4a6:	2a e2       	ldi	r18, 0x2A	; 42
     4a8:	30 e0       	ldi	r19, 0x00	; 0
     4aa:	f9 01       	movw	r30, r18
     4ac:	20 81       	ld	r18, Z
     4ae:	20 61       	ori	r18, 0x10	; 16
     4b0:	fc 01       	movw	r30, r24
     4b2:	20 83       	st	Z, r18
	DDR(D5_PORT) |= 1<<D5_PIN;
     4b4:	8a e2       	ldi	r24, 0x2A	; 42
     4b6:	90 e0       	ldi	r25, 0x00	; 0
     4b8:	2a e2       	ldi	r18, 0x2A	; 42
     4ba:	30 e0       	ldi	r19, 0x00	; 0
     4bc:	f9 01       	movw	r30, r18
     4be:	20 81       	ld	r18, Z
     4c0:	20 62       	ori	r18, 0x20	; 32
     4c2:	fc 01       	movw	r30, r24
     4c4:	20 83       	st	Z, r18
	DDR(D6_PORT) |= 1<<D6_PIN;
     4c6:	8a e2       	ldi	r24, 0x2A	; 42
     4c8:	90 e0       	ldi	r25, 0x00	; 0
     4ca:	2a e2       	ldi	r18, 0x2A	; 42
     4cc:	30 e0       	ldi	r19, 0x00	; 0
     4ce:	f9 01       	movw	r30, r18
     4d0:	20 81       	ld	r18, Z
     4d2:	20 64       	ori	r18, 0x40	; 64
     4d4:	fc 01       	movw	r30, r24
     4d6:	20 83       	st	Z, r18
	DDR(D7_PORT) |= 1<<D7_PIN;
     4d8:	8a e2       	ldi	r24, 0x2A	; 42
     4da:	90 e0       	ldi	r25, 0x00	; 0
     4dc:	2a e2       	ldi	r18, 0x2A	; 42
     4de:	30 e0       	ldi	r19, 0x00	; 0
     4e0:	f9 01       	movw	r30, r18
     4e2:	20 81       	ld	r18, Z
     4e4:	20 68       	ori	r18, 0x80	; 128
     4e6:	fc 01       	movw	r30, r24
     4e8:	20 83       	st	Z, r18
}
     4ea:	00 00       	nop
     4ec:	df 91       	pop	r29
     4ee:	cf 91       	pop	r28
     4f0:	08 95       	ret

000004f2 <map_data_port>:


void map_data_port(unsigned char data)
{
     4f2:	cf 93       	push	r28
     4f4:	df 93       	push	r29
     4f6:	00 d0       	rcall	.+0      	; 0x4f8 <map_data_port+0x6>
     4f8:	cd b7       	in	r28, 0x3d	; 61
     4fa:	de b7       	in	r29, 0x3e	; 62
     4fc:	8a 83       	std	Y+2, r24	; 0x02
	/*MAP_BIT(data,0,D4_PORT,D4_PIN);
	MAP_BIT(data,1,D5_PORT,D5_PIN);
	MAP_BIT(data,2,D6_PORT,D6_PIN);
	MAP_BIT(data,3,D7_PORT,D7_PIN);
	*/
	uint8_t state = (data>>0)&0b00000001;
     4fe:	8a 81       	ldd	r24, Y+2	; 0x02
     500:	81 70       	andi	r24, 0x01	; 1
     502:	89 83       	std	Y+1, r24	; 0x01
	WRITE_PIN(D4_PORT,D4_PIN,state);
     504:	8b e2       	ldi	r24, 0x2B	; 43
     506:	90 e0       	ldi	r25, 0x00	; 0
     508:	2b e2       	ldi	r18, 0x2B	; 43
     50a:	30 e0       	ldi	r19, 0x00	; 0
     50c:	f9 01       	movw	r30, r18
     50e:	20 81       	ld	r18, Z
     510:	42 2f       	mov	r20, r18
     512:	4f 7e       	andi	r20, 0xEF	; 239
     514:	29 81       	ldd	r18, Y+1	; 0x01
     516:	22 2f       	mov	r18, r18
     518:	30 e0       	ldi	r19, 0x00	; 0
     51a:	22 95       	swap	r18
     51c:	32 95       	swap	r19
     51e:	30 7f       	andi	r19, 0xF0	; 240
     520:	32 27       	eor	r19, r18
     522:	20 7f       	andi	r18, 0xF0	; 240
     524:	32 27       	eor	r19, r18
     526:	24 2b       	or	r18, r20
     528:	fc 01       	movw	r30, r24
     52a:	20 83       	st	Z, r18
	
	state = (data>>1)&0b00000001;
     52c:	8a 81       	ldd	r24, Y+2	; 0x02
     52e:	86 95       	lsr	r24
     530:	81 70       	andi	r24, 0x01	; 1
     532:	89 83       	std	Y+1, r24	; 0x01
	WRITE_PIN(D5_PORT,D5_PIN,state);
     534:	8b e2       	ldi	r24, 0x2B	; 43
     536:	90 e0       	ldi	r25, 0x00	; 0
     538:	2b e2       	ldi	r18, 0x2B	; 43
     53a:	30 e0       	ldi	r19, 0x00	; 0
     53c:	f9 01       	movw	r30, r18
     53e:	20 81       	ld	r18, Z
     540:	42 2f       	mov	r20, r18
     542:	4f 7d       	andi	r20, 0xDF	; 223
     544:	29 81       	ldd	r18, Y+1	; 0x01
     546:	22 2f       	mov	r18, r18
     548:	30 e0       	ldi	r19, 0x00	; 0
     54a:	22 0f       	add	r18, r18
     54c:	33 1f       	adc	r19, r19
     54e:	22 95       	swap	r18
     550:	32 95       	swap	r19
     552:	30 7f       	andi	r19, 0xF0	; 240
     554:	32 27       	eor	r19, r18
     556:	20 7f       	andi	r18, 0xF0	; 240
     558:	32 27       	eor	r19, r18
     55a:	24 2b       	or	r18, r20
     55c:	fc 01       	movw	r30, r24
     55e:	20 83       	st	Z, r18
	
	state = (data>>2)&0b00000001;
     560:	8a 81       	ldd	r24, Y+2	; 0x02
     562:	86 95       	lsr	r24
     564:	86 95       	lsr	r24
     566:	81 70       	andi	r24, 0x01	; 1
     568:	89 83       	std	Y+1, r24	; 0x01
	WRITE_PIN(D6_PORT,D6_PIN,state);
     56a:	8b e2       	ldi	r24, 0x2B	; 43
     56c:	90 e0       	ldi	r25, 0x00	; 0
     56e:	2b e2       	ldi	r18, 0x2B	; 43
     570:	30 e0       	ldi	r19, 0x00	; 0
     572:	f9 01       	movw	r30, r18
     574:	20 81       	ld	r18, Z
     576:	42 2f       	mov	r20, r18
     578:	4f 7b       	andi	r20, 0xBF	; 191
     57a:	29 81       	ldd	r18, Y+1	; 0x01
     57c:	22 2f       	mov	r18, r18
     57e:	30 e0       	ldi	r19, 0x00	; 0
     580:	00 24       	eor	r0, r0
     582:	36 95       	lsr	r19
     584:	27 95       	ror	r18
     586:	07 94       	ror	r0
     588:	36 95       	lsr	r19
     58a:	27 95       	ror	r18
     58c:	07 94       	ror	r0
     58e:	32 2f       	mov	r19, r18
     590:	20 2d       	mov	r18, r0
     592:	24 2b       	or	r18, r20
     594:	fc 01       	movw	r30, r24
     596:	20 83       	st	Z, r18
	
	state = (data>>3)&0b00000001;
     598:	8a 81       	ldd	r24, Y+2	; 0x02
     59a:	86 95       	lsr	r24
     59c:	86 95       	lsr	r24
     59e:	86 95       	lsr	r24
     5a0:	81 70       	andi	r24, 0x01	; 1
     5a2:	89 83       	std	Y+1, r24	; 0x01
	WRITE_PIN(D7_PORT,D7_PIN,state);
     5a4:	8b e2       	ldi	r24, 0x2B	; 43
     5a6:	90 e0       	ldi	r25, 0x00	; 0
     5a8:	2b e2       	ldi	r18, 0x2B	; 43
     5aa:	30 e0       	ldi	r19, 0x00	; 0
     5ac:	f9 01       	movw	r30, r18
     5ae:	20 81       	ld	r18, Z
     5b0:	42 2f       	mov	r20, r18
     5b2:	4f 77       	andi	r20, 0x7F	; 127
     5b4:	29 81       	ldd	r18, Y+1	; 0x01
     5b6:	22 2f       	mov	r18, r18
     5b8:	30 e0       	ldi	r19, 0x00	; 0
     5ba:	36 95       	lsr	r19
     5bc:	32 2f       	mov	r19, r18
     5be:	22 27       	eor	r18, r18
     5c0:	37 95       	ror	r19
     5c2:	27 95       	ror	r18
     5c4:	24 2b       	or	r18, r20
     5c6:	fc 01       	movw	r30, r24
     5c8:	20 83       	st	Z, r18
	

}
     5ca:	00 00       	nop
     5cc:	0f 90       	pop	r0
     5ce:	0f 90       	pop	r0
     5d0:	df 91       	pop	r29
     5d2:	cf 91       	pop	r28
     5d4:	08 95       	ret

000005d6 <lcd_write_nibble>:

void lcd_write_nibble(unsigned char data, uint8_t type)
{
     5d6:	cf 93       	push	r28
     5d8:	df 93       	push	r29
     5da:	00 d0       	rcall	.+0      	; 0x5dc <lcd_write_nibble+0x6>
     5dc:	cd b7       	in	r28, 0x3d	; 61
     5de:	de b7       	in	r29, 0x3e	; 62
     5e0:	89 83       	std	Y+1, r24	; 0x01
     5e2:	6a 83       	std	Y+2, r22	; 0x02
	
	if(type == 0)
     5e4:	8a 81       	ldd	r24, Y+2	; 0x02
     5e6:	88 23       	and	r24, r24
     5e8:	51 f4       	brne	.+20     	; 0x5fe <lcd_write_nibble+0x28>
	{
		RS_LO(); //for command
     5ea:	8b e2       	ldi	r24, 0x2B	; 43
     5ec:	90 e0       	ldi	r25, 0x00	; 0
     5ee:	2b e2       	ldi	r18, 0x2B	; 43
     5f0:	30 e0       	ldi	r19, 0x00	; 0
     5f2:	f9 01       	movw	r30, r18
     5f4:	20 81       	ld	r18, Z
     5f6:	2b 7f       	andi	r18, 0xFB	; 251
     5f8:	fc 01       	movw	r30, r24
     5fa:	20 83       	st	Z, r18
     5fc:	09 c0       	rjmp	.+18     	; 0x610 <lcd_write_nibble+0x3a>
	}
	else
	{
		RS_HI(); //for data
     5fe:	8b e2       	ldi	r24, 0x2B	; 43
     600:	90 e0       	ldi	r25, 0x00	; 0
     602:	2b e2       	ldi	r18, 0x2B	; 43
     604:	30 e0       	ldi	r19, 0x00	; 0
     606:	f9 01       	movw	r30, r18
     608:	20 81       	ld	r18, Z
     60a:	24 60       	ori	r18, 0x04	; 4
     60c:	fc 01       	movw	r30, r24
     60e:	20 83       	st	Z, r18
	}
	RW_LO(); //for write
     610:	8b e2       	ldi	r24, 0x2B	; 43
     612:	90 e0       	ldi	r25, 0x00	; 0
     614:	2b e2       	ldi	r18, 0x2B	; 43
     616:	30 e0       	ldi	r19, 0x00	; 0
     618:	f9 01       	movw	r30, r18
     61a:	20 81       	ld	r18, Z
     61c:	2d 7f       	andi	r18, 0xFD	; 253
     61e:	fc 01       	movw	r30, r24
     620:	20 83       	st	Z, r18
	
	EN_LO();
     622:	8b e2       	ldi	r24, 0x2B	; 43
     624:	90 e0       	ldi	r25, 0x00	; 0
     626:	2b e2       	ldi	r18, 0x2B	; 43
     628:	30 e0       	ldi	r19, 0x00	; 0
     62a:	f9 01       	movw	r30, r18
     62c:	20 81       	ld	r18, Z
     62e:	2e 7f       	andi	r18, 0xFE	; 254
     630:	fc 01       	movw	r30, r24
     632:	20 83       	st	Z, r18
	EN_HI();
     634:	8b e2       	ldi	r24, 0x2B	; 43
     636:	90 e0       	ldi	r25, 0x00	; 0
     638:	2b e2       	ldi	r18, 0x2B	; 43
     63a:	30 e0       	ldi	r19, 0x00	; 0
     63c:	f9 01       	movw	r30, r18
     63e:	20 81       	ld	r18, Z
     640:	21 60       	ori	r18, 0x01	; 1
     642:	fc 01       	movw	r30, r24
     644:	20 83       	st	Z, r18
	map_data_port(data);
     646:	89 81       	ldd	r24, Y+1	; 0x01
     648:	0e 94 79 02 	call	0x4f2	; 0x4f2 <map_data_port>
	EN_LO();
     64c:	8b e2       	ldi	r24, 0x2B	; 43
     64e:	90 e0       	ldi	r25, 0x00	; 0
     650:	2b e2       	ldi	r18, 0x2B	; 43
     652:	30 e0       	ldi	r19, 0x00	; 0
     654:	f9 01       	movw	r30, r18
     656:	20 81       	ld	r18, Z
     658:	2e 7f       	andi	r18, 0xFE	; 254
     65a:	fc 01       	movw	r30, r24
     65c:	20 83       	st	Z, r18
	
}
     65e:	00 00       	nop
     660:	0f 90       	pop	r0
     662:	0f 90       	pop	r0
     664:	df 91       	pop	r29
     666:	cf 91       	pop	r28
     668:	08 95       	ret

0000066a <lcd_write_byte>:

void lcd_write_byte(unsigned char data, uint8_t type)
{
     66a:	cf 93       	push	r28
     66c:	df 93       	push	r29
     66e:	cd b7       	in	r28, 0x3d	; 61
     670:	de b7       	in	r29, 0x3e	; 62
     672:	a3 97       	sbiw	r28, 0x23	; 35
     674:	0f b6       	in	r0, 0x3f	; 63
     676:	f8 94       	cli
     678:	de bf       	out	0x3e, r29	; 62
     67a:	0f be       	out	0x3f, r0	; 63
     67c:	cd bf       	out	0x3d, r28	; 61
     67e:	8a a3       	std	Y+34, r24	; 0x22
     680:	6b a3       	std	Y+35, r22	; 0x23
	uint8_t temp;
	
	temp = (data>>4)& 0X0F;
     682:	8a a1       	ldd	r24, Y+34	; 0x22
     684:	82 95       	swap	r24
     686:	8f 70       	andi	r24, 0x0F	; 15
     688:	89 83       	std	Y+1, r24	; 0x01
	lcd_write_nibble(temp,type);//Sending high nibble
     68a:	6b a1       	ldd	r22, Y+35	; 0x23
     68c:	89 81       	ldd	r24, Y+1	; 0x01
     68e:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <lcd_write_nibble>
	
	temp = data & 0X0F;
     692:	8a a1       	ldd	r24, Y+34	; 0x22
     694:	8f 70       	andi	r24, 0x0F	; 15
     696:	89 83       	std	Y+1, r24	; 0x01
	lcd_write_nibble(temp,type);//Sending lower nible
     698:	6b a1       	ldd	r22, Y+35	; 0x23
     69a:	89 81       	ldd	r24, Y+1	; 0x01
     69c:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <lcd_write_nibble>
     6a0:	80 e0       	ldi	r24, 0x00	; 0
     6a2:	90 e0       	ldi	r25, 0x00	; 0
     6a4:	a0 e2       	ldi	r26, 0x20	; 32
     6a6:	b2 e4       	ldi	r27, 0x42	; 66
     6a8:	8a 83       	std	Y+2, r24	; 0x02
     6aa:	9b 83       	std	Y+3, r25	; 0x03
     6ac:	ac 83       	std	Y+4, r26	; 0x04
     6ae:	bd 83       	std	Y+5, r27	; 0x05
	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint8_t __ticks;
	double __tmp2 ;
	__tmp = ((F_CPU) / 3e6) * __us;
     6b0:	2b ea       	ldi	r18, 0xAB	; 171
     6b2:	3a ea       	ldi	r19, 0xAA	; 170
     6b4:	4a ea       	ldi	r20, 0xAA	; 170
     6b6:	50 e4       	ldi	r21, 0x40	; 64
     6b8:	6a 81       	ldd	r22, Y+2	; 0x02
     6ba:	7b 81       	ldd	r23, Y+3	; 0x03
     6bc:	8c 81       	ldd	r24, Y+4	; 0x04
     6be:	9d 81       	ldd	r25, Y+5	; 0x05
     6c0:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
     6c4:	dc 01       	movw	r26, r24
     6c6:	cb 01       	movw	r24, r22
     6c8:	8e 83       	std	Y+6, r24	; 0x06
     6ca:	9f 83       	std	Y+7, r25	; 0x07
     6cc:	a8 87       	std	Y+8, r26	; 0x08
     6ce:	b9 87       	std	Y+9, r27	; 0x09
	__tmp2 = ((F_CPU) / 4e6) * __us;
     6d0:	20 e0       	ldi	r18, 0x00	; 0
     6d2:	30 e0       	ldi	r19, 0x00	; 0
     6d4:	40 e8       	ldi	r20, 0x80	; 128
     6d6:	50 e4       	ldi	r21, 0x40	; 64
     6d8:	6a 81       	ldd	r22, Y+2	; 0x02
     6da:	7b 81       	ldd	r23, Y+3	; 0x03
     6dc:	8c 81       	ldd	r24, Y+4	; 0x04
     6de:	9d 81       	ldd	r25, Y+5	; 0x05
     6e0:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
     6e4:	dc 01       	movw	r26, r24
     6e6:	cb 01       	movw	r24, r22
     6e8:	8a 87       	std	Y+10, r24	; 0x0a
     6ea:	9b 87       	std	Y+11, r25	; 0x0b
     6ec:	ac 87       	std	Y+12, r26	; 0x0c
     6ee:	bd 87       	std	Y+13, r27	; 0x0d
	if (__tmp < 1.0)
     6f0:	20 e0       	ldi	r18, 0x00	; 0
     6f2:	30 e0       	ldi	r19, 0x00	; 0
     6f4:	40 e8       	ldi	r20, 0x80	; 128
     6f6:	5f e3       	ldi	r21, 0x3F	; 63
     6f8:	6e 81       	ldd	r22, Y+6	; 0x06
     6fa:	7f 81       	ldd	r23, Y+7	; 0x07
     6fc:	88 85       	ldd	r24, Y+8	; 0x08
     6fe:	99 85       	ldd	r25, Y+9	; 0x09
     700:	0e 94 00 1a 	call	0x3400	; 0x3400 <__cmpsf2>
     704:	88 23       	and	r24, r24
     706:	1c f4       	brge	.+6      	; 0x70e <lcd_write_byte+0xa4>
		__ticks = 1;
     708:	81 e0       	ldi	r24, 0x01	; 1
     70a:	8e 87       	std	Y+14, r24	; 0x0e
     70c:	b2 c0       	rjmp	.+356    	; 0x872 <lcd_write_byte+0x208>
	else if (__tmp2 > 65535)
     70e:	20 e0       	ldi	r18, 0x00	; 0
     710:	3f ef       	ldi	r19, 0xFF	; 255
     712:	4f e7       	ldi	r20, 0x7F	; 127
     714:	57 e4       	ldi	r21, 0x47	; 71
     716:	6a 85       	ldd	r22, Y+10	; 0x0a
     718:	7b 85       	ldd	r23, Y+11	; 0x0b
     71a:	8c 85       	ldd	r24, Y+12	; 0x0c
     71c:	9d 85       	ldd	r25, Y+13	; 0x0d
     71e:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
     722:	18 16       	cp	r1, r24
     724:	0c f0       	brlt	.+2      	; 0x728 <lcd_write_byte+0xbe>
     726:	7b c0       	rjmp	.+246    	; 0x81e <lcd_write_byte+0x1b4>
	{
		_delay_ms(__us / 1000.0);
     728:	20 e0       	ldi	r18, 0x00	; 0
     72a:	30 e0       	ldi	r19, 0x00	; 0
     72c:	4a e7       	ldi	r20, 0x7A	; 122
     72e:	54 e4       	ldi	r21, 0x44	; 68
     730:	6a 81       	ldd	r22, Y+2	; 0x02
     732:	7b 81       	ldd	r23, Y+3	; 0x03
     734:	8c 81       	ldd	r24, Y+4	; 0x04
     736:	9d 81       	ldd	r25, Y+5	; 0x05
     738:	0e 94 05 1a 	call	0x340a	; 0x340a <__divsf3>
     73c:	dc 01       	movw	r26, r24
     73e:	cb 01       	movw	r24, r22
     740:	8f 87       	std	Y+15, r24	; 0x0f
     742:	98 8b       	std	Y+16, r25	; 0x10
     744:	a9 8b       	std	Y+17, r26	; 0x11
     746:	ba 8b       	std	Y+18, r27	; 0x12

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     748:	20 e0       	ldi	r18, 0x00	; 0
     74a:	30 e0       	ldi	r19, 0x00	; 0
     74c:	4a e7       	ldi	r20, 0x7A	; 122
     74e:	55 e4       	ldi	r21, 0x45	; 69
     750:	6f 85       	ldd	r22, Y+15	; 0x0f
     752:	78 89       	ldd	r23, Y+16	; 0x10
     754:	89 89       	ldd	r24, Y+17	; 0x11
     756:	9a 89       	ldd	r25, Y+18	; 0x12
     758:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
     75c:	dc 01       	movw	r26, r24
     75e:	cb 01       	movw	r24, r22
     760:	8b 8b       	std	Y+19, r24	; 0x13
     762:	9c 8b       	std	Y+20, r25	; 0x14
     764:	ad 8b       	std	Y+21, r26	; 0x15
     766:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
     768:	20 e0       	ldi	r18, 0x00	; 0
     76a:	30 e0       	ldi	r19, 0x00	; 0
     76c:	40 e8       	ldi	r20, 0x80	; 128
     76e:	5f e3       	ldi	r21, 0x3F	; 63
     770:	6b 89       	ldd	r22, Y+19	; 0x13
     772:	7c 89       	ldd	r23, Y+20	; 0x14
     774:	8d 89       	ldd	r24, Y+21	; 0x15
     776:	9e 89       	ldd	r25, Y+22	; 0x16
     778:	0e 94 00 1a 	call	0x3400	; 0x3400 <__cmpsf2>
     77c:	88 23       	and	r24, r24
     77e:	2c f4       	brge	.+10     	; 0x78a <lcd_write_byte+0x120>
		__ticks = 1;
     780:	81 e0       	ldi	r24, 0x01	; 1
     782:	90 e0       	ldi	r25, 0x00	; 0
     784:	98 8f       	std	Y+24, r25	; 0x18
     786:	8f 8b       	std	Y+23, r24	; 0x17
     788:	3f c0       	rjmp	.+126    	; 0x808 <lcd_write_byte+0x19e>
	else if (__tmp > 65535)
     78a:	20 e0       	ldi	r18, 0x00	; 0
     78c:	3f ef       	ldi	r19, 0xFF	; 255
     78e:	4f e7       	ldi	r20, 0x7F	; 127
     790:	57 e4       	ldi	r21, 0x47	; 71
     792:	6b 89       	ldd	r22, Y+19	; 0x13
     794:	7c 89       	ldd	r23, Y+20	; 0x14
     796:	8d 89       	ldd	r24, Y+21	; 0x15
     798:	9e 89       	ldd	r25, Y+22	; 0x16
     79a:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
     79e:	18 16       	cp	r1, r24
     7a0:	4c f5       	brge	.+82     	; 0x7f4 <lcd_write_byte+0x18a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     7a2:	20 e0       	ldi	r18, 0x00	; 0
     7a4:	30 e0       	ldi	r19, 0x00	; 0
     7a6:	40 e2       	ldi	r20, 0x20	; 32
     7a8:	51 e4       	ldi	r21, 0x41	; 65
     7aa:	6f 85       	ldd	r22, Y+15	; 0x0f
     7ac:	78 89       	ldd	r23, Y+16	; 0x10
     7ae:	89 89       	ldd	r24, Y+17	; 0x11
     7b0:	9a 89       	ldd	r25, Y+18	; 0x12
     7b2:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
     7b6:	dc 01       	movw	r26, r24
     7b8:	cb 01       	movw	r24, r22
     7ba:	bc 01       	movw	r22, r24
     7bc:	cd 01       	movw	r24, r26
     7be:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
     7c2:	dc 01       	movw	r26, r24
     7c4:	cb 01       	movw	r24, r22
     7c6:	98 8f       	std	Y+24, r25	; 0x18
     7c8:	8f 8b       	std	Y+23, r24	; 0x17
     7ca:	0f c0       	rjmp	.+30     	; 0x7ea <lcd_write_byte+0x180>
     7cc:	80 e9       	ldi	r24, 0x90	; 144
     7ce:	91 e0       	ldi	r25, 0x01	; 1
     7d0:	9a 8f       	std	Y+26, r25	; 0x1a
     7d2:	89 8f       	std	Y+25, r24	; 0x19
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     7d4:	89 8d       	ldd	r24, Y+25	; 0x19
     7d6:	9a 8d       	ldd	r25, Y+26	; 0x1a
     7d8:	01 97       	sbiw	r24, 0x01	; 1
     7da:	f1 f7       	brne	.-4      	; 0x7d8 <lcd_write_byte+0x16e>
     7dc:	9a 8f       	std	Y+26, r25	; 0x1a
     7de:	89 8f       	std	Y+25, r24	; 0x19
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     7e0:	8f 89       	ldd	r24, Y+23	; 0x17
     7e2:	98 8d       	ldd	r25, Y+24	; 0x18
     7e4:	01 97       	sbiw	r24, 0x01	; 1
     7e6:	98 8f       	std	Y+24, r25	; 0x18
     7e8:	8f 8b       	std	Y+23, r24	; 0x17
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     7ea:	8f 89       	ldd	r24, Y+23	; 0x17
     7ec:	98 8d       	ldd	r25, Y+24	; 0x18
     7ee:	89 2b       	or	r24, r25
     7f0:	69 f7       	brne	.-38     	; 0x7cc <lcd_write_byte+0x162>
     7f2:	3f c0       	rjmp	.+126    	; 0x872 <lcd_write_byte+0x208>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     7f4:	6b 89       	ldd	r22, Y+19	; 0x13
     7f6:	7c 89       	ldd	r23, Y+20	; 0x14
     7f8:	8d 89       	ldd	r24, Y+21	; 0x15
     7fa:	9e 89       	ldd	r25, Y+22	; 0x16
     7fc:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
     800:	dc 01       	movw	r26, r24
     802:	cb 01       	movw	r24, r22
     804:	98 8f       	std	Y+24, r25	; 0x18
     806:	8f 8b       	std	Y+23, r24	; 0x17
     808:	8f 89       	ldd	r24, Y+23	; 0x17
     80a:	98 8d       	ldd	r25, Y+24	; 0x18
     80c:	9c 8f       	std	Y+28, r25	; 0x1c
     80e:	8b 8f       	std	Y+27, r24	; 0x1b
     810:	8b 8d       	ldd	r24, Y+27	; 0x1b
     812:	9c 8d       	ldd	r25, Y+28	; 0x1c
     814:	01 97       	sbiw	r24, 0x01	; 1
     816:	f1 f7       	brne	.-4      	; 0x814 <lcd_write_byte+0x1aa>
     818:	9c 8f       	std	Y+28, r25	; 0x1c
     81a:	8b 8f       	std	Y+27, r24	; 0x1b
     81c:	2a c0       	rjmp	.+84     	; 0x872 <lcd_write_byte+0x208>
		__ticks = 1;
	else if (__tmp2 > 65535)
	{
		_delay_ms(__us / 1000.0);
	}
	else if (__tmp > 255)
     81e:	20 e0       	ldi	r18, 0x00	; 0
     820:	30 e0       	ldi	r19, 0x00	; 0
     822:	4f e7       	ldi	r20, 0x7F	; 127
     824:	53 e4       	ldi	r21, 0x43	; 67
     826:	6e 81       	ldd	r22, Y+6	; 0x06
     828:	7f 81       	ldd	r23, Y+7	; 0x07
     82a:	88 85       	ldd	r24, Y+8	; 0x08
     82c:	99 85       	ldd	r25, Y+9	; 0x09
     82e:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
     832:	18 16       	cp	r1, r24
     834:	ac f4       	brge	.+42     	; 0x860 <lcd_write_byte+0x1f6>
	{
		uint16_t __ticks=(uint16_t)__tmp2;
     836:	6a 85       	ldd	r22, Y+10	; 0x0a
     838:	7b 85       	ldd	r23, Y+11	; 0x0b
     83a:	8c 85       	ldd	r24, Y+12	; 0x0c
     83c:	9d 85       	ldd	r25, Y+13	; 0x0d
     83e:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
     842:	dc 01       	movw	r26, r24
     844:	cb 01       	movw	r24, r22
     846:	9e 8f       	std	Y+30, r25	; 0x1e
     848:	8d 8f       	std	Y+29, r24	; 0x1d
     84a:	8d 8d       	ldd	r24, Y+29	; 0x1d
     84c:	9e 8d       	ldd	r25, Y+30	; 0x1e
     84e:	98 a3       	std	Y+32, r25	; 0x20
     850:	8f 8f       	std	Y+31, r24	; 0x1f
     852:	8f 8d       	ldd	r24, Y+31	; 0x1f
     854:	98 a1       	ldd	r25, Y+32	; 0x20
     856:	01 97       	sbiw	r24, 0x01	; 1
     858:	f1 f7       	brne	.-4      	; 0x856 <lcd_write_byte+0x1ec>
     85a:	98 a3       	std	Y+32, r25	; 0x20
     85c:	8f 8f       	std	Y+31, r24	; 0x1f
	_delay_us(40);
	//lcd_busy_wait();
}
     85e:	0f c0       	rjmp	.+30     	; 0x87e <lcd_write_byte+0x214>
		_delay_loop_2(__ticks);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
     860:	6e 81       	ldd	r22, Y+6	; 0x06
     862:	7f 81       	ldd	r23, Y+7	; 0x07
     864:	88 85       	ldd	r24, Y+8	; 0x08
     866:	99 85       	ldd	r25, Y+9	; 0x09
     868:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
     86c:	dc 01       	movw	r26, r24
     86e:	cb 01       	movw	r24, r22
     870:	8e 87       	std	Y+14, r24	; 0x0e
     872:	8e 85       	ldd	r24, Y+14	; 0x0e
     874:	89 a3       	std	Y+33, r24	; 0x21
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     876:	89 a1       	ldd	r24, Y+33	; 0x21
     878:	8a 95       	dec	r24
     87a:	f1 f7       	brne	.-4      	; 0x878 <lcd_write_byte+0x20e>
     87c:	89 a3       	std	Y+33, r24	; 0x21
     87e:	00 00       	nop
     880:	a3 96       	adiw	r28, 0x23	; 35
     882:	0f b6       	in	r0, 0x3f	; 63
     884:	f8 94       	cli
     886:	de bf       	out	0x3e, r29	; 62
     888:	0f be       	out	0x3f, r0	; 63
     88a:	cd bf       	out	0x3d, r28	; 61
     88c:	df 91       	pop	r29
     88e:	cf 91       	pop	r28
     890:	08 95       	ret

00000892 <lcd_write_cmd_with_delay>:

void lcd_write_cmd_with_delay(unsigned char data)
{
     892:	cf 93       	push	r28
     894:	df 93       	push	r29
     896:	cd b7       	in	r28, 0x3d	; 61
     898:	de b7       	in	r29, 0x3e	; 62
     89a:	6e 97       	sbiw	r28, 0x1e	; 30
     89c:	0f b6       	in	r0, 0x3f	; 63
     89e:	f8 94       	cli
     8a0:	de bf       	out	0x3e, r29	; 62
     8a2:	0f be       	out	0x3f, r0	; 63
     8a4:	cd bf       	out	0x3d, r28	; 61
     8a6:	8e 8f       	std	Y+30, r24	; 0x1e
     8a8:	80 e0       	ldi	r24, 0x00	; 0
     8aa:	90 e0       	ldi	r25, 0x00	; 0
     8ac:	a0 e2       	ldi	r26, 0x20	; 32
     8ae:	b1 e4       	ldi	r27, 0x41	; 65
     8b0:	8a 83       	std	Y+2, r24	; 0x02
     8b2:	9b 83       	std	Y+3, r25	; 0x03
     8b4:	ac 83       	std	Y+4, r26	; 0x04
     8b6:	bd 83       	std	Y+5, r27	; 0x05

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     8b8:	20 e0       	ldi	r18, 0x00	; 0
     8ba:	30 e0       	ldi	r19, 0x00	; 0
     8bc:	4a e7       	ldi	r20, 0x7A	; 122
     8be:	55 e4       	ldi	r21, 0x45	; 69
     8c0:	6a 81       	ldd	r22, Y+2	; 0x02
     8c2:	7b 81       	ldd	r23, Y+3	; 0x03
     8c4:	8c 81       	ldd	r24, Y+4	; 0x04
     8c6:	9d 81       	ldd	r25, Y+5	; 0x05
     8c8:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
     8cc:	dc 01       	movw	r26, r24
     8ce:	cb 01       	movw	r24, r22
     8d0:	8c 8b       	std	Y+20, r24	; 0x14
     8d2:	9d 8b       	std	Y+21, r25	; 0x15
     8d4:	ae 8b       	std	Y+22, r26	; 0x16
     8d6:	bf 8b       	std	Y+23, r27	; 0x17
	if (__tmp < 1.0)
     8d8:	20 e0       	ldi	r18, 0x00	; 0
     8da:	30 e0       	ldi	r19, 0x00	; 0
     8dc:	40 e8       	ldi	r20, 0x80	; 128
     8de:	5f e3       	ldi	r21, 0x3F	; 63
     8e0:	6c 89       	ldd	r22, Y+20	; 0x14
     8e2:	7d 89       	ldd	r23, Y+21	; 0x15
     8e4:	8e 89       	ldd	r24, Y+22	; 0x16
     8e6:	9f 89       	ldd	r25, Y+23	; 0x17
     8e8:	0e 94 00 1a 	call	0x3400	; 0x3400 <__cmpsf2>
     8ec:	88 23       	and	r24, r24
     8ee:	2c f4       	brge	.+10     	; 0x8fa <lcd_write_cmd_with_delay+0x68>
		__ticks = 1;
     8f0:	81 e0       	ldi	r24, 0x01	; 1
     8f2:	90 e0       	ldi	r25, 0x00	; 0
     8f4:	99 8f       	std	Y+25, r25	; 0x19
     8f6:	88 8f       	std	Y+24, r24	; 0x18
     8f8:	3f c0       	rjmp	.+126    	; 0x978 <__stack+0x79>
	else if (__tmp > 65535)
     8fa:	20 e0       	ldi	r18, 0x00	; 0
     8fc:	3f ef       	ldi	r19, 0xFF	; 255
     8fe:	4f e7       	ldi	r20, 0x7F	; 127
     900:	57 e4       	ldi	r21, 0x47	; 71
     902:	6c 89       	ldd	r22, Y+20	; 0x14
     904:	7d 89       	ldd	r23, Y+21	; 0x15
     906:	8e 89       	ldd	r24, Y+22	; 0x16
     908:	9f 89       	ldd	r25, Y+23	; 0x17
     90a:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
     90e:	18 16       	cp	r1, r24
     910:	4c f5       	brge	.+82     	; 0x964 <__stack+0x65>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     912:	20 e0       	ldi	r18, 0x00	; 0
     914:	30 e0       	ldi	r19, 0x00	; 0
     916:	40 e2       	ldi	r20, 0x20	; 32
     918:	51 e4       	ldi	r21, 0x41	; 65
     91a:	6a 81       	ldd	r22, Y+2	; 0x02
     91c:	7b 81       	ldd	r23, Y+3	; 0x03
     91e:	8c 81       	ldd	r24, Y+4	; 0x04
     920:	9d 81       	ldd	r25, Y+5	; 0x05
     922:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
     926:	dc 01       	movw	r26, r24
     928:	cb 01       	movw	r24, r22
     92a:	bc 01       	movw	r22, r24
     92c:	cd 01       	movw	r24, r26
     92e:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
     932:	dc 01       	movw	r26, r24
     934:	cb 01       	movw	r24, r22
     936:	99 8f       	std	Y+25, r25	; 0x19
     938:	88 8f       	std	Y+24, r24	; 0x18
     93a:	0f c0       	rjmp	.+30     	; 0x95a <__stack+0x5b>
     93c:	80 e9       	ldi	r24, 0x90	; 144
     93e:	91 e0       	ldi	r25, 0x01	; 1
     940:	9b 8f       	std	Y+27, r25	; 0x1b
     942:	8a 8f       	std	Y+26, r24	; 0x1a
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     944:	8a 8d       	ldd	r24, Y+26	; 0x1a
     946:	9b 8d       	ldd	r25, Y+27	; 0x1b
     948:	01 97       	sbiw	r24, 0x01	; 1
     94a:	f1 f7       	brne	.-4      	; 0x948 <__stack+0x49>
     94c:	9b 8f       	std	Y+27, r25	; 0x1b
     94e:	8a 8f       	std	Y+26, r24	; 0x1a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     950:	88 8d       	ldd	r24, Y+24	; 0x18
     952:	99 8d       	ldd	r25, Y+25	; 0x19
     954:	01 97       	sbiw	r24, 0x01	; 1
     956:	99 8f       	std	Y+25, r25	; 0x19
     958:	88 8f       	std	Y+24, r24	; 0x18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     95a:	88 8d       	ldd	r24, Y+24	; 0x18
     95c:	99 8d       	ldd	r25, Y+25	; 0x19
     95e:	89 2b       	or	r24, r25
     960:	69 f7       	brne	.-38     	; 0x93c <__stack+0x3d>
     962:	14 c0       	rjmp	.+40     	; 0x98c <__stack+0x8d>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     964:	6c 89       	ldd	r22, Y+20	; 0x14
     966:	7d 89       	ldd	r23, Y+21	; 0x15
     968:	8e 89       	ldd	r24, Y+22	; 0x16
     96a:	9f 89       	ldd	r25, Y+23	; 0x17
     96c:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
     970:	dc 01       	movw	r26, r24
     972:	cb 01       	movw	r24, r22
     974:	99 8f       	std	Y+25, r25	; 0x19
     976:	88 8f       	std	Y+24, r24	; 0x18
     978:	88 8d       	ldd	r24, Y+24	; 0x18
     97a:	99 8d       	ldd	r25, Y+25	; 0x19
     97c:	9d 8f       	std	Y+29, r25	; 0x1d
     97e:	8c 8f       	std	Y+28, r24	; 0x1c
     980:	8c 8d       	ldd	r24, Y+28	; 0x1c
     982:	9d 8d       	ldd	r25, Y+29	; 0x1d
     984:	01 97       	sbiw	r24, 0x01	; 1
     986:	f1 f7       	brne	.-4      	; 0x984 <__stack+0x85>
     988:	9d 8f       	std	Y+29, r25	; 0x1d
     98a:	8c 8f       	std	Y+28, r24	; 0x1c
	uint8_t temp;
	
	
	_delay_ms(10);
	temp = (data>>4)& 0X0F; //Masking upper nibble
     98c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     98e:	82 95       	swap	r24
     990:	8f 70       	andi	r24, 0x0F	; 15
     992:	89 83       	std	Y+1, r24	; 0x01
	lcd_write_nibble(temp,CMD);
     994:	60 e0       	ldi	r22, 0x00	; 0
     996:	89 81       	ldd	r24, Y+1	; 0x01
     998:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <lcd_write_nibble>
     99c:	80 e0       	ldi	r24, 0x00	; 0
     99e:	90 e0       	ldi	r25, 0x00	; 0
     9a0:	a0 e2       	ldi	r26, 0x20	; 32
     9a2:	b1 e4       	ldi	r27, 0x41	; 65
     9a4:	8e 83       	std	Y+6, r24	; 0x06
     9a6:	9f 83       	std	Y+7, r25	; 0x07
     9a8:	a8 87       	std	Y+8, r26	; 0x08
     9aa:	b9 87       	std	Y+9, r27	; 0x09

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     9ac:	20 e0       	ldi	r18, 0x00	; 0
     9ae:	30 e0       	ldi	r19, 0x00	; 0
     9b0:	4a e7       	ldi	r20, 0x7A	; 122
     9b2:	55 e4       	ldi	r21, 0x45	; 69
     9b4:	6e 81       	ldd	r22, Y+6	; 0x06
     9b6:	7f 81       	ldd	r23, Y+7	; 0x07
     9b8:	88 85       	ldd	r24, Y+8	; 0x08
     9ba:	99 85       	ldd	r25, Y+9	; 0x09
     9bc:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
     9c0:	dc 01       	movw	r26, r24
     9c2:	cb 01       	movw	r24, r22
     9c4:	8a 87       	std	Y+10, r24	; 0x0a
     9c6:	9b 87       	std	Y+11, r25	; 0x0b
     9c8:	ac 87       	std	Y+12, r26	; 0x0c
     9ca:	bd 87       	std	Y+13, r27	; 0x0d
	if (__tmp < 1.0)
     9cc:	20 e0       	ldi	r18, 0x00	; 0
     9ce:	30 e0       	ldi	r19, 0x00	; 0
     9d0:	40 e8       	ldi	r20, 0x80	; 128
     9d2:	5f e3       	ldi	r21, 0x3F	; 63
     9d4:	6a 85       	ldd	r22, Y+10	; 0x0a
     9d6:	7b 85       	ldd	r23, Y+11	; 0x0b
     9d8:	8c 85       	ldd	r24, Y+12	; 0x0c
     9da:	9d 85       	ldd	r25, Y+13	; 0x0d
     9dc:	0e 94 00 1a 	call	0x3400	; 0x3400 <__cmpsf2>
     9e0:	88 23       	and	r24, r24
     9e2:	2c f4       	brge	.+10     	; 0x9ee <__stack+0xef>
		__ticks = 1;
     9e4:	81 e0       	ldi	r24, 0x01	; 1
     9e6:	90 e0       	ldi	r25, 0x00	; 0
     9e8:	9f 87       	std	Y+15, r25	; 0x0f
     9ea:	8e 87       	std	Y+14, r24	; 0x0e
     9ec:	3f c0       	rjmp	.+126    	; 0xa6c <__stack+0x16d>
	else if (__tmp > 65535)
     9ee:	20 e0       	ldi	r18, 0x00	; 0
     9f0:	3f ef       	ldi	r19, 0xFF	; 255
     9f2:	4f e7       	ldi	r20, 0x7F	; 127
     9f4:	57 e4       	ldi	r21, 0x47	; 71
     9f6:	6a 85       	ldd	r22, Y+10	; 0x0a
     9f8:	7b 85       	ldd	r23, Y+11	; 0x0b
     9fa:	8c 85       	ldd	r24, Y+12	; 0x0c
     9fc:	9d 85       	ldd	r25, Y+13	; 0x0d
     9fe:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
     a02:	18 16       	cp	r1, r24
     a04:	4c f5       	brge	.+82     	; 0xa58 <__stack+0x159>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     a06:	20 e0       	ldi	r18, 0x00	; 0
     a08:	30 e0       	ldi	r19, 0x00	; 0
     a0a:	40 e2       	ldi	r20, 0x20	; 32
     a0c:	51 e4       	ldi	r21, 0x41	; 65
     a0e:	6e 81       	ldd	r22, Y+6	; 0x06
     a10:	7f 81       	ldd	r23, Y+7	; 0x07
     a12:	88 85       	ldd	r24, Y+8	; 0x08
     a14:	99 85       	ldd	r25, Y+9	; 0x09
     a16:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
     a1a:	dc 01       	movw	r26, r24
     a1c:	cb 01       	movw	r24, r22
     a1e:	bc 01       	movw	r22, r24
     a20:	cd 01       	movw	r24, r26
     a22:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
     a26:	dc 01       	movw	r26, r24
     a28:	cb 01       	movw	r24, r22
     a2a:	9f 87       	std	Y+15, r25	; 0x0f
     a2c:	8e 87       	std	Y+14, r24	; 0x0e
     a2e:	0f c0       	rjmp	.+30     	; 0xa4e <__stack+0x14f>
     a30:	80 e9       	ldi	r24, 0x90	; 144
     a32:	91 e0       	ldi	r25, 0x01	; 1
     a34:	99 8b       	std	Y+17, r25	; 0x11
     a36:	88 8b       	std	Y+16, r24	; 0x10
     a38:	88 89       	ldd	r24, Y+16	; 0x10
     a3a:	99 89       	ldd	r25, Y+17	; 0x11
     a3c:	01 97       	sbiw	r24, 0x01	; 1
     a3e:	f1 f7       	brne	.-4      	; 0xa3c <__stack+0x13d>
     a40:	99 8b       	std	Y+17, r25	; 0x11
     a42:	88 8b       	std	Y+16, r24	; 0x10
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     a44:	8e 85       	ldd	r24, Y+14	; 0x0e
     a46:	9f 85       	ldd	r25, Y+15	; 0x0f
     a48:	01 97       	sbiw	r24, 0x01	; 1
     a4a:	9f 87       	std	Y+15, r25	; 0x0f
     a4c:	8e 87       	std	Y+14, r24	; 0x0e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     a4e:	8e 85       	ldd	r24, Y+14	; 0x0e
     a50:	9f 85       	ldd	r25, Y+15	; 0x0f
     a52:	89 2b       	or	r24, r25
     a54:	69 f7       	brne	.-38     	; 0xa30 <__stack+0x131>
     a56:	14 c0       	rjmp	.+40     	; 0xa80 <__stack+0x181>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     a58:	6a 85       	ldd	r22, Y+10	; 0x0a
     a5a:	7b 85       	ldd	r23, Y+11	; 0x0b
     a5c:	8c 85       	ldd	r24, Y+12	; 0x0c
     a5e:	9d 85       	ldd	r25, Y+13	; 0x0d
     a60:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
     a64:	dc 01       	movw	r26, r24
     a66:	cb 01       	movw	r24, r22
     a68:	9f 87       	std	Y+15, r25	; 0x0f
     a6a:	8e 87       	std	Y+14, r24	; 0x0e
     a6c:	8e 85       	ldd	r24, Y+14	; 0x0e
     a6e:	9f 85       	ldd	r25, Y+15	; 0x0f
     a70:	9b 8b       	std	Y+19, r25	; 0x13
     a72:	8a 8b       	std	Y+18, r24	; 0x12
     a74:	8a 89       	ldd	r24, Y+18	; 0x12
     a76:	9b 89       	ldd	r25, Y+19	; 0x13
     a78:	01 97       	sbiw	r24, 0x01	; 1
     a7a:	f1 f7       	brne	.-4      	; 0xa78 <__stack+0x179>
     a7c:	9b 8b       	std	Y+19, r25	; 0x13
     a7e:	8a 8b       	std	Y+18, r24	; 0x12
	
	_delay_ms(10);
	temp = data & 0X0F;
     a80:	8e 8d       	ldd	r24, Y+30	; 0x1e
     a82:	8f 70       	andi	r24, 0x0F	; 15
     a84:	89 83       	std	Y+1, r24	; 0x01
	lcd_write_nibble(temp,CMD);
     a86:	60 e0       	ldi	r22, 0x00	; 0
     a88:	89 81       	ldd	r24, Y+1	; 0x01
     a8a:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <lcd_write_nibble>
}
     a8e:	00 00       	nop
     a90:	6e 96       	adiw	r28, 0x1e	; 30
     a92:	0f b6       	in	r0, 0x3f	; 63
     a94:	f8 94       	cli
     a96:	de bf       	out	0x3e, r29	; 62
     a98:	0f be       	out	0x3f, r0	; 63
     a9a:	cd bf       	out	0x3d, r28	; 61
     a9c:	df 91       	pop	r29
     a9e:	cf 91       	pop	r28
     aa0:	08 95       	ret

00000aa2 <lcd_write_cmd_byte>:

void lcd_write_cmd_byte(unsigned char data)
{
     aa2:	cf 93       	push	r28
     aa4:	df 93       	push	r29
     aa6:	00 d0       	rcall	.+0      	; 0xaa8 <lcd_write_cmd_byte+0x6>
     aa8:	cd b7       	in	r28, 0x3d	; 61
     aaa:	de b7       	in	r29, 0x3e	; 62
     aac:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t temp;
	temp = (data>>4)& 0X0F;
     aae:	8a 81       	ldd	r24, Y+2	; 0x02
     ab0:	82 95       	swap	r24
     ab2:	8f 70       	andi	r24, 0x0F	; 15
     ab4:	89 83       	std	Y+1, r24	; 0x01
	lcd_write_nibble(temp,CMD);
     ab6:	60 e0       	ldi	r22, 0x00	; 0
     ab8:	89 81       	ldd	r24, Y+1	; 0x01
     aba:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <lcd_write_nibble>
	
	temp = data & 0X0F;
     abe:	8a 81       	ldd	r24, Y+2	; 0x02
     ac0:	8f 70       	andi	r24, 0x0F	; 15
     ac2:	89 83       	std	Y+1, r24	; 0x01
	lcd_write_nibble(temp,CMD);	
     ac4:	60 e0       	ldi	r22, 0x00	; 0
     ac6:	89 81       	ldd	r24, Y+1	; 0x01
     ac8:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <lcd_write_nibble>
}
     acc:	00 00       	nop
     ace:	0f 90       	pop	r0
     ad0:	0f 90       	pop	r0
     ad2:	df 91       	pop	r29
     ad4:	cf 91       	pop	r28
     ad6:	08 95       	ret

00000ad8 <lcd_busy_wait>:


void lcd_busy_wait()
{
     ad8:	cf 93       	push	r28
     ada:	df 93       	push	r29
     adc:	cd b7       	in	r28, 0x3d	; 61
     ade:	de b7       	in	r29, 0x3e	; 62
     ae0:	a1 97       	sbiw	r28, 0x21	; 33
     ae2:	0f b6       	in	r0, 0x3f	; 63
     ae4:	f8 94       	cli
     ae6:	de bf       	out	0x3e, r29	; 62
     ae8:	0f be       	out	0x3f, r0	; 63
     aea:	cd bf       	out	0x3d, r28	; 61
	//DDR(D7_PORT) &=~(1<<D7_PIN);;//D7 pin input for reading pin state
	RS_LO(); //for CMD
     aec:	8b e2       	ldi	r24, 0x2B	; 43
     aee:	90 e0       	ldi	r25, 0x00	; 0
     af0:	2b e2       	ldi	r18, 0x2B	; 43
     af2:	30 e0       	ldi	r19, 0x00	; 0
     af4:	f9 01       	movw	r30, r18
     af6:	20 81       	ld	r18, Z
     af8:	2b 7f       	andi	r18, 0xFB	; 251
     afa:	fc 01       	movw	r30, r24
     afc:	20 83       	st	Z, r18
	RW_HI(); //Read Mode
     afe:	8b e2       	ldi	r24, 0x2B	; 43
     b00:	90 e0       	ldi	r25, 0x00	; 0
     b02:	2b e2       	ldi	r18, 0x2B	; 43
     b04:	30 e0       	ldi	r19, 0x00	; 0
     b06:	f9 01       	movw	r30, r18
     b08:	20 81       	ld	r18, Z
     b0a:	22 60       	ori	r18, 0x02	; 2
     b0c:	fc 01       	movw	r30, r24
     b0e:	20 83       	st	Z, r18
	
	PORTB &= ~(1<<PB3);
     b10:	85 e2       	ldi	r24, 0x25	; 37
     b12:	90 e0       	ldi	r25, 0x00	; 0
     b14:	25 e2       	ldi	r18, 0x25	; 37
     b16:	30 e0       	ldi	r19, 0x00	; 0
     b18:	f9 01       	movw	r30, r18
     b1a:	20 81       	ld	r18, Z
     b1c:	27 7f       	andi	r18, 0xF7	; 247
     b1e:	fc 01       	movw	r30, r24
     b20:	20 83       	st	Z, r18
	
	uint8_t busyFlag = 1;//Busy flag in D7 pin
     b22:	81 e0       	ldi	r24, 0x01	; 1
     b24:	89 83       	std	Y+1, r24	; 0x01
	do 
	{
		//EN_LO();
		//EN_HI();
		EN_LO();
     b26:	8b e2       	ldi	r24, 0x2B	; 43
     b28:	90 e0       	ldi	r25, 0x00	; 0
     b2a:	2b e2       	ldi	r18, 0x2B	; 43
     b2c:	30 e0       	ldi	r19, 0x00	; 0
     b2e:	f9 01       	movw	r30, r18
     b30:	20 81       	ld	r18, Z
     b32:	2e 7f       	andi	r18, 0xFE	; 254
     b34:	fc 01       	movw	r30, r24
     b36:	20 83       	st	Z, r18
		//_delay_us(0.1);
		EN_HI();
     b38:	8b e2       	ldi	r24, 0x2B	; 43
     b3a:	90 e0       	ldi	r25, 0x00	; 0
     b3c:	2b e2       	ldi	r18, 0x2B	; 43
     b3e:	30 e0       	ldi	r19, 0x00	; 0
     b40:	f9 01       	movw	r30, r18
     b42:	20 81       	ld	r18, Z
     b44:	21 60       	ori	r18, 0x01	; 1
     b46:	fc 01       	movw	r30, r24
     b48:	20 83       	st	Z, r18
		busyFlag = PINB & (1 << PB3);
     b4a:	83 e2       	ldi	r24, 0x23	; 35
     b4c:	90 e0       	ldi	r25, 0x00	; 0
     b4e:	fc 01       	movw	r30, r24
     b50:	80 81       	ld	r24, Z
     b52:	88 70       	andi	r24, 0x08	; 8
     b54:	89 83       	std	Y+1, r24	; 0x01
		EN_LO();
     b56:	8b e2       	ldi	r24, 0x2B	; 43
     b58:	90 e0       	ldi	r25, 0x00	; 0
     b5a:	2b e2       	ldi	r18, 0x2B	; 43
     b5c:	30 e0       	ldi	r19, 0x00	; 0
     b5e:	f9 01       	movw	r30, r18
     b60:	20 81       	ld	r18, Z
     b62:	2e 7f       	andi	r18, 0xFE	; 254
     b64:	fc 01       	movw	r30, r24
     b66:	20 83       	st	Z, r18
     b68:	80 e0       	ldi	r24, 0x00	; 0
     b6a:	90 e0       	ldi	r25, 0x00	; 0
     b6c:	a0 e0       	ldi	r26, 0x00	; 0
     b6e:	bf e3       	ldi	r27, 0x3F	; 63
     b70:	8a 83       	std	Y+2, r24	; 0x02
     b72:	9b 83       	std	Y+3, r25	; 0x03
     b74:	ac 83       	std	Y+4, r26	; 0x04
     b76:	bd 83       	std	Y+5, r27	; 0x05
	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint8_t __ticks;
	double __tmp2 ;
	__tmp = ((F_CPU) / 3e6) * __us;
     b78:	2b ea       	ldi	r18, 0xAB	; 171
     b7a:	3a ea       	ldi	r19, 0xAA	; 170
     b7c:	4a ea       	ldi	r20, 0xAA	; 170
     b7e:	50 e4       	ldi	r21, 0x40	; 64
     b80:	6a 81       	ldd	r22, Y+2	; 0x02
     b82:	7b 81       	ldd	r23, Y+3	; 0x03
     b84:	8c 81       	ldd	r24, Y+4	; 0x04
     b86:	9d 81       	ldd	r25, Y+5	; 0x05
     b88:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
     b8c:	dc 01       	movw	r26, r24
     b8e:	cb 01       	movw	r24, r22
     b90:	8e 83       	std	Y+6, r24	; 0x06
     b92:	9f 83       	std	Y+7, r25	; 0x07
     b94:	a8 87       	std	Y+8, r26	; 0x08
     b96:	b9 87       	std	Y+9, r27	; 0x09
	__tmp2 = ((F_CPU) / 4e6) * __us;
     b98:	20 e0       	ldi	r18, 0x00	; 0
     b9a:	30 e0       	ldi	r19, 0x00	; 0
     b9c:	40 e8       	ldi	r20, 0x80	; 128
     b9e:	50 e4       	ldi	r21, 0x40	; 64
     ba0:	6a 81       	ldd	r22, Y+2	; 0x02
     ba2:	7b 81       	ldd	r23, Y+3	; 0x03
     ba4:	8c 81       	ldd	r24, Y+4	; 0x04
     ba6:	9d 81       	ldd	r25, Y+5	; 0x05
     ba8:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
     bac:	dc 01       	movw	r26, r24
     bae:	cb 01       	movw	r24, r22
     bb0:	8a 87       	std	Y+10, r24	; 0x0a
     bb2:	9b 87       	std	Y+11, r25	; 0x0b
     bb4:	ac 87       	std	Y+12, r26	; 0x0c
     bb6:	bd 87       	std	Y+13, r27	; 0x0d
	if (__tmp < 1.0)
     bb8:	20 e0       	ldi	r18, 0x00	; 0
     bba:	30 e0       	ldi	r19, 0x00	; 0
     bbc:	40 e8       	ldi	r20, 0x80	; 128
     bbe:	5f e3       	ldi	r21, 0x3F	; 63
     bc0:	6e 81       	ldd	r22, Y+6	; 0x06
     bc2:	7f 81       	ldd	r23, Y+7	; 0x07
     bc4:	88 85       	ldd	r24, Y+8	; 0x08
     bc6:	99 85       	ldd	r25, Y+9	; 0x09
     bc8:	0e 94 00 1a 	call	0x3400	; 0x3400 <__cmpsf2>
     bcc:	88 23       	and	r24, r24
     bce:	1c f4       	brge	.+6      	; 0xbd6 <lcd_busy_wait+0xfe>
		__ticks = 1;
     bd0:	81 e0       	ldi	r24, 0x01	; 1
     bd2:	8e 87       	std	Y+14, r24	; 0x0e
     bd4:	b2 c0       	rjmp	.+356    	; 0xd3a <lcd_busy_wait+0x262>
	else if (__tmp2 > 65535)
     bd6:	20 e0       	ldi	r18, 0x00	; 0
     bd8:	3f ef       	ldi	r19, 0xFF	; 255
     bda:	4f e7       	ldi	r20, 0x7F	; 127
     bdc:	57 e4       	ldi	r21, 0x47	; 71
     bde:	6a 85       	ldd	r22, Y+10	; 0x0a
     be0:	7b 85       	ldd	r23, Y+11	; 0x0b
     be2:	8c 85       	ldd	r24, Y+12	; 0x0c
     be4:	9d 85       	ldd	r25, Y+13	; 0x0d
     be6:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
     bea:	18 16       	cp	r1, r24
     bec:	0c f0       	brlt	.+2      	; 0xbf0 <lcd_busy_wait+0x118>
     bee:	7b c0       	rjmp	.+246    	; 0xce6 <lcd_busy_wait+0x20e>
	{
		_delay_ms(__us / 1000.0);
     bf0:	20 e0       	ldi	r18, 0x00	; 0
     bf2:	30 e0       	ldi	r19, 0x00	; 0
     bf4:	4a e7       	ldi	r20, 0x7A	; 122
     bf6:	54 e4       	ldi	r21, 0x44	; 68
     bf8:	6a 81       	ldd	r22, Y+2	; 0x02
     bfa:	7b 81       	ldd	r23, Y+3	; 0x03
     bfc:	8c 81       	ldd	r24, Y+4	; 0x04
     bfe:	9d 81       	ldd	r25, Y+5	; 0x05
     c00:	0e 94 05 1a 	call	0x340a	; 0x340a <__divsf3>
     c04:	dc 01       	movw	r26, r24
     c06:	cb 01       	movw	r24, r22
     c08:	8f 87       	std	Y+15, r24	; 0x0f
     c0a:	98 8b       	std	Y+16, r25	; 0x10
     c0c:	a9 8b       	std	Y+17, r26	; 0x11
     c0e:	ba 8b       	std	Y+18, r27	; 0x12

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     c10:	20 e0       	ldi	r18, 0x00	; 0
     c12:	30 e0       	ldi	r19, 0x00	; 0
     c14:	4a e7       	ldi	r20, 0x7A	; 122
     c16:	55 e4       	ldi	r21, 0x45	; 69
     c18:	6f 85       	ldd	r22, Y+15	; 0x0f
     c1a:	78 89       	ldd	r23, Y+16	; 0x10
     c1c:	89 89       	ldd	r24, Y+17	; 0x11
     c1e:	9a 89       	ldd	r25, Y+18	; 0x12
     c20:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
     c24:	dc 01       	movw	r26, r24
     c26:	cb 01       	movw	r24, r22
     c28:	8b 8b       	std	Y+19, r24	; 0x13
     c2a:	9c 8b       	std	Y+20, r25	; 0x14
     c2c:	ad 8b       	std	Y+21, r26	; 0x15
     c2e:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
     c30:	20 e0       	ldi	r18, 0x00	; 0
     c32:	30 e0       	ldi	r19, 0x00	; 0
     c34:	40 e8       	ldi	r20, 0x80	; 128
     c36:	5f e3       	ldi	r21, 0x3F	; 63
     c38:	6b 89       	ldd	r22, Y+19	; 0x13
     c3a:	7c 89       	ldd	r23, Y+20	; 0x14
     c3c:	8d 89       	ldd	r24, Y+21	; 0x15
     c3e:	9e 89       	ldd	r25, Y+22	; 0x16
     c40:	0e 94 00 1a 	call	0x3400	; 0x3400 <__cmpsf2>
     c44:	88 23       	and	r24, r24
     c46:	2c f4       	brge	.+10     	; 0xc52 <lcd_busy_wait+0x17a>
		__ticks = 1;
     c48:	81 e0       	ldi	r24, 0x01	; 1
     c4a:	90 e0       	ldi	r25, 0x00	; 0
     c4c:	98 8f       	std	Y+24, r25	; 0x18
     c4e:	8f 8b       	std	Y+23, r24	; 0x17
     c50:	3f c0       	rjmp	.+126    	; 0xcd0 <lcd_busy_wait+0x1f8>
	else if (__tmp > 65535)
     c52:	20 e0       	ldi	r18, 0x00	; 0
     c54:	3f ef       	ldi	r19, 0xFF	; 255
     c56:	4f e7       	ldi	r20, 0x7F	; 127
     c58:	57 e4       	ldi	r21, 0x47	; 71
     c5a:	6b 89       	ldd	r22, Y+19	; 0x13
     c5c:	7c 89       	ldd	r23, Y+20	; 0x14
     c5e:	8d 89       	ldd	r24, Y+21	; 0x15
     c60:	9e 89       	ldd	r25, Y+22	; 0x16
     c62:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
     c66:	18 16       	cp	r1, r24
     c68:	4c f5       	brge	.+82     	; 0xcbc <lcd_busy_wait+0x1e4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     c6a:	20 e0       	ldi	r18, 0x00	; 0
     c6c:	30 e0       	ldi	r19, 0x00	; 0
     c6e:	40 e2       	ldi	r20, 0x20	; 32
     c70:	51 e4       	ldi	r21, 0x41	; 65
     c72:	6f 85       	ldd	r22, Y+15	; 0x0f
     c74:	78 89       	ldd	r23, Y+16	; 0x10
     c76:	89 89       	ldd	r24, Y+17	; 0x11
     c78:	9a 89       	ldd	r25, Y+18	; 0x12
     c7a:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
     c7e:	dc 01       	movw	r26, r24
     c80:	cb 01       	movw	r24, r22
     c82:	bc 01       	movw	r22, r24
     c84:	cd 01       	movw	r24, r26
     c86:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
     c8a:	dc 01       	movw	r26, r24
     c8c:	cb 01       	movw	r24, r22
     c8e:	98 8f       	std	Y+24, r25	; 0x18
     c90:	8f 8b       	std	Y+23, r24	; 0x17
     c92:	0f c0       	rjmp	.+30     	; 0xcb2 <lcd_busy_wait+0x1da>
     c94:	80 e9       	ldi	r24, 0x90	; 144
     c96:	91 e0       	ldi	r25, 0x01	; 1
     c98:	9a 8f       	std	Y+26, r25	; 0x1a
     c9a:	89 8f       	std	Y+25, r24	; 0x19
     c9c:	89 8d       	ldd	r24, Y+25	; 0x19
     c9e:	9a 8d       	ldd	r25, Y+26	; 0x1a
     ca0:	01 97       	sbiw	r24, 0x01	; 1
     ca2:	f1 f7       	brne	.-4      	; 0xca0 <lcd_busy_wait+0x1c8>
     ca4:	9a 8f       	std	Y+26, r25	; 0x1a
     ca6:	89 8f       	std	Y+25, r24	; 0x19
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     ca8:	8f 89       	ldd	r24, Y+23	; 0x17
     caa:	98 8d       	ldd	r25, Y+24	; 0x18
     cac:	01 97       	sbiw	r24, 0x01	; 1
     cae:	98 8f       	std	Y+24, r25	; 0x18
     cb0:	8f 8b       	std	Y+23, r24	; 0x17
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     cb2:	8f 89       	ldd	r24, Y+23	; 0x17
     cb4:	98 8d       	ldd	r25, Y+24	; 0x18
     cb6:	89 2b       	or	r24, r25
     cb8:	69 f7       	brne	.-38     	; 0xc94 <lcd_busy_wait+0x1bc>
     cba:	3f c0       	rjmp	.+126    	; 0xd3a <lcd_busy_wait+0x262>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     cbc:	6b 89       	ldd	r22, Y+19	; 0x13
     cbe:	7c 89       	ldd	r23, Y+20	; 0x14
     cc0:	8d 89       	ldd	r24, Y+21	; 0x15
     cc2:	9e 89       	ldd	r25, Y+22	; 0x16
     cc4:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
     cc8:	dc 01       	movw	r26, r24
     cca:	cb 01       	movw	r24, r22
     ccc:	98 8f       	std	Y+24, r25	; 0x18
     cce:	8f 8b       	std	Y+23, r24	; 0x17
     cd0:	8f 89       	ldd	r24, Y+23	; 0x17
     cd2:	98 8d       	ldd	r25, Y+24	; 0x18
     cd4:	9c 8f       	std	Y+28, r25	; 0x1c
     cd6:	8b 8f       	std	Y+27, r24	; 0x1b
     cd8:	8b 8d       	ldd	r24, Y+27	; 0x1b
     cda:	9c 8d       	ldd	r25, Y+28	; 0x1c
     cdc:	01 97       	sbiw	r24, 0x01	; 1
     cde:	f1 f7       	brne	.-4      	; 0xcdc <lcd_busy_wait+0x204>
     ce0:	9c 8f       	std	Y+28, r25	; 0x1c
     ce2:	8b 8f       	std	Y+27, r24	; 0x1b
     ce4:	2a c0       	rjmp	.+84     	; 0xd3a <lcd_busy_wait+0x262>
		__ticks = 1;
	else if (__tmp2 > 65535)
	{
		_delay_ms(__us / 1000.0);
	}
	else if (__tmp > 255)
     ce6:	20 e0       	ldi	r18, 0x00	; 0
     ce8:	30 e0       	ldi	r19, 0x00	; 0
     cea:	4f e7       	ldi	r20, 0x7F	; 127
     cec:	53 e4       	ldi	r21, 0x43	; 67
     cee:	6e 81       	ldd	r22, Y+6	; 0x06
     cf0:	7f 81       	ldd	r23, Y+7	; 0x07
     cf2:	88 85       	ldd	r24, Y+8	; 0x08
     cf4:	99 85       	ldd	r25, Y+9	; 0x09
     cf6:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
     cfa:	18 16       	cp	r1, r24
     cfc:	ac f4       	brge	.+42     	; 0xd28 <lcd_busy_wait+0x250>
	{
		uint16_t __ticks=(uint16_t)__tmp2;
     cfe:	6a 85       	ldd	r22, Y+10	; 0x0a
     d00:	7b 85       	ldd	r23, Y+11	; 0x0b
     d02:	8c 85       	ldd	r24, Y+12	; 0x0c
     d04:	9d 85       	ldd	r25, Y+13	; 0x0d
     d06:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
     d0a:	dc 01       	movw	r26, r24
     d0c:	cb 01       	movw	r24, r22
     d0e:	9e 8f       	std	Y+30, r25	; 0x1e
     d10:	8d 8f       	std	Y+29, r24	; 0x1d
     d12:	8d 8d       	ldd	r24, Y+29	; 0x1d
     d14:	9e 8d       	ldd	r25, Y+30	; 0x1e
     d16:	98 a3       	std	Y+32, r25	; 0x20
     d18:	8f 8f       	std	Y+31, r24	; 0x1f
     d1a:	8f 8d       	ldd	r24, Y+31	; 0x1f
     d1c:	98 a1       	ldd	r25, Y+32	; 0x20
     d1e:	01 97       	sbiw	r24, 0x01	; 1
     d20:	f1 f7       	brne	.-4      	; 0xd1e <lcd_busy_wait+0x246>
     d22:	98 a3       	std	Y+32, r25	; 0x20
     d24:	8f 8f       	std	Y+31, r24	; 0x1f
     d26:	0f c0       	rjmp	.+30     	; 0xd46 <lcd_busy_wait+0x26e>
		_delay_loop_2(__ticks);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
     d28:	6e 81       	ldd	r22, Y+6	; 0x06
     d2a:	7f 81       	ldd	r23, Y+7	; 0x07
     d2c:	88 85       	ldd	r24, Y+8	; 0x08
     d2e:	99 85       	ldd	r25, Y+9	; 0x09
     d30:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
     d34:	dc 01       	movw	r26, r24
     d36:	cb 01       	movw	r24, r22
     d38:	8e 87       	std	Y+14, r24	; 0x0e
     d3a:	8e 85       	ldd	r24, Y+14	; 0x0e
     d3c:	89 a3       	std	Y+33, r24	; 0x21
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     d3e:	89 a1       	ldd	r24, Y+33	; 0x21
     d40:	8a 95       	dec	r24
     d42:	f1 f7       	brne	.-4      	; 0xd40 <lcd_busy_wait+0x268>
     d44:	89 a3       	std	Y+33, r24	; 0x21
		{
			PORTD &= ~(1<<PD3);
		}
		*/
		
	} while (busyFlag);
     d46:	89 81       	ldd	r24, Y+1	; 0x01
     d48:	88 23       	and	r24, r24
     d4a:	09 f0       	breq	.+2      	; 0xd4e <lcd_busy_wait+0x276>
     d4c:	ec ce       	rjmp	.-552    	; 0xb26 <lcd_busy_wait+0x4e>
	
	PORTB |= 1<<PB3;
     d4e:	85 e2       	ldi	r24, 0x25	; 37
     d50:	90 e0       	ldi	r25, 0x00	; 0
     d52:	25 e2       	ldi	r18, 0x25	; 37
     d54:	30 e0       	ldi	r19, 0x00	; 0
     d56:	f9 01       	movw	r30, r18
     d58:	20 81       	ld	r18, Z
     d5a:	28 60       	ori	r18, 0x08	; 8
     d5c:	fc 01       	movw	r30, r24
     d5e:	20 83       	st	Z, r18
	RW_LO();
     d60:	8b e2       	ldi	r24, 0x2B	; 43
     d62:	90 e0       	ldi	r25, 0x00	; 0
     d64:	2b e2       	ldi	r18, 0x2B	; 43
     d66:	30 e0       	ldi	r19, 0x00	; 0
     d68:	f9 01       	movw	r30, r18
     d6a:	20 81       	ld	r18, Z
     d6c:	2d 7f       	andi	r18, 0xFD	; 253
     d6e:	fc 01       	movw	r30, r24
     d70:	20 83       	st	Z, r18
	return;
     d72:	00 00       	nop
}
     d74:	a1 96       	adiw	r28, 0x21	; 33
     d76:	0f b6       	in	r0, 0x3f	; 63
     d78:	f8 94       	cli
     d7a:	de bf       	out	0x3e, r29	; 62
     d7c:	0f be       	out	0x3f, r0	; 63
     d7e:	cd bf       	out	0x3d, r28	; 61
     d80:	df 91       	pop	r29
     d82:	cf 91       	pop	r28
     d84:	08 95       	ret

00000d86 <lcd_begin>:


void lcd_begin()
{
     d86:	0f 93       	push	r16
     d88:	1f 93       	push	r17
     d8a:	cf 93       	push	r28
     d8c:	df 93       	push	r29
     d8e:	cd b7       	in	r28, 0x3d	; 61
     d90:	de b7       	in	r29, 0x3e	; 62
     d92:	c4 59       	subi	r28, 0x94	; 148
     d94:	d1 09       	sbc	r29, r1
     d96:	0f b6       	in	r0, 0x3f	; 63
     d98:	f8 94       	cli
     d9a:	de bf       	out	0x3e, r29	; 62
     d9c:	0f be       	out	0x3f, r0	; 63
     d9e:	cd bf       	out	0x3d, r28	; 61
     da0:	80 e0       	ldi	r24, 0x00	; 0
     da2:	90 e0       	ldi	r25, 0x00	; 0
     da4:	a8 e4       	ldi	r26, 0x48	; 72
     da6:	b2 e4       	ldi	r27, 0x42	; 66
     da8:	89 83       	std	Y+1, r24	; 0x01
     daa:	9a 83       	std	Y+2, r25	; 0x02
     dac:	ab 83       	std	Y+3, r26	; 0x03
     dae:	bc 83       	std	Y+4, r27	; 0x04

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     db0:	8e 01       	movw	r16, r28
     db2:	05 57       	subi	r16, 0x75	; 117
     db4:	1f 4f       	sbci	r17, 0xFF	; 255
     db6:	20 e0       	ldi	r18, 0x00	; 0
     db8:	30 e0       	ldi	r19, 0x00	; 0
     dba:	4a e7       	ldi	r20, 0x7A	; 122
     dbc:	55 e4       	ldi	r21, 0x45	; 69
     dbe:	69 81       	ldd	r22, Y+1	; 0x01
     dc0:	7a 81       	ldd	r23, Y+2	; 0x02
     dc2:	8b 81       	ldd	r24, Y+3	; 0x03
     dc4:	9c 81       	ldd	r25, Y+4	; 0x04
     dc6:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
     dca:	dc 01       	movw	r26, r24
     dcc:	cb 01       	movw	r24, r22
     dce:	f8 01       	movw	r30, r16
     dd0:	80 83       	st	Z, r24
     dd2:	91 83       	std	Z+1, r25	; 0x01
     dd4:	a2 83       	std	Z+2, r26	; 0x02
     dd6:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
     dd8:	ce 01       	movw	r24, r28
     dda:	85 57       	subi	r24, 0x75	; 117
     ddc:	9f 4f       	sbci	r25, 0xFF	; 255
     dde:	20 e0       	ldi	r18, 0x00	; 0
     de0:	30 e0       	ldi	r19, 0x00	; 0
     de2:	40 e8       	ldi	r20, 0x80	; 128
     de4:	5f e3       	ldi	r21, 0x3F	; 63
     de6:	fc 01       	movw	r30, r24
     de8:	60 81       	ld	r22, Z
     dea:	71 81       	ldd	r23, Z+1	; 0x01
     dec:	82 81       	ldd	r24, Z+2	; 0x02
     dee:	93 81       	ldd	r25, Z+3	; 0x03
     df0:	0e 94 00 1a 	call	0x3400	; 0x3400 <__cmpsf2>
     df4:	88 23       	and	r24, r24
     df6:	4c f4       	brge	.+18     	; 0xe0a <lcd_begin+0x84>
		__ticks = 1;
     df8:	ce 01       	movw	r24, r28
     dfa:	81 57       	subi	r24, 0x71	; 113
     dfc:	9f 4f       	sbci	r25, 0xFF	; 255
     dfe:	21 e0       	ldi	r18, 0x01	; 1
     e00:	30 e0       	ldi	r19, 0x00	; 0
     e02:	fc 01       	movw	r30, r24
     e04:	31 83       	std	Z+1, r19	; 0x01
     e06:	20 83       	st	Z, r18
     e08:	69 c0       	rjmp	.+210    	; 0xedc <lcd_begin+0x156>
	else if (__tmp > 65535)
     e0a:	ce 01       	movw	r24, r28
     e0c:	85 57       	subi	r24, 0x75	; 117
     e0e:	9f 4f       	sbci	r25, 0xFF	; 255
     e10:	20 e0       	ldi	r18, 0x00	; 0
     e12:	3f ef       	ldi	r19, 0xFF	; 255
     e14:	4f e7       	ldi	r20, 0x7F	; 127
     e16:	57 e4       	ldi	r21, 0x47	; 71
     e18:	fc 01       	movw	r30, r24
     e1a:	60 81       	ld	r22, Z
     e1c:	71 81       	ldd	r23, Z+1	; 0x01
     e1e:	82 81       	ldd	r24, Z+2	; 0x02
     e20:	93 81       	ldd	r25, Z+3	; 0x03
     e22:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
     e26:	18 16       	cp	r1, r24
     e28:	0c f0       	brlt	.+2      	; 0xe2c <lcd_begin+0xa6>
     e2a:	46 c0       	rjmp	.+140    	; 0xeb8 <lcd_begin+0x132>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     e2c:	20 e0       	ldi	r18, 0x00	; 0
     e2e:	30 e0       	ldi	r19, 0x00	; 0
     e30:	40 e2       	ldi	r20, 0x20	; 32
     e32:	51 e4       	ldi	r21, 0x41	; 65
     e34:	69 81       	ldd	r22, Y+1	; 0x01
     e36:	7a 81       	ldd	r23, Y+2	; 0x02
     e38:	8b 81       	ldd	r24, Y+3	; 0x03
     e3a:	9c 81       	ldd	r25, Y+4	; 0x04
     e3c:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
     e40:	dc 01       	movw	r26, r24
     e42:	cb 01       	movw	r24, r22
     e44:	8e 01       	movw	r16, r28
     e46:	01 57       	subi	r16, 0x71	; 113
     e48:	1f 4f       	sbci	r17, 0xFF	; 255
     e4a:	bc 01       	movw	r22, r24
     e4c:	cd 01       	movw	r24, r26
     e4e:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
     e52:	dc 01       	movw	r26, r24
     e54:	cb 01       	movw	r24, r22
     e56:	f8 01       	movw	r30, r16
     e58:	91 83       	std	Z+1, r25	; 0x01
     e5a:	80 83       	st	Z, r24
     e5c:	24 c0       	rjmp	.+72     	; 0xea6 <lcd_begin+0x120>
     e5e:	ce 01       	movw	r24, r28
     e60:	8f 56       	subi	r24, 0x6F	; 111
     e62:	9f 4f       	sbci	r25, 0xFF	; 255
     e64:	20 e9       	ldi	r18, 0x90	; 144
     e66:	31 e0       	ldi	r19, 0x01	; 1
     e68:	fc 01       	movw	r30, r24
     e6a:	31 83       	std	Z+1, r19	; 0x01
     e6c:	20 83       	st	Z, r18
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     e6e:	ce 01       	movw	r24, r28
     e70:	8f 56       	subi	r24, 0x6F	; 111
     e72:	9f 4f       	sbci	r25, 0xFF	; 255
     e74:	fc 01       	movw	r30, r24
     e76:	80 81       	ld	r24, Z
     e78:	91 81       	ldd	r25, Z+1	; 0x01
     e7a:	01 97       	sbiw	r24, 0x01	; 1
     e7c:	f1 f7       	brne	.-4      	; 0xe7a <lcd_begin+0xf4>
     e7e:	9e 01       	movw	r18, r28
     e80:	2f 56       	subi	r18, 0x6F	; 111
     e82:	3f 4f       	sbci	r19, 0xFF	; 255
     e84:	f9 01       	movw	r30, r18
     e86:	91 83       	std	Z+1, r25	; 0x01
     e88:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     e8a:	ce 01       	movw	r24, r28
     e8c:	81 57       	subi	r24, 0x71	; 113
     e8e:	9f 4f       	sbci	r25, 0xFF	; 255
     e90:	9e 01       	movw	r18, r28
     e92:	21 57       	subi	r18, 0x71	; 113
     e94:	3f 4f       	sbci	r19, 0xFF	; 255
     e96:	f9 01       	movw	r30, r18
     e98:	20 81       	ld	r18, Z
     e9a:	31 81       	ldd	r19, Z+1	; 0x01
     e9c:	21 50       	subi	r18, 0x01	; 1
     e9e:	31 09       	sbc	r19, r1
     ea0:	fc 01       	movw	r30, r24
     ea2:	31 83       	std	Z+1, r19	; 0x01
     ea4:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     ea6:	ce 01       	movw	r24, r28
     ea8:	81 57       	subi	r24, 0x71	; 113
     eaa:	9f 4f       	sbci	r25, 0xFF	; 255
     eac:	fc 01       	movw	r30, r24
     eae:	80 81       	ld	r24, Z
     eb0:	91 81       	ldd	r25, Z+1	; 0x01
     eb2:	89 2b       	or	r24, r25
     eb4:	a1 f6       	brne	.-88     	; 0xe5e <lcd_begin+0xd8>
     eb6:	2c c0       	rjmp	.+88     	; 0xf10 <lcd_begin+0x18a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     eb8:	8e 01       	movw	r16, r28
     eba:	01 57       	subi	r16, 0x71	; 113
     ebc:	1f 4f       	sbci	r17, 0xFF	; 255
     ebe:	ce 01       	movw	r24, r28
     ec0:	85 57       	subi	r24, 0x75	; 117
     ec2:	9f 4f       	sbci	r25, 0xFF	; 255
     ec4:	fc 01       	movw	r30, r24
     ec6:	60 81       	ld	r22, Z
     ec8:	71 81       	ldd	r23, Z+1	; 0x01
     eca:	82 81       	ldd	r24, Z+2	; 0x02
     ecc:	93 81       	ldd	r25, Z+3	; 0x03
     ece:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
     ed2:	dc 01       	movw	r26, r24
     ed4:	cb 01       	movw	r24, r22
     ed6:	f8 01       	movw	r30, r16
     ed8:	91 83       	std	Z+1, r25	; 0x01
     eda:	80 83       	st	Z, r24
     edc:	ce 01       	movw	r24, r28
     ede:	8d 56       	subi	r24, 0x6D	; 109
     ee0:	9f 4f       	sbci	r25, 0xFF	; 255
     ee2:	9e 01       	movw	r18, r28
     ee4:	21 57       	subi	r18, 0x71	; 113
     ee6:	3f 4f       	sbci	r19, 0xFF	; 255
     ee8:	f9 01       	movw	r30, r18
     eea:	20 81       	ld	r18, Z
     eec:	31 81       	ldd	r19, Z+1	; 0x01
     eee:	fc 01       	movw	r30, r24
     ef0:	31 83       	std	Z+1, r19	; 0x01
     ef2:	20 83       	st	Z, r18
     ef4:	ce 01       	movw	r24, r28
     ef6:	8d 56       	subi	r24, 0x6D	; 109
     ef8:	9f 4f       	sbci	r25, 0xFF	; 255
     efa:	fc 01       	movw	r30, r24
     efc:	80 81       	ld	r24, Z
     efe:	91 81       	ldd	r25, Z+1	; 0x01
     f00:	01 97       	sbiw	r24, 0x01	; 1
     f02:	f1 f7       	brne	.-4      	; 0xf00 <lcd_begin+0x17a>
     f04:	9e 01       	movw	r18, r28
     f06:	2d 56       	subi	r18, 0x6D	; 109
     f08:	3f 4f       	sbci	r19, 0xFF	; 255
     f0a:	f9 01       	movw	r30, r18
     f0c:	91 83       	std	Z+1, r25	; 0x01
     f0e:	80 83       	st	Z, r24
	_delay_ms(50);
	lcd_port_init_4Bit();
     f10:	0e 94 32 02 	call	0x464	; 0x464 <lcd_port_init_4Bit>
	
	lcd_write_cmd_byte(0x03);
     f14:	83 e0       	ldi	r24, 0x03	; 3
     f16:	0e 94 51 05 	call	0xaa2	; 0xaa2 <lcd_write_cmd_byte>
     f1a:	80 e0       	ldi	r24, 0x00	; 0
     f1c:	90 e0       	ldi	r25, 0x00	; 0
     f1e:	a0 ea       	ldi	r26, 0xA0	; 160
     f20:	b0 e4       	ldi	r27, 0x40	; 64
     f22:	8d 83       	std	Y+5, r24	; 0x05
     f24:	9e 83       	std	Y+6, r25	; 0x06
     f26:	af 83       	std	Y+7, r26	; 0x07
     f28:	b8 87       	std	Y+8, r27	; 0x08

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     f2a:	8e 01       	movw	r16, r28
     f2c:	0f 57       	subi	r16, 0x7F	; 127
     f2e:	1f 4f       	sbci	r17, 0xFF	; 255
     f30:	20 e0       	ldi	r18, 0x00	; 0
     f32:	30 e0       	ldi	r19, 0x00	; 0
     f34:	4a e7       	ldi	r20, 0x7A	; 122
     f36:	55 e4       	ldi	r21, 0x45	; 69
     f38:	6d 81       	ldd	r22, Y+5	; 0x05
     f3a:	7e 81       	ldd	r23, Y+6	; 0x06
     f3c:	8f 81       	ldd	r24, Y+7	; 0x07
     f3e:	98 85       	ldd	r25, Y+8	; 0x08
     f40:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
     f44:	dc 01       	movw	r26, r24
     f46:	cb 01       	movw	r24, r22
     f48:	f8 01       	movw	r30, r16
     f4a:	80 83       	st	Z, r24
     f4c:	91 83       	std	Z+1, r25	; 0x01
     f4e:	a2 83       	std	Z+2, r26	; 0x02
     f50:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
     f52:	ce 01       	movw	r24, r28
     f54:	8f 57       	subi	r24, 0x7F	; 127
     f56:	9f 4f       	sbci	r25, 0xFF	; 255
     f58:	20 e0       	ldi	r18, 0x00	; 0
     f5a:	30 e0       	ldi	r19, 0x00	; 0
     f5c:	40 e8       	ldi	r20, 0x80	; 128
     f5e:	5f e3       	ldi	r21, 0x3F	; 63
     f60:	fc 01       	movw	r30, r24
     f62:	60 81       	ld	r22, Z
     f64:	71 81       	ldd	r23, Z+1	; 0x01
     f66:	82 81       	ldd	r24, Z+2	; 0x02
     f68:	93 81       	ldd	r25, Z+3	; 0x03
     f6a:	0e 94 00 1a 	call	0x3400	; 0x3400 <__cmpsf2>
     f6e:	88 23       	and	r24, r24
     f70:	4c f4       	brge	.+18     	; 0xf84 <lcd_begin+0x1fe>
		__ticks = 1;
     f72:	ce 01       	movw	r24, r28
     f74:	8b 57       	subi	r24, 0x7B	; 123
     f76:	9f 4f       	sbci	r25, 0xFF	; 255
     f78:	21 e0       	ldi	r18, 0x01	; 1
     f7a:	30 e0       	ldi	r19, 0x00	; 0
     f7c:	fc 01       	movw	r30, r24
     f7e:	31 83       	std	Z+1, r19	; 0x01
     f80:	20 83       	st	Z, r18
     f82:	69 c0       	rjmp	.+210    	; 0x1056 <lcd_begin+0x2d0>
	else if (__tmp > 65535)
     f84:	ce 01       	movw	r24, r28
     f86:	8f 57       	subi	r24, 0x7F	; 127
     f88:	9f 4f       	sbci	r25, 0xFF	; 255
     f8a:	20 e0       	ldi	r18, 0x00	; 0
     f8c:	3f ef       	ldi	r19, 0xFF	; 255
     f8e:	4f e7       	ldi	r20, 0x7F	; 127
     f90:	57 e4       	ldi	r21, 0x47	; 71
     f92:	fc 01       	movw	r30, r24
     f94:	60 81       	ld	r22, Z
     f96:	71 81       	ldd	r23, Z+1	; 0x01
     f98:	82 81       	ldd	r24, Z+2	; 0x02
     f9a:	93 81       	ldd	r25, Z+3	; 0x03
     f9c:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
     fa0:	18 16       	cp	r1, r24
     fa2:	0c f0       	brlt	.+2      	; 0xfa6 <lcd_begin+0x220>
     fa4:	46 c0       	rjmp	.+140    	; 0x1032 <lcd_begin+0x2ac>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     fa6:	20 e0       	ldi	r18, 0x00	; 0
     fa8:	30 e0       	ldi	r19, 0x00	; 0
     faa:	40 e2       	ldi	r20, 0x20	; 32
     fac:	51 e4       	ldi	r21, 0x41	; 65
     fae:	6d 81       	ldd	r22, Y+5	; 0x05
     fb0:	7e 81       	ldd	r23, Y+6	; 0x06
     fb2:	8f 81       	ldd	r24, Y+7	; 0x07
     fb4:	98 85       	ldd	r25, Y+8	; 0x08
     fb6:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
     fba:	dc 01       	movw	r26, r24
     fbc:	cb 01       	movw	r24, r22
     fbe:	8e 01       	movw	r16, r28
     fc0:	0b 57       	subi	r16, 0x7B	; 123
     fc2:	1f 4f       	sbci	r17, 0xFF	; 255
     fc4:	bc 01       	movw	r22, r24
     fc6:	cd 01       	movw	r24, r26
     fc8:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
     fcc:	dc 01       	movw	r26, r24
     fce:	cb 01       	movw	r24, r22
     fd0:	f8 01       	movw	r30, r16
     fd2:	91 83       	std	Z+1, r25	; 0x01
     fd4:	80 83       	st	Z, r24
     fd6:	24 c0       	rjmp	.+72     	; 0x1020 <lcd_begin+0x29a>
     fd8:	ce 01       	movw	r24, r28
     fda:	89 57       	subi	r24, 0x79	; 121
     fdc:	9f 4f       	sbci	r25, 0xFF	; 255
     fde:	20 e9       	ldi	r18, 0x90	; 144
     fe0:	31 e0       	ldi	r19, 0x01	; 1
     fe2:	fc 01       	movw	r30, r24
     fe4:	31 83       	std	Z+1, r19	; 0x01
     fe6:	20 83       	st	Z, r18
     fe8:	ce 01       	movw	r24, r28
     fea:	89 57       	subi	r24, 0x79	; 121
     fec:	9f 4f       	sbci	r25, 0xFF	; 255
     fee:	fc 01       	movw	r30, r24
     ff0:	80 81       	ld	r24, Z
     ff2:	91 81       	ldd	r25, Z+1	; 0x01
     ff4:	01 97       	sbiw	r24, 0x01	; 1
     ff6:	f1 f7       	brne	.-4      	; 0xff4 <lcd_begin+0x26e>
     ff8:	9e 01       	movw	r18, r28
     ffa:	29 57       	subi	r18, 0x79	; 121
     ffc:	3f 4f       	sbci	r19, 0xFF	; 255
     ffe:	f9 01       	movw	r30, r18
    1000:	91 83       	std	Z+1, r25	; 0x01
    1002:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1004:	ce 01       	movw	r24, r28
    1006:	8b 57       	subi	r24, 0x7B	; 123
    1008:	9f 4f       	sbci	r25, 0xFF	; 255
    100a:	9e 01       	movw	r18, r28
    100c:	2b 57       	subi	r18, 0x7B	; 123
    100e:	3f 4f       	sbci	r19, 0xFF	; 255
    1010:	f9 01       	movw	r30, r18
    1012:	20 81       	ld	r18, Z
    1014:	31 81       	ldd	r19, Z+1	; 0x01
    1016:	21 50       	subi	r18, 0x01	; 1
    1018:	31 09       	sbc	r19, r1
    101a:	fc 01       	movw	r30, r24
    101c:	31 83       	std	Z+1, r19	; 0x01
    101e:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1020:	ce 01       	movw	r24, r28
    1022:	8b 57       	subi	r24, 0x7B	; 123
    1024:	9f 4f       	sbci	r25, 0xFF	; 255
    1026:	fc 01       	movw	r30, r24
    1028:	80 81       	ld	r24, Z
    102a:	91 81       	ldd	r25, Z+1	; 0x01
    102c:	89 2b       	or	r24, r25
    102e:	a1 f6       	brne	.-88     	; 0xfd8 <lcd_begin+0x252>
    1030:	2c c0       	rjmp	.+88     	; 0x108a <lcd_begin+0x304>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1032:	8e 01       	movw	r16, r28
    1034:	0b 57       	subi	r16, 0x7B	; 123
    1036:	1f 4f       	sbci	r17, 0xFF	; 255
    1038:	ce 01       	movw	r24, r28
    103a:	8f 57       	subi	r24, 0x7F	; 127
    103c:	9f 4f       	sbci	r25, 0xFF	; 255
    103e:	fc 01       	movw	r30, r24
    1040:	60 81       	ld	r22, Z
    1042:	71 81       	ldd	r23, Z+1	; 0x01
    1044:	82 81       	ldd	r24, Z+2	; 0x02
    1046:	93 81       	ldd	r25, Z+3	; 0x03
    1048:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    104c:	dc 01       	movw	r26, r24
    104e:	cb 01       	movw	r24, r22
    1050:	f8 01       	movw	r30, r16
    1052:	91 83       	std	Z+1, r25	; 0x01
    1054:	80 83       	st	Z, r24
    1056:	ce 01       	movw	r24, r28
    1058:	87 57       	subi	r24, 0x77	; 119
    105a:	9f 4f       	sbci	r25, 0xFF	; 255
    105c:	9e 01       	movw	r18, r28
    105e:	2b 57       	subi	r18, 0x7B	; 123
    1060:	3f 4f       	sbci	r19, 0xFF	; 255
    1062:	f9 01       	movw	r30, r18
    1064:	20 81       	ld	r18, Z
    1066:	31 81       	ldd	r19, Z+1	; 0x01
    1068:	fc 01       	movw	r30, r24
    106a:	31 83       	std	Z+1, r19	; 0x01
    106c:	20 83       	st	Z, r18
    106e:	ce 01       	movw	r24, r28
    1070:	87 57       	subi	r24, 0x77	; 119
    1072:	9f 4f       	sbci	r25, 0xFF	; 255
    1074:	fc 01       	movw	r30, r24
    1076:	80 81       	ld	r24, Z
    1078:	91 81       	ldd	r25, Z+1	; 0x01
    107a:	01 97       	sbiw	r24, 0x01	; 1
    107c:	f1 f7       	brne	.-4      	; 0x107a <lcd_begin+0x2f4>
    107e:	9e 01       	movw	r18, r28
    1080:	27 57       	subi	r18, 0x77	; 119
    1082:	3f 4f       	sbci	r19, 0xFF	; 255
    1084:	f9 01       	movw	r30, r18
    1086:	91 83       	std	Z+1, r25	; 0x01
    1088:	80 83       	st	Z, r24
	_delay_ms(5);
	lcd_write_cmd_byte(0x03);
    108a:	83 e0       	ldi	r24, 0x03	; 3
    108c:	0e 94 51 05 	call	0xaa2	; 0xaa2 <lcd_write_cmd_byte>
    1090:	80 e0       	ldi	r24, 0x00	; 0
    1092:	90 e0       	ldi	r25, 0x00	; 0
    1094:	a0 e2       	ldi	r26, 0x20	; 32
    1096:	b3 e4       	ldi	r27, 0x43	; 67
    1098:	89 87       	std	Y+9, r24	; 0x09
    109a:	9a 87       	std	Y+10, r25	; 0x0a
    109c:	ab 87       	std	Y+11, r26	; 0x0b
    109e:	bc 87       	std	Y+12, r27	; 0x0c
	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint8_t __ticks;
	double __tmp2 ;
	__tmp = ((F_CPU) / 3e6) * __us;
    10a0:	8e 01       	movw	r16, r28
    10a2:	0b 59       	subi	r16, 0x9B	; 155
    10a4:	1f 4f       	sbci	r17, 0xFF	; 255
    10a6:	2b ea       	ldi	r18, 0xAB	; 171
    10a8:	3a ea       	ldi	r19, 0xAA	; 170
    10aa:	4a ea       	ldi	r20, 0xAA	; 170
    10ac:	50 e4       	ldi	r21, 0x40	; 64
    10ae:	69 85       	ldd	r22, Y+9	; 0x09
    10b0:	7a 85       	ldd	r23, Y+10	; 0x0a
    10b2:	8b 85       	ldd	r24, Y+11	; 0x0b
    10b4:	9c 85       	ldd	r25, Y+12	; 0x0c
    10b6:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
    10ba:	dc 01       	movw	r26, r24
    10bc:	cb 01       	movw	r24, r22
    10be:	f8 01       	movw	r30, r16
    10c0:	80 83       	st	Z, r24
    10c2:	91 83       	std	Z+1, r25	; 0x01
    10c4:	a2 83       	std	Z+2, r26	; 0x02
    10c6:	b3 83       	std	Z+3, r27	; 0x03
	__tmp2 = ((F_CPU) / 4e6) * __us;
    10c8:	8e 01       	movw	r16, r28
    10ca:	07 59       	subi	r16, 0x97	; 151
    10cc:	1f 4f       	sbci	r17, 0xFF	; 255
    10ce:	20 e0       	ldi	r18, 0x00	; 0
    10d0:	30 e0       	ldi	r19, 0x00	; 0
    10d2:	40 e8       	ldi	r20, 0x80	; 128
    10d4:	50 e4       	ldi	r21, 0x40	; 64
    10d6:	69 85       	ldd	r22, Y+9	; 0x09
    10d8:	7a 85       	ldd	r23, Y+10	; 0x0a
    10da:	8b 85       	ldd	r24, Y+11	; 0x0b
    10dc:	9c 85       	ldd	r25, Y+12	; 0x0c
    10de:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
    10e2:	dc 01       	movw	r26, r24
    10e4:	cb 01       	movw	r24, r22
    10e6:	f8 01       	movw	r30, r16
    10e8:	80 83       	st	Z, r24
    10ea:	91 83       	std	Z+1, r25	; 0x01
    10ec:	a2 83       	std	Z+2, r26	; 0x02
    10ee:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    10f0:	ce 01       	movw	r24, r28
    10f2:	8b 59       	subi	r24, 0x9B	; 155
    10f4:	9f 4f       	sbci	r25, 0xFF	; 255
    10f6:	20 e0       	ldi	r18, 0x00	; 0
    10f8:	30 e0       	ldi	r19, 0x00	; 0
    10fa:	40 e8       	ldi	r20, 0x80	; 128
    10fc:	5f e3       	ldi	r21, 0x3F	; 63
    10fe:	fc 01       	movw	r30, r24
    1100:	60 81       	ld	r22, Z
    1102:	71 81       	ldd	r23, Z+1	; 0x01
    1104:	82 81       	ldd	r24, Z+2	; 0x02
    1106:	93 81       	ldd	r25, Z+3	; 0x03
    1108:	0e 94 00 1a 	call	0x3400	; 0x3400 <__cmpsf2>
    110c:	88 23       	and	r24, r24
    110e:	3c f4       	brge	.+14     	; 0x111e <lcd_begin+0x398>
		__ticks = 1;
    1110:	ce 01       	movw	r24, r28
    1112:	83 59       	subi	r24, 0x93	; 147
    1114:	9f 4f       	sbci	r25, 0xFF	; 255
    1116:	21 e0       	ldi	r18, 0x01	; 1
    1118:	fc 01       	movw	r30, r24
    111a:	20 83       	st	Z, r18
    111c:	2c c1       	rjmp	.+600    	; 0x1376 <lcd_begin+0x5f0>
	else if (__tmp2 > 65535)
    111e:	ce 01       	movw	r24, r28
    1120:	87 59       	subi	r24, 0x97	; 151
    1122:	9f 4f       	sbci	r25, 0xFF	; 255
    1124:	20 e0       	ldi	r18, 0x00	; 0
    1126:	3f ef       	ldi	r19, 0xFF	; 255
    1128:	4f e7       	ldi	r20, 0x7F	; 127
    112a:	57 e4       	ldi	r21, 0x47	; 71
    112c:	fc 01       	movw	r30, r24
    112e:	60 81       	ld	r22, Z
    1130:	71 81       	ldd	r23, Z+1	; 0x01
    1132:	82 81       	ldd	r24, Z+2	; 0x02
    1134:	93 81       	ldd	r25, Z+3	; 0x03
    1136:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
    113a:	18 16       	cp	r1, r24
    113c:	0c f0       	brlt	.+2      	; 0x1140 <lcd_begin+0x3ba>
    113e:	cd c0       	rjmp	.+410    	; 0x12da <lcd_begin+0x554>
	{
		_delay_ms(__us / 1000.0);
    1140:	20 e0       	ldi	r18, 0x00	; 0
    1142:	30 e0       	ldi	r19, 0x00	; 0
    1144:	4a e7       	ldi	r20, 0x7A	; 122
    1146:	54 e4       	ldi	r21, 0x44	; 68
    1148:	69 85       	ldd	r22, Y+9	; 0x09
    114a:	7a 85       	ldd	r23, Y+10	; 0x0a
    114c:	8b 85       	ldd	r24, Y+11	; 0x0b
    114e:	9c 85       	ldd	r25, Y+12	; 0x0c
    1150:	0e 94 05 1a 	call	0x340a	; 0x340a <__divsf3>
    1154:	dc 01       	movw	r26, r24
    1156:	cb 01       	movw	r24, r22
    1158:	9e 01       	movw	r18, r28
    115a:	22 59       	subi	r18, 0x92	; 146
    115c:	3f 4f       	sbci	r19, 0xFF	; 255
    115e:	f9 01       	movw	r30, r18
    1160:	80 83       	st	Z, r24
    1162:	91 83       	std	Z+1, r25	; 0x01
    1164:	a2 83       	std	Z+2, r26	; 0x02
    1166:	b3 83       	std	Z+3, r27	; 0x03

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    1168:	8e 01       	movw	r16, r28
    116a:	0e 58       	subi	r16, 0x8E	; 142
    116c:	1f 4f       	sbci	r17, 0xFF	; 255
    116e:	ce 01       	movw	r24, r28
    1170:	82 59       	subi	r24, 0x92	; 146
    1172:	9f 4f       	sbci	r25, 0xFF	; 255
    1174:	20 e0       	ldi	r18, 0x00	; 0
    1176:	30 e0       	ldi	r19, 0x00	; 0
    1178:	4a e7       	ldi	r20, 0x7A	; 122
    117a:	55 e4       	ldi	r21, 0x45	; 69
    117c:	fc 01       	movw	r30, r24
    117e:	60 81       	ld	r22, Z
    1180:	71 81       	ldd	r23, Z+1	; 0x01
    1182:	82 81       	ldd	r24, Z+2	; 0x02
    1184:	93 81       	ldd	r25, Z+3	; 0x03
    1186:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
    118a:	dc 01       	movw	r26, r24
    118c:	cb 01       	movw	r24, r22
    118e:	f8 01       	movw	r30, r16
    1190:	80 83       	st	Z, r24
    1192:	91 83       	std	Z+1, r25	; 0x01
    1194:	a2 83       	std	Z+2, r26	; 0x02
    1196:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1198:	ce 01       	movw	r24, r28
    119a:	8e 58       	subi	r24, 0x8E	; 142
    119c:	9f 4f       	sbci	r25, 0xFF	; 255
    119e:	20 e0       	ldi	r18, 0x00	; 0
    11a0:	30 e0       	ldi	r19, 0x00	; 0
    11a2:	40 e8       	ldi	r20, 0x80	; 128
    11a4:	5f e3       	ldi	r21, 0x3F	; 63
    11a6:	fc 01       	movw	r30, r24
    11a8:	60 81       	ld	r22, Z
    11aa:	71 81       	ldd	r23, Z+1	; 0x01
    11ac:	82 81       	ldd	r24, Z+2	; 0x02
    11ae:	93 81       	ldd	r25, Z+3	; 0x03
    11b0:	0e 94 00 1a 	call	0x3400	; 0x3400 <__cmpsf2>
    11b4:	88 23       	and	r24, r24
    11b6:	4c f4       	brge	.+18     	; 0x11ca <lcd_begin+0x444>
		__ticks = 1;
    11b8:	ce 01       	movw	r24, r28
    11ba:	8a 58       	subi	r24, 0x8A	; 138
    11bc:	9f 4f       	sbci	r25, 0xFF	; 255
    11be:	21 e0       	ldi	r18, 0x01	; 1
    11c0:	30 e0       	ldi	r19, 0x00	; 0
    11c2:	fc 01       	movw	r30, r24
    11c4:	31 83       	std	Z+1, r19	; 0x01
    11c6:	20 83       	st	Z, r18
    11c8:	6d c0       	rjmp	.+218    	; 0x12a4 <lcd_begin+0x51e>
	else if (__tmp > 65535)
    11ca:	ce 01       	movw	r24, r28
    11cc:	8e 58       	subi	r24, 0x8E	; 142
    11ce:	9f 4f       	sbci	r25, 0xFF	; 255
    11d0:	20 e0       	ldi	r18, 0x00	; 0
    11d2:	3f ef       	ldi	r19, 0xFF	; 255
    11d4:	4f e7       	ldi	r20, 0x7F	; 127
    11d6:	57 e4       	ldi	r21, 0x47	; 71
    11d8:	fc 01       	movw	r30, r24
    11da:	60 81       	ld	r22, Z
    11dc:	71 81       	ldd	r23, Z+1	; 0x01
    11de:	82 81       	ldd	r24, Z+2	; 0x02
    11e0:	93 81       	ldd	r25, Z+3	; 0x03
    11e2:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
    11e6:	18 16       	cp	r1, r24
    11e8:	0c f0       	brlt	.+2      	; 0x11ec <lcd_begin+0x466>
    11ea:	4a c0       	rjmp	.+148    	; 0x1280 <lcd_begin+0x4fa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    11ec:	ce 01       	movw	r24, r28
    11ee:	82 59       	subi	r24, 0x92	; 146
    11f0:	9f 4f       	sbci	r25, 0xFF	; 255
    11f2:	20 e0       	ldi	r18, 0x00	; 0
    11f4:	30 e0       	ldi	r19, 0x00	; 0
    11f6:	40 e2       	ldi	r20, 0x20	; 32
    11f8:	51 e4       	ldi	r21, 0x41	; 65
    11fa:	fc 01       	movw	r30, r24
    11fc:	60 81       	ld	r22, Z
    11fe:	71 81       	ldd	r23, Z+1	; 0x01
    1200:	82 81       	ldd	r24, Z+2	; 0x02
    1202:	93 81       	ldd	r25, Z+3	; 0x03
    1204:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
    1208:	dc 01       	movw	r26, r24
    120a:	cb 01       	movw	r24, r22
    120c:	8e 01       	movw	r16, r28
    120e:	0a 58       	subi	r16, 0x8A	; 138
    1210:	1f 4f       	sbci	r17, 0xFF	; 255
    1212:	bc 01       	movw	r22, r24
    1214:	cd 01       	movw	r24, r26
    1216:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    121a:	dc 01       	movw	r26, r24
    121c:	cb 01       	movw	r24, r22
    121e:	f8 01       	movw	r30, r16
    1220:	91 83       	std	Z+1, r25	; 0x01
    1222:	80 83       	st	Z, r24
    1224:	24 c0       	rjmp	.+72     	; 0x126e <lcd_begin+0x4e8>
    1226:	ce 01       	movw	r24, r28
    1228:	88 58       	subi	r24, 0x88	; 136
    122a:	9f 4f       	sbci	r25, 0xFF	; 255
    122c:	20 e9       	ldi	r18, 0x90	; 144
    122e:	31 e0       	ldi	r19, 0x01	; 1
    1230:	fc 01       	movw	r30, r24
    1232:	31 83       	std	Z+1, r19	; 0x01
    1234:	20 83       	st	Z, r18
    1236:	ce 01       	movw	r24, r28
    1238:	88 58       	subi	r24, 0x88	; 136
    123a:	9f 4f       	sbci	r25, 0xFF	; 255
    123c:	fc 01       	movw	r30, r24
    123e:	80 81       	ld	r24, Z
    1240:	91 81       	ldd	r25, Z+1	; 0x01
    1242:	01 97       	sbiw	r24, 0x01	; 1
    1244:	f1 f7       	brne	.-4      	; 0x1242 <lcd_begin+0x4bc>
    1246:	9e 01       	movw	r18, r28
    1248:	28 58       	subi	r18, 0x88	; 136
    124a:	3f 4f       	sbci	r19, 0xFF	; 255
    124c:	f9 01       	movw	r30, r18
    124e:	91 83       	std	Z+1, r25	; 0x01
    1250:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1252:	ce 01       	movw	r24, r28
    1254:	8a 58       	subi	r24, 0x8A	; 138
    1256:	9f 4f       	sbci	r25, 0xFF	; 255
    1258:	9e 01       	movw	r18, r28
    125a:	2a 58       	subi	r18, 0x8A	; 138
    125c:	3f 4f       	sbci	r19, 0xFF	; 255
    125e:	f9 01       	movw	r30, r18
    1260:	20 81       	ld	r18, Z
    1262:	31 81       	ldd	r19, Z+1	; 0x01
    1264:	21 50       	subi	r18, 0x01	; 1
    1266:	31 09       	sbc	r19, r1
    1268:	fc 01       	movw	r30, r24
    126a:	31 83       	std	Z+1, r19	; 0x01
    126c:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    126e:	ce 01       	movw	r24, r28
    1270:	8a 58       	subi	r24, 0x8A	; 138
    1272:	9f 4f       	sbci	r25, 0xFF	; 255
    1274:	fc 01       	movw	r30, r24
    1276:	80 81       	ld	r24, Z
    1278:	91 81       	ldd	r25, Z+1	; 0x01
    127a:	89 2b       	or	r24, r25
    127c:	a1 f6       	brne	.-88     	; 0x1226 <lcd_begin+0x4a0>
    127e:	7b c0       	rjmp	.+246    	; 0x1376 <lcd_begin+0x5f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1280:	8e 01       	movw	r16, r28
    1282:	0a 58       	subi	r16, 0x8A	; 138
    1284:	1f 4f       	sbci	r17, 0xFF	; 255
    1286:	ce 01       	movw	r24, r28
    1288:	8e 58       	subi	r24, 0x8E	; 142
    128a:	9f 4f       	sbci	r25, 0xFF	; 255
    128c:	fc 01       	movw	r30, r24
    128e:	60 81       	ld	r22, Z
    1290:	71 81       	ldd	r23, Z+1	; 0x01
    1292:	82 81       	ldd	r24, Z+2	; 0x02
    1294:	93 81       	ldd	r25, Z+3	; 0x03
    1296:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    129a:	dc 01       	movw	r26, r24
    129c:	cb 01       	movw	r24, r22
    129e:	f8 01       	movw	r30, r16
    12a0:	91 83       	std	Z+1, r25	; 0x01
    12a2:	80 83       	st	Z, r24
    12a4:	ce 01       	movw	r24, r28
    12a6:	86 58       	subi	r24, 0x86	; 134
    12a8:	9f 4f       	sbci	r25, 0xFF	; 255
    12aa:	9e 01       	movw	r18, r28
    12ac:	2a 58       	subi	r18, 0x8A	; 138
    12ae:	3f 4f       	sbci	r19, 0xFF	; 255
    12b0:	f9 01       	movw	r30, r18
    12b2:	20 81       	ld	r18, Z
    12b4:	31 81       	ldd	r19, Z+1	; 0x01
    12b6:	fc 01       	movw	r30, r24
    12b8:	31 83       	std	Z+1, r19	; 0x01
    12ba:	20 83       	st	Z, r18
    12bc:	ce 01       	movw	r24, r28
    12be:	86 58       	subi	r24, 0x86	; 134
    12c0:	9f 4f       	sbci	r25, 0xFF	; 255
    12c2:	fc 01       	movw	r30, r24
    12c4:	80 81       	ld	r24, Z
    12c6:	91 81       	ldd	r25, Z+1	; 0x01
    12c8:	01 97       	sbiw	r24, 0x01	; 1
    12ca:	f1 f7       	brne	.-4      	; 0x12c8 <lcd_begin+0x542>
    12cc:	9e 01       	movw	r18, r28
    12ce:	26 58       	subi	r18, 0x86	; 134
    12d0:	3f 4f       	sbci	r19, 0xFF	; 255
    12d2:	f9 01       	movw	r30, r18
    12d4:	91 83       	std	Z+1, r25	; 0x01
    12d6:	80 83       	st	Z, r24
    12d8:	4e c0       	rjmp	.+156    	; 0x1376 <lcd_begin+0x5f0>
		__ticks = 1;
	else if (__tmp2 > 65535)
	{
		_delay_ms(__us / 1000.0);
	}
	else if (__tmp > 255)
    12da:	ce 01       	movw	r24, r28
    12dc:	8b 59       	subi	r24, 0x9B	; 155
    12de:	9f 4f       	sbci	r25, 0xFF	; 255
    12e0:	20 e0       	ldi	r18, 0x00	; 0
    12e2:	30 e0       	ldi	r19, 0x00	; 0
    12e4:	4f e7       	ldi	r20, 0x7F	; 127
    12e6:	53 e4       	ldi	r21, 0x43	; 67
    12e8:	fc 01       	movw	r30, r24
    12ea:	60 81       	ld	r22, Z
    12ec:	71 81       	ldd	r23, Z+1	; 0x01
    12ee:	82 81       	ldd	r24, Z+2	; 0x02
    12f0:	93 81       	ldd	r25, Z+3	; 0x03
    12f2:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
    12f6:	18 16       	cp	r1, r24
    12f8:	6c f5       	brge	.+90     	; 0x1354 <lcd_begin+0x5ce>
	{
		uint16_t __ticks=(uint16_t)__tmp2;
    12fa:	8e 01       	movw	r16, r28
    12fc:	04 58       	subi	r16, 0x84	; 132
    12fe:	1f 4f       	sbci	r17, 0xFF	; 255
    1300:	ce 01       	movw	r24, r28
    1302:	87 59       	subi	r24, 0x97	; 151
    1304:	9f 4f       	sbci	r25, 0xFF	; 255
    1306:	fc 01       	movw	r30, r24
    1308:	60 81       	ld	r22, Z
    130a:	71 81       	ldd	r23, Z+1	; 0x01
    130c:	82 81       	ldd	r24, Z+2	; 0x02
    130e:	93 81       	ldd	r25, Z+3	; 0x03
    1310:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    1314:	dc 01       	movw	r26, r24
    1316:	cb 01       	movw	r24, r22
    1318:	f8 01       	movw	r30, r16
    131a:	91 83       	std	Z+1, r25	; 0x01
    131c:	80 83       	st	Z, r24
    131e:	ce 01       	movw	r24, r28
    1320:	82 58       	subi	r24, 0x82	; 130
    1322:	9f 4f       	sbci	r25, 0xFF	; 255
    1324:	9e 01       	movw	r18, r28
    1326:	24 58       	subi	r18, 0x84	; 132
    1328:	3f 4f       	sbci	r19, 0xFF	; 255
    132a:	f9 01       	movw	r30, r18
    132c:	20 81       	ld	r18, Z
    132e:	31 81       	ldd	r19, Z+1	; 0x01
    1330:	fc 01       	movw	r30, r24
    1332:	31 83       	std	Z+1, r19	; 0x01
    1334:	20 83       	st	Z, r18
    1336:	ce 01       	movw	r24, r28
    1338:	82 58       	subi	r24, 0x82	; 130
    133a:	9f 4f       	sbci	r25, 0xFF	; 255
    133c:	fc 01       	movw	r30, r24
    133e:	80 81       	ld	r24, Z
    1340:	91 81       	ldd	r25, Z+1	; 0x01
    1342:	01 97       	sbiw	r24, 0x01	; 1
    1344:	f1 f7       	brne	.-4      	; 0x1342 <lcd_begin+0x5bc>
    1346:	9e 01       	movw	r18, r28
    1348:	22 58       	subi	r18, 0x82	; 130
    134a:	3f 4f       	sbci	r19, 0xFF	; 255
    134c:	f9 01       	movw	r30, r18
    134e:	91 83       	std	Z+1, r25	; 0x01
    1350:	80 83       	st	Z, r24
    1352:	28 c0       	rjmp	.+80     	; 0x13a4 <lcd_begin+0x61e>
		_delay_loop_2(__ticks);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1354:	8e 01       	movw	r16, r28
    1356:	03 59       	subi	r16, 0x93	; 147
    1358:	1f 4f       	sbci	r17, 0xFF	; 255
    135a:	ce 01       	movw	r24, r28
    135c:	8b 59       	subi	r24, 0x9B	; 155
    135e:	9f 4f       	sbci	r25, 0xFF	; 255
    1360:	fc 01       	movw	r30, r24
    1362:	60 81       	ld	r22, Z
    1364:	71 81       	ldd	r23, Z+1	; 0x01
    1366:	82 81       	ldd	r24, Z+2	; 0x02
    1368:	93 81       	ldd	r25, Z+3	; 0x03
    136a:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    136e:	dc 01       	movw	r26, r24
    1370:	cb 01       	movw	r24, r22
    1372:	f8 01       	movw	r30, r16
    1374:	80 83       	st	Z, r24
    1376:	ce 01       	movw	r24, r28
    1378:	80 58       	subi	r24, 0x80	; 128
    137a:	9f 4f       	sbci	r25, 0xFF	; 255
    137c:	9e 01       	movw	r18, r28
    137e:	23 59       	subi	r18, 0x93	; 147
    1380:	3f 4f       	sbci	r19, 0xFF	; 255
    1382:	f9 01       	movw	r30, r18
    1384:	20 81       	ld	r18, Z
    1386:	fc 01       	movw	r30, r24
    1388:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    138a:	ce 01       	movw	r24, r28
    138c:	80 58       	subi	r24, 0x80	; 128
    138e:	9f 4f       	sbci	r25, 0xFF	; 255
    1390:	fc 01       	movw	r30, r24
    1392:	80 81       	ld	r24, Z
    1394:	28 2f       	mov	r18, r24
    1396:	2a 95       	dec	r18
    1398:	f1 f7       	brne	.-4      	; 0x1396 <lcd_begin+0x610>
    139a:	ce 01       	movw	r24, r28
    139c:	80 58       	subi	r24, 0x80	; 128
    139e:	9f 4f       	sbci	r25, 0xFF	; 255
    13a0:	fc 01       	movw	r30, r24
    13a2:	20 83       	st	Z, r18
	_delay_us(160);
	lcd_write_cmd_byte(0x03);
    13a4:	83 e0       	ldi	r24, 0x03	; 3
    13a6:	0e 94 51 05 	call	0xaa2	; 0xaa2 <lcd_write_cmd_byte>
    13aa:	80 e0       	ldi	r24, 0x00	; 0
    13ac:	90 e0       	ldi	r25, 0x00	; 0
    13ae:	a0 e2       	ldi	r26, 0x20	; 32
    13b0:	b3 e4       	ldi	r27, 0x43	; 67
    13b2:	8d 87       	std	Y+13, r24	; 0x0d
    13b4:	9e 87       	std	Y+14, r25	; 0x0e
    13b6:	af 87       	std	Y+15, r26	; 0x0f
    13b8:	b8 8b       	std	Y+16, r27	; 0x10
	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint8_t __ticks;
	double __tmp2 ;
	__tmp = ((F_CPU) / 3e6) * __us;
    13ba:	8e 01       	movw	r16, r28
    13bc:	07 5b       	subi	r16, 0xB7	; 183
    13be:	1f 4f       	sbci	r17, 0xFF	; 255
    13c0:	2b ea       	ldi	r18, 0xAB	; 171
    13c2:	3a ea       	ldi	r19, 0xAA	; 170
    13c4:	4a ea       	ldi	r20, 0xAA	; 170
    13c6:	50 e4       	ldi	r21, 0x40	; 64
    13c8:	6d 85       	ldd	r22, Y+13	; 0x0d
    13ca:	7e 85       	ldd	r23, Y+14	; 0x0e
    13cc:	8f 85       	ldd	r24, Y+15	; 0x0f
    13ce:	98 89       	ldd	r25, Y+16	; 0x10
    13d0:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
    13d4:	dc 01       	movw	r26, r24
    13d6:	cb 01       	movw	r24, r22
    13d8:	f8 01       	movw	r30, r16
    13da:	80 83       	st	Z, r24
    13dc:	91 83       	std	Z+1, r25	; 0x01
    13de:	a2 83       	std	Z+2, r26	; 0x02
    13e0:	b3 83       	std	Z+3, r27	; 0x03
	__tmp2 = ((F_CPU) / 4e6) * __us;
    13e2:	8e 01       	movw	r16, r28
    13e4:	03 5b       	subi	r16, 0xB3	; 179
    13e6:	1f 4f       	sbci	r17, 0xFF	; 255
    13e8:	20 e0       	ldi	r18, 0x00	; 0
    13ea:	30 e0       	ldi	r19, 0x00	; 0
    13ec:	40 e8       	ldi	r20, 0x80	; 128
    13ee:	50 e4       	ldi	r21, 0x40	; 64
    13f0:	6d 85       	ldd	r22, Y+13	; 0x0d
    13f2:	7e 85       	ldd	r23, Y+14	; 0x0e
    13f4:	8f 85       	ldd	r24, Y+15	; 0x0f
    13f6:	98 89       	ldd	r25, Y+16	; 0x10
    13f8:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
    13fc:	dc 01       	movw	r26, r24
    13fe:	cb 01       	movw	r24, r22
    1400:	f8 01       	movw	r30, r16
    1402:	80 83       	st	Z, r24
    1404:	91 83       	std	Z+1, r25	; 0x01
    1406:	a2 83       	std	Z+2, r26	; 0x02
    1408:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    140a:	ce 01       	movw	r24, r28
    140c:	87 5b       	subi	r24, 0xB7	; 183
    140e:	9f 4f       	sbci	r25, 0xFF	; 255
    1410:	20 e0       	ldi	r18, 0x00	; 0
    1412:	30 e0       	ldi	r19, 0x00	; 0
    1414:	40 e8       	ldi	r20, 0x80	; 128
    1416:	5f e3       	ldi	r21, 0x3F	; 63
    1418:	fc 01       	movw	r30, r24
    141a:	60 81       	ld	r22, Z
    141c:	71 81       	ldd	r23, Z+1	; 0x01
    141e:	82 81       	ldd	r24, Z+2	; 0x02
    1420:	93 81       	ldd	r25, Z+3	; 0x03
    1422:	0e 94 00 1a 	call	0x3400	; 0x3400 <__cmpsf2>
    1426:	88 23       	and	r24, r24
    1428:	3c f4       	brge	.+14     	; 0x1438 <lcd_begin+0x6b2>
		__ticks = 1;
    142a:	ce 01       	movw	r24, r28
    142c:	8f 5a       	subi	r24, 0xAF	; 175
    142e:	9f 4f       	sbci	r25, 0xFF	; 255
    1430:	21 e0       	ldi	r18, 0x01	; 1
    1432:	fc 01       	movw	r30, r24
    1434:	20 83       	st	Z, r18
    1436:	2c c1       	rjmp	.+600    	; 0x1690 <lcd_begin+0x90a>
	else if (__tmp2 > 65535)
    1438:	ce 01       	movw	r24, r28
    143a:	83 5b       	subi	r24, 0xB3	; 179
    143c:	9f 4f       	sbci	r25, 0xFF	; 255
    143e:	20 e0       	ldi	r18, 0x00	; 0
    1440:	3f ef       	ldi	r19, 0xFF	; 255
    1442:	4f e7       	ldi	r20, 0x7F	; 127
    1444:	57 e4       	ldi	r21, 0x47	; 71
    1446:	fc 01       	movw	r30, r24
    1448:	60 81       	ld	r22, Z
    144a:	71 81       	ldd	r23, Z+1	; 0x01
    144c:	82 81       	ldd	r24, Z+2	; 0x02
    144e:	93 81       	ldd	r25, Z+3	; 0x03
    1450:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
    1454:	18 16       	cp	r1, r24
    1456:	0c f0       	brlt	.+2      	; 0x145a <lcd_begin+0x6d4>
    1458:	cd c0       	rjmp	.+410    	; 0x15f4 <lcd_begin+0x86e>
	{
		_delay_ms(__us / 1000.0);
    145a:	20 e0       	ldi	r18, 0x00	; 0
    145c:	30 e0       	ldi	r19, 0x00	; 0
    145e:	4a e7       	ldi	r20, 0x7A	; 122
    1460:	54 e4       	ldi	r21, 0x44	; 68
    1462:	6d 85       	ldd	r22, Y+13	; 0x0d
    1464:	7e 85       	ldd	r23, Y+14	; 0x0e
    1466:	8f 85       	ldd	r24, Y+15	; 0x0f
    1468:	98 89       	ldd	r25, Y+16	; 0x10
    146a:	0e 94 05 1a 	call	0x340a	; 0x340a <__divsf3>
    146e:	dc 01       	movw	r26, r24
    1470:	cb 01       	movw	r24, r22
    1472:	9e 01       	movw	r18, r28
    1474:	2e 5a       	subi	r18, 0xAE	; 174
    1476:	3f 4f       	sbci	r19, 0xFF	; 255
    1478:	f9 01       	movw	r30, r18
    147a:	80 83       	st	Z, r24
    147c:	91 83       	std	Z+1, r25	; 0x01
    147e:	a2 83       	std	Z+2, r26	; 0x02
    1480:	b3 83       	std	Z+3, r27	; 0x03

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    1482:	8e 01       	movw	r16, r28
    1484:	0a 5a       	subi	r16, 0xAA	; 170
    1486:	1f 4f       	sbci	r17, 0xFF	; 255
    1488:	ce 01       	movw	r24, r28
    148a:	8e 5a       	subi	r24, 0xAE	; 174
    148c:	9f 4f       	sbci	r25, 0xFF	; 255
    148e:	20 e0       	ldi	r18, 0x00	; 0
    1490:	30 e0       	ldi	r19, 0x00	; 0
    1492:	4a e7       	ldi	r20, 0x7A	; 122
    1494:	55 e4       	ldi	r21, 0x45	; 69
    1496:	fc 01       	movw	r30, r24
    1498:	60 81       	ld	r22, Z
    149a:	71 81       	ldd	r23, Z+1	; 0x01
    149c:	82 81       	ldd	r24, Z+2	; 0x02
    149e:	93 81       	ldd	r25, Z+3	; 0x03
    14a0:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
    14a4:	dc 01       	movw	r26, r24
    14a6:	cb 01       	movw	r24, r22
    14a8:	f8 01       	movw	r30, r16
    14aa:	80 83       	st	Z, r24
    14ac:	91 83       	std	Z+1, r25	; 0x01
    14ae:	a2 83       	std	Z+2, r26	; 0x02
    14b0:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    14b2:	ce 01       	movw	r24, r28
    14b4:	8a 5a       	subi	r24, 0xAA	; 170
    14b6:	9f 4f       	sbci	r25, 0xFF	; 255
    14b8:	20 e0       	ldi	r18, 0x00	; 0
    14ba:	30 e0       	ldi	r19, 0x00	; 0
    14bc:	40 e8       	ldi	r20, 0x80	; 128
    14be:	5f e3       	ldi	r21, 0x3F	; 63
    14c0:	fc 01       	movw	r30, r24
    14c2:	60 81       	ld	r22, Z
    14c4:	71 81       	ldd	r23, Z+1	; 0x01
    14c6:	82 81       	ldd	r24, Z+2	; 0x02
    14c8:	93 81       	ldd	r25, Z+3	; 0x03
    14ca:	0e 94 00 1a 	call	0x3400	; 0x3400 <__cmpsf2>
    14ce:	88 23       	and	r24, r24
    14d0:	4c f4       	brge	.+18     	; 0x14e4 <lcd_begin+0x75e>
		__ticks = 1;
    14d2:	ce 01       	movw	r24, r28
    14d4:	86 5a       	subi	r24, 0xA6	; 166
    14d6:	9f 4f       	sbci	r25, 0xFF	; 255
    14d8:	21 e0       	ldi	r18, 0x01	; 1
    14da:	30 e0       	ldi	r19, 0x00	; 0
    14dc:	fc 01       	movw	r30, r24
    14de:	31 83       	std	Z+1, r19	; 0x01
    14e0:	20 83       	st	Z, r18
    14e2:	6d c0       	rjmp	.+218    	; 0x15be <lcd_begin+0x838>
	else if (__tmp > 65535)
    14e4:	ce 01       	movw	r24, r28
    14e6:	8a 5a       	subi	r24, 0xAA	; 170
    14e8:	9f 4f       	sbci	r25, 0xFF	; 255
    14ea:	20 e0       	ldi	r18, 0x00	; 0
    14ec:	3f ef       	ldi	r19, 0xFF	; 255
    14ee:	4f e7       	ldi	r20, 0x7F	; 127
    14f0:	57 e4       	ldi	r21, 0x47	; 71
    14f2:	fc 01       	movw	r30, r24
    14f4:	60 81       	ld	r22, Z
    14f6:	71 81       	ldd	r23, Z+1	; 0x01
    14f8:	82 81       	ldd	r24, Z+2	; 0x02
    14fa:	93 81       	ldd	r25, Z+3	; 0x03
    14fc:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
    1500:	18 16       	cp	r1, r24
    1502:	0c f0       	brlt	.+2      	; 0x1506 <lcd_begin+0x780>
    1504:	4a c0       	rjmp	.+148    	; 0x159a <lcd_begin+0x814>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1506:	ce 01       	movw	r24, r28
    1508:	8e 5a       	subi	r24, 0xAE	; 174
    150a:	9f 4f       	sbci	r25, 0xFF	; 255
    150c:	20 e0       	ldi	r18, 0x00	; 0
    150e:	30 e0       	ldi	r19, 0x00	; 0
    1510:	40 e2       	ldi	r20, 0x20	; 32
    1512:	51 e4       	ldi	r21, 0x41	; 65
    1514:	fc 01       	movw	r30, r24
    1516:	60 81       	ld	r22, Z
    1518:	71 81       	ldd	r23, Z+1	; 0x01
    151a:	82 81       	ldd	r24, Z+2	; 0x02
    151c:	93 81       	ldd	r25, Z+3	; 0x03
    151e:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
    1522:	dc 01       	movw	r26, r24
    1524:	cb 01       	movw	r24, r22
    1526:	8e 01       	movw	r16, r28
    1528:	06 5a       	subi	r16, 0xA6	; 166
    152a:	1f 4f       	sbci	r17, 0xFF	; 255
    152c:	bc 01       	movw	r22, r24
    152e:	cd 01       	movw	r24, r26
    1530:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    1534:	dc 01       	movw	r26, r24
    1536:	cb 01       	movw	r24, r22
    1538:	f8 01       	movw	r30, r16
    153a:	91 83       	std	Z+1, r25	; 0x01
    153c:	80 83       	st	Z, r24
    153e:	24 c0       	rjmp	.+72     	; 0x1588 <lcd_begin+0x802>
    1540:	ce 01       	movw	r24, r28
    1542:	84 5a       	subi	r24, 0xA4	; 164
    1544:	9f 4f       	sbci	r25, 0xFF	; 255
    1546:	20 e9       	ldi	r18, 0x90	; 144
    1548:	31 e0       	ldi	r19, 0x01	; 1
    154a:	fc 01       	movw	r30, r24
    154c:	31 83       	std	Z+1, r19	; 0x01
    154e:	20 83       	st	Z, r18
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1550:	ce 01       	movw	r24, r28
    1552:	84 5a       	subi	r24, 0xA4	; 164
    1554:	9f 4f       	sbci	r25, 0xFF	; 255
    1556:	fc 01       	movw	r30, r24
    1558:	80 81       	ld	r24, Z
    155a:	91 81       	ldd	r25, Z+1	; 0x01
    155c:	01 97       	sbiw	r24, 0x01	; 1
    155e:	f1 f7       	brne	.-4      	; 0x155c <lcd_begin+0x7d6>
    1560:	9e 01       	movw	r18, r28
    1562:	24 5a       	subi	r18, 0xA4	; 164
    1564:	3f 4f       	sbci	r19, 0xFF	; 255
    1566:	f9 01       	movw	r30, r18
    1568:	91 83       	std	Z+1, r25	; 0x01
    156a:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    156c:	ce 01       	movw	r24, r28
    156e:	86 5a       	subi	r24, 0xA6	; 166
    1570:	9f 4f       	sbci	r25, 0xFF	; 255
    1572:	9e 01       	movw	r18, r28
    1574:	26 5a       	subi	r18, 0xA6	; 166
    1576:	3f 4f       	sbci	r19, 0xFF	; 255
    1578:	f9 01       	movw	r30, r18
    157a:	20 81       	ld	r18, Z
    157c:	31 81       	ldd	r19, Z+1	; 0x01
    157e:	21 50       	subi	r18, 0x01	; 1
    1580:	31 09       	sbc	r19, r1
    1582:	fc 01       	movw	r30, r24
    1584:	31 83       	std	Z+1, r19	; 0x01
    1586:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1588:	ce 01       	movw	r24, r28
    158a:	86 5a       	subi	r24, 0xA6	; 166
    158c:	9f 4f       	sbci	r25, 0xFF	; 255
    158e:	fc 01       	movw	r30, r24
    1590:	80 81       	ld	r24, Z
    1592:	91 81       	ldd	r25, Z+1	; 0x01
    1594:	89 2b       	or	r24, r25
    1596:	a1 f6       	brne	.-88     	; 0x1540 <lcd_begin+0x7ba>
    1598:	7b c0       	rjmp	.+246    	; 0x1690 <lcd_begin+0x90a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    159a:	8e 01       	movw	r16, r28
    159c:	06 5a       	subi	r16, 0xA6	; 166
    159e:	1f 4f       	sbci	r17, 0xFF	; 255
    15a0:	ce 01       	movw	r24, r28
    15a2:	8a 5a       	subi	r24, 0xAA	; 170
    15a4:	9f 4f       	sbci	r25, 0xFF	; 255
    15a6:	fc 01       	movw	r30, r24
    15a8:	60 81       	ld	r22, Z
    15aa:	71 81       	ldd	r23, Z+1	; 0x01
    15ac:	82 81       	ldd	r24, Z+2	; 0x02
    15ae:	93 81       	ldd	r25, Z+3	; 0x03
    15b0:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    15b4:	dc 01       	movw	r26, r24
    15b6:	cb 01       	movw	r24, r22
    15b8:	f8 01       	movw	r30, r16
    15ba:	91 83       	std	Z+1, r25	; 0x01
    15bc:	80 83       	st	Z, r24
    15be:	ce 01       	movw	r24, r28
    15c0:	82 5a       	subi	r24, 0xA2	; 162
    15c2:	9f 4f       	sbci	r25, 0xFF	; 255
    15c4:	9e 01       	movw	r18, r28
    15c6:	26 5a       	subi	r18, 0xA6	; 166
    15c8:	3f 4f       	sbci	r19, 0xFF	; 255
    15ca:	f9 01       	movw	r30, r18
    15cc:	20 81       	ld	r18, Z
    15ce:	31 81       	ldd	r19, Z+1	; 0x01
    15d0:	fc 01       	movw	r30, r24
    15d2:	31 83       	std	Z+1, r19	; 0x01
    15d4:	20 83       	st	Z, r18
    15d6:	ce 01       	movw	r24, r28
    15d8:	82 5a       	subi	r24, 0xA2	; 162
    15da:	9f 4f       	sbci	r25, 0xFF	; 255
    15dc:	fc 01       	movw	r30, r24
    15de:	80 81       	ld	r24, Z
    15e0:	91 81       	ldd	r25, Z+1	; 0x01
    15e2:	01 97       	sbiw	r24, 0x01	; 1
    15e4:	f1 f7       	brne	.-4      	; 0x15e2 <lcd_begin+0x85c>
    15e6:	9e 01       	movw	r18, r28
    15e8:	22 5a       	subi	r18, 0xA2	; 162
    15ea:	3f 4f       	sbci	r19, 0xFF	; 255
    15ec:	f9 01       	movw	r30, r18
    15ee:	91 83       	std	Z+1, r25	; 0x01
    15f0:	80 83       	st	Z, r24
    15f2:	4e c0       	rjmp	.+156    	; 0x1690 <lcd_begin+0x90a>
		__ticks = 1;
	else if (__tmp2 > 65535)
	{
		_delay_ms(__us / 1000.0);
	}
	else if (__tmp > 255)
    15f4:	ce 01       	movw	r24, r28
    15f6:	87 5b       	subi	r24, 0xB7	; 183
    15f8:	9f 4f       	sbci	r25, 0xFF	; 255
    15fa:	20 e0       	ldi	r18, 0x00	; 0
    15fc:	30 e0       	ldi	r19, 0x00	; 0
    15fe:	4f e7       	ldi	r20, 0x7F	; 127
    1600:	53 e4       	ldi	r21, 0x43	; 67
    1602:	fc 01       	movw	r30, r24
    1604:	60 81       	ld	r22, Z
    1606:	71 81       	ldd	r23, Z+1	; 0x01
    1608:	82 81       	ldd	r24, Z+2	; 0x02
    160a:	93 81       	ldd	r25, Z+3	; 0x03
    160c:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
    1610:	18 16       	cp	r1, r24
    1612:	6c f5       	brge	.+90     	; 0x166e <lcd_begin+0x8e8>
	{
		uint16_t __ticks=(uint16_t)__tmp2;
    1614:	8e 01       	movw	r16, r28
    1616:	00 5a       	subi	r16, 0xA0	; 160
    1618:	1f 4f       	sbci	r17, 0xFF	; 255
    161a:	ce 01       	movw	r24, r28
    161c:	83 5b       	subi	r24, 0xB3	; 179
    161e:	9f 4f       	sbci	r25, 0xFF	; 255
    1620:	fc 01       	movw	r30, r24
    1622:	60 81       	ld	r22, Z
    1624:	71 81       	ldd	r23, Z+1	; 0x01
    1626:	82 81       	ldd	r24, Z+2	; 0x02
    1628:	93 81       	ldd	r25, Z+3	; 0x03
    162a:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    162e:	dc 01       	movw	r26, r24
    1630:	cb 01       	movw	r24, r22
    1632:	f8 01       	movw	r30, r16
    1634:	91 83       	std	Z+1, r25	; 0x01
    1636:	80 83       	st	Z, r24
    1638:	ce 01       	movw	r24, r28
    163a:	8e 59       	subi	r24, 0x9E	; 158
    163c:	9f 4f       	sbci	r25, 0xFF	; 255
    163e:	9e 01       	movw	r18, r28
    1640:	20 5a       	subi	r18, 0xA0	; 160
    1642:	3f 4f       	sbci	r19, 0xFF	; 255
    1644:	f9 01       	movw	r30, r18
    1646:	20 81       	ld	r18, Z
    1648:	31 81       	ldd	r19, Z+1	; 0x01
    164a:	fc 01       	movw	r30, r24
    164c:	31 83       	std	Z+1, r19	; 0x01
    164e:	20 83       	st	Z, r18
    1650:	ce 01       	movw	r24, r28
    1652:	8e 59       	subi	r24, 0x9E	; 158
    1654:	9f 4f       	sbci	r25, 0xFF	; 255
    1656:	fc 01       	movw	r30, r24
    1658:	80 81       	ld	r24, Z
    165a:	91 81       	ldd	r25, Z+1	; 0x01
    165c:	01 97       	sbiw	r24, 0x01	; 1
    165e:	f1 f7       	brne	.-4      	; 0x165c <lcd_begin+0x8d6>
    1660:	9e 01       	movw	r18, r28
    1662:	2e 59       	subi	r18, 0x9E	; 158
    1664:	3f 4f       	sbci	r19, 0xFF	; 255
    1666:	f9 01       	movw	r30, r18
    1668:	91 83       	std	Z+1, r25	; 0x01
    166a:	80 83       	st	Z, r24
    166c:	28 c0       	rjmp	.+80     	; 0x16be <lcd_begin+0x938>
		_delay_loop_2(__ticks);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    166e:	8e 01       	movw	r16, r28
    1670:	0f 5a       	subi	r16, 0xAF	; 175
    1672:	1f 4f       	sbci	r17, 0xFF	; 255
    1674:	ce 01       	movw	r24, r28
    1676:	87 5b       	subi	r24, 0xB7	; 183
    1678:	9f 4f       	sbci	r25, 0xFF	; 255
    167a:	fc 01       	movw	r30, r24
    167c:	60 81       	ld	r22, Z
    167e:	71 81       	ldd	r23, Z+1	; 0x01
    1680:	82 81       	ldd	r24, Z+2	; 0x02
    1682:	93 81       	ldd	r25, Z+3	; 0x03
    1684:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    1688:	dc 01       	movw	r26, r24
    168a:	cb 01       	movw	r24, r22
    168c:	f8 01       	movw	r30, r16
    168e:	80 83       	st	Z, r24
    1690:	ce 01       	movw	r24, r28
    1692:	8c 59       	subi	r24, 0x9C	; 156
    1694:	9f 4f       	sbci	r25, 0xFF	; 255
    1696:	9e 01       	movw	r18, r28
    1698:	2f 5a       	subi	r18, 0xAF	; 175
    169a:	3f 4f       	sbci	r19, 0xFF	; 255
    169c:	f9 01       	movw	r30, r18
    169e:	20 81       	ld	r18, Z
    16a0:	fc 01       	movw	r30, r24
    16a2:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    16a4:	ce 01       	movw	r24, r28
    16a6:	8c 59       	subi	r24, 0x9C	; 156
    16a8:	9f 4f       	sbci	r25, 0xFF	; 255
    16aa:	fc 01       	movw	r30, r24
    16ac:	80 81       	ld	r24, Z
    16ae:	28 2f       	mov	r18, r24
    16b0:	2a 95       	dec	r18
    16b2:	f1 f7       	brne	.-4      	; 0x16b0 <lcd_begin+0x92a>
    16b4:	ce 01       	movw	r24, r28
    16b6:	8c 59       	subi	r24, 0x9C	; 156
    16b8:	9f 4f       	sbci	r25, 0xFF	; 255
    16ba:	fc 01       	movw	r30, r24
    16bc:	20 83       	st	Z, r18
	_delay_us(160);
	lcd_write_cmd_byte(0x02); //to initialize LCD in 4-bit mode.
    16be:	82 e0       	ldi	r24, 0x02	; 2
    16c0:	0e 94 51 05 	call	0xaa2	; 0xaa2 <lcd_write_cmd_byte>
    16c4:	80 e0       	ldi	r24, 0x00	; 0
    16c6:	90 e0       	ldi	r25, 0x00	; 0
    16c8:	a0 e2       	ldi	r26, 0x20	; 32
    16ca:	b1 e4       	ldi	r27, 0x41	; 65
    16cc:	89 8b       	std	Y+17, r24	; 0x11
    16ce:	9a 8b       	std	Y+18, r25	; 0x12
    16d0:	ab 8b       	std	Y+19, r26	; 0x13
    16d2:	bc 8b       	std	Y+20, r27	; 0x14

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    16d4:	8e 01       	movw	r16, r28
    16d6:	01 5c       	subi	r16, 0xC1	; 193
    16d8:	1f 4f       	sbci	r17, 0xFF	; 255
    16da:	20 e0       	ldi	r18, 0x00	; 0
    16dc:	30 e0       	ldi	r19, 0x00	; 0
    16de:	4a e7       	ldi	r20, 0x7A	; 122
    16e0:	55 e4       	ldi	r21, 0x45	; 69
    16e2:	69 89       	ldd	r22, Y+17	; 0x11
    16e4:	7a 89       	ldd	r23, Y+18	; 0x12
    16e6:	8b 89       	ldd	r24, Y+19	; 0x13
    16e8:	9c 89       	ldd	r25, Y+20	; 0x14
    16ea:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
    16ee:	dc 01       	movw	r26, r24
    16f0:	cb 01       	movw	r24, r22
    16f2:	f8 01       	movw	r30, r16
    16f4:	80 83       	st	Z, r24
    16f6:	91 83       	std	Z+1, r25	; 0x01
    16f8:	a2 83       	std	Z+2, r26	; 0x02
    16fa:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    16fc:	ce 01       	movw	r24, r28
    16fe:	cf 96       	adiw	r24, 0x3f	; 63
    1700:	20 e0       	ldi	r18, 0x00	; 0
    1702:	30 e0       	ldi	r19, 0x00	; 0
    1704:	40 e8       	ldi	r20, 0x80	; 128
    1706:	5f e3       	ldi	r21, 0x3F	; 63
    1708:	fc 01       	movw	r30, r24
    170a:	60 81       	ld	r22, Z
    170c:	71 81       	ldd	r23, Z+1	; 0x01
    170e:	82 81       	ldd	r24, Z+2	; 0x02
    1710:	93 81       	ldd	r25, Z+3	; 0x03
    1712:	0e 94 00 1a 	call	0x3400	; 0x3400 <__cmpsf2>
    1716:	88 23       	and	r24, r24
    1718:	4c f4       	brge	.+18     	; 0x172c <lcd_begin+0x9a6>
		__ticks = 1;
    171a:	ce 01       	movw	r24, r28
    171c:	8d 5b       	subi	r24, 0xBD	; 189
    171e:	9f 4f       	sbci	r25, 0xFF	; 255
    1720:	21 e0       	ldi	r18, 0x01	; 1
    1722:	30 e0       	ldi	r19, 0x00	; 0
    1724:	fc 01       	movw	r30, r24
    1726:	31 83       	std	Z+1, r19	; 0x01
    1728:	20 83       	st	Z, r18
    172a:	67 c0       	rjmp	.+206    	; 0x17fa <lcd_begin+0xa74>
	else if (__tmp > 65535)
    172c:	ce 01       	movw	r24, r28
    172e:	cf 96       	adiw	r24, 0x3f	; 63
    1730:	20 e0       	ldi	r18, 0x00	; 0
    1732:	3f ef       	ldi	r19, 0xFF	; 255
    1734:	4f e7       	ldi	r20, 0x7F	; 127
    1736:	57 e4       	ldi	r21, 0x47	; 71
    1738:	fc 01       	movw	r30, r24
    173a:	60 81       	ld	r22, Z
    173c:	71 81       	ldd	r23, Z+1	; 0x01
    173e:	82 81       	ldd	r24, Z+2	; 0x02
    1740:	93 81       	ldd	r25, Z+3	; 0x03
    1742:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
    1746:	18 16       	cp	r1, r24
    1748:	0c f0       	brlt	.+2      	; 0x174c <lcd_begin+0x9c6>
    174a:	46 c0       	rjmp	.+140    	; 0x17d8 <lcd_begin+0xa52>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    174c:	20 e0       	ldi	r18, 0x00	; 0
    174e:	30 e0       	ldi	r19, 0x00	; 0
    1750:	40 e2       	ldi	r20, 0x20	; 32
    1752:	51 e4       	ldi	r21, 0x41	; 65
    1754:	69 89       	ldd	r22, Y+17	; 0x11
    1756:	7a 89       	ldd	r23, Y+18	; 0x12
    1758:	8b 89       	ldd	r24, Y+19	; 0x13
    175a:	9c 89       	ldd	r25, Y+20	; 0x14
    175c:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
    1760:	dc 01       	movw	r26, r24
    1762:	cb 01       	movw	r24, r22
    1764:	8e 01       	movw	r16, r28
    1766:	0d 5b       	subi	r16, 0xBD	; 189
    1768:	1f 4f       	sbci	r17, 0xFF	; 255
    176a:	bc 01       	movw	r22, r24
    176c:	cd 01       	movw	r24, r26
    176e:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    1772:	dc 01       	movw	r26, r24
    1774:	cb 01       	movw	r24, r22
    1776:	f8 01       	movw	r30, r16
    1778:	91 83       	std	Z+1, r25	; 0x01
    177a:	80 83       	st	Z, r24
    177c:	24 c0       	rjmp	.+72     	; 0x17c6 <lcd_begin+0xa40>
    177e:	ce 01       	movw	r24, r28
    1780:	8b 5b       	subi	r24, 0xBB	; 187
    1782:	9f 4f       	sbci	r25, 0xFF	; 255
    1784:	20 e9       	ldi	r18, 0x90	; 144
    1786:	31 e0       	ldi	r19, 0x01	; 1
    1788:	fc 01       	movw	r30, r24
    178a:	31 83       	std	Z+1, r19	; 0x01
    178c:	20 83       	st	Z, r18
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    178e:	ce 01       	movw	r24, r28
    1790:	8b 5b       	subi	r24, 0xBB	; 187
    1792:	9f 4f       	sbci	r25, 0xFF	; 255
    1794:	fc 01       	movw	r30, r24
    1796:	80 81       	ld	r24, Z
    1798:	91 81       	ldd	r25, Z+1	; 0x01
    179a:	01 97       	sbiw	r24, 0x01	; 1
    179c:	f1 f7       	brne	.-4      	; 0x179a <lcd_begin+0xa14>
    179e:	9e 01       	movw	r18, r28
    17a0:	2b 5b       	subi	r18, 0xBB	; 187
    17a2:	3f 4f       	sbci	r19, 0xFF	; 255
    17a4:	f9 01       	movw	r30, r18
    17a6:	91 83       	std	Z+1, r25	; 0x01
    17a8:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    17aa:	ce 01       	movw	r24, r28
    17ac:	8d 5b       	subi	r24, 0xBD	; 189
    17ae:	9f 4f       	sbci	r25, 0xFF	; 255
    17b0:	9e 01       	movw	r18, r28
    17b2:	2d 5b       	subi	r18, 0xBD	; 189
    17b4:	3f 4f       	sbci	r19, 0xFF	; 255
    17b6:	f9 01       	movw	r30, r18
    17b8:	20 81       	ld	r18, Z
    17ba:	31 81       	ldd	r19, Z+1	; 0x01
    17bc:	21 50       	subi	r18, 0x01	; 1
    17be:	31 09       	sbc	r19, r1
    17c0:	fc 01       	movw	r30, r24
    17c2:	31 83       	std	Z+1, r19	; 0x01
    17c4:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    17c6:	ce 01       	movw	r24, r28
    17c8:	8d 5b       	subi	r24, 0xBD	; 189
    17ca:	9f 4f       	sbci	r25, 0xFF	; 255
    17cc:	fc 01       	movw	r30, r24
    17ce:	80 81       	ld	r24, Z
    17d0:	91 81       	ldd	r25, Z+1	; 0x01
    17d2:	89 2b       	or	r24, r25
    17d4:	a1 f6       	brne	.-88     	; 0x177e <lcd_begin+0x9f8>
    17d6:	2b c0       	rjmp	.+86     	; 0x182e <lcd_begin+0xaa8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    17d8:	8e 01       	movw	r16, r28
    17da:	0d 5b       	subi	r16, 0xBD	; 189
    17dc:	1f 4f       	sbci	r17, 0xFF	; 255
    17de:	ce 01       	movw	r24, r28
    17e0:	cf 96       	adiw	r24, 0x3f	; 63
    17e2:	fc 01       	movw	r30, r24
    17e4:	60 81       	ld	r22, Z
    17e6:	71 81       	ldd	r23, Z+1	; 0x01
    17e8:	82 81       	ldd	r24, Z+2	; 0x02
    17ea:	93 81       	ldd	r25, Z+3	; 0x03
    17ec:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    17f0:	dc 01       	movw	r26, r24
    17f2:	cb 01       	movw	r24, r22
    17f4:	f8 01       	movw	r30, r16
    17f6:	91 83       	std	Z+1, r25	; 0x01
    17f8:	80 83       	st	Z, r24
    17fa:	ce 01       	movw	r24, r28
    17fc:	89 5b       	subi	r24, 0xB9	; 185
    17fe:	9f 4f       	sbci	r25, 0xFF	; 255
    1800:	9e 01       	movw	r18, r28
    1802:	2d 5b       	subi	r18, 0xBD	; 189
    1804:	3f 4f       	sbci	r19, 0xFF	; 255
    1806:	f9 01       	movw	r30, r18
    1808:	20 81       	ld	r18, Z
    180a:	31 81       	ldd	r19, Z+1	; 0x01
    180c:	fc 01       	movw	r30, r24
    180e:	31 83       	std	Z+1, r19	; 0x01
    1810:	20 83       	st	Z, r18
    1812:	ce 01       	movw	r24, r28
    1814:	89 5b       	subi	r24, 0xB9	; 185
    1816:	9f 4f       	sbci	r25, 0xFF	; 255
    1818:	fc 01       	movw	r30, r24
    181a:	80 81       	ld	r24, Z
    181c:	91 81       	ldd	r25, Z+1	; 0x01
    181e:	01 97       	sbiw	r24, 0x01	; 1
    1820:	f1 f7       	brne	.-4      	; 0x181e <lcd_begin+0xa98>
    1822:	9e 01       	movw	r18, r28
    1824:	29 5b       	subi	r18, 0xB9	; 185
    1826:	3f 4f       	sbci	r19, 0xFF	; 255
    1828:	f9 01       	movw	r30, r18
    182a:	91 83       	std	Z+1, r25	; 0x01
    182c:	80 83       	st	Z, r24
	_delay_ms(10);
	lcd_write_cmd_byte(0x28); //to initialize LCD in 2 lines, 5X7 dots and 4bit mode.
    182e:	88 e2       	ldi	r24, 0x28	; 40
    1830:	0e 94 51 05 	call	0xaa2	; 0xaa2 <lcd_write_cmd_byte>
    1834:	80 e0       	ldi	r24, 0x00	; 0
    1836:	90 e0       	ldi	r25, 0x00	; 0
    1838:	a0 e2       	ldi	r26, 0x20	; 32
    183a:	b1 e4       	ldi	r27, 0x41	; 65
    183c:	8d 8b       	std	Y+21, r24	; 0x15
    183e:	9e 8b       	std	Y+22, r25	; 0x16
    1840:	af 8b       	std	Y+23, r26	; 0x17
    1842:	b8 8f       	std	Y+24, r27	; 0x18

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    1844:	20 e0       	ldi	r18, 0x00	; 0
    1846:	30 e0       	ldi	r19, 0x00	; 0
    1848:	4a e7       	ldi	r20, 0x7A	; 122
    184a:	55 e4       	ldi	r21, 0x45	; 69
    184c:	6d 89       	ldd	r22, Y+21	; 0x15
    184e:	7e 89       	ldd	r23, Y+22	; 0x16
    1850:	8f 89       	ldd	r24, Y+23	; 0x17
    1852:	98 8d       	ldd	r25, Y+24	; 0x18
    1854:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
    1858:	dc 01       	movw	r26, r24
    185a:	cb 01       	movw	r24, r22
    185c:	8d ab       	std	Y+53, r24	; 0x35
    185e:	9e ab       	std	Y+54, r25	; 0x36
    1860:	af ab       	std	Y+55, r26	; 0x37
    1862:	b8 af       	std	Y+56, r27	; 0x38
	if (__tmp < 1.0)
    1864:	20 e0       	ldi	r18, 0x00	; 0
    1866:	30 e0       	ldi	r19, 0x00	; 0
    1868:	40 e8       	ldi	r20, 0x80	; 128
    186a:	5f e3       	ldi	r21, 0x3F	; 63
    186c:	6d a9       	ldd	r22, Y+53	; 0x35
    186e:	7e a9       	ldd	r23, Y+54	; 0x36
    1870:	8f a9       	ldd	r24, Y+55	; 0x37
    1872:	98 ad       	ldd	r25, Y+56	; 0x38
    1874:	0e 94 00 1a 	call	0x3400	; 0x3400 <__cmpsf2>
    1878:	88 23       	and	r24, r24
    187a:	2c f4       	brge	.+10     	; 0x1886 <lcd_begin+0xb00>
		__ticks = 1;
    187c:	81 e0       	ldi	r24, 0x01	; 1
    187e:	90 e0       	ldi	r25, 0x00	; 0
    1880:	9a af       	std	Y+58, r25	; 0x3a
    1882:	89 af       	std	Y+57, r24	; 0x39
    1884:	3f c0       	rjmp	.+126    	; 0x1904 <lcd_begin+0xb7e>
	else if (__tmp > 65535)
    1886:	20 e0       	ldi	r18, 0x00	; 0
    1888:	3f ef       	ldi	r19, 0xFF	; 255
    188a:	4f e7       	ldi	r20, 0x7F	; 127
    188c:	57 e4       	ldi	r21, 0x47	; 71
    188e:	6d a9       	ldd	r22, Y+53	; 0x35
    1890:	7e a9       	ldd	r23, Y+54	; 0x36
    1892:	8f a9       	ldd	r24, Y+55	; 0x37
    1894:	98 ad       	ldd	r25, Y+56	; 0x38
    1896:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
    189a:	18 16       	cp	r1, r24
    189c:	4c f5       	brge	.+82     	; 0x18f0 <lcd_begin+0xb6a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    189e:	20 e0       	ldi	r18, 0x00	; 0
    18a0:	30 e0       	ldi	r19, 0x00	; 0
    18a2:	40 e2       	ldi	r20, 0x20	; 32
    18a4:	51 e4       	ldi	r21, 0x41	; 65
    18a6:	6d 89       	ldd	r22, Y+21	; 0x15
    18a8:	7e 89       	ldd	r23, Y+22	; 0x16
    18aa:	8f 89       	ldd	r24, Y+23	; 0x17
    18ac:	98 8d       	ldd	r25, Y+24	; 0x18
    18ae:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
    18b2:	dc 01       	movw	r26, r24
    18b4:	cb 01       	movw	r24, r22
    18b6:	bc 01       	movw	r22, r24
    18b8:	cd 01       	movw	r24, r26
    18ba:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    18be:	dc 01       	movw	r26, r24
    18c0:	cb 01       	movw	r24, r22
    18c2:	9a af       	std	Y+58, r25	; 0x3a
    18c4:	89 af       	std	Y+57, r24	; 0x39
    18c6:	0f c0       	rjmp	.+30     	; 0x18e6 <lcd_begin+0xb60>
    18c8:	80 e9       	ldi	r24, 0x90	; 144
    18ca:	91 e0       	ldi	r25, 0x01	; 1
    18cc:	9c af       	std	Y+60, r25	; 0x3c
    18ce:	8b af       	std	Y+59, r24	; 0x3b
    18d0:	8b ad       	ldd	r24, Y+59	; 0x3b
    18d2:	9c ad       	ldd	r25, Y+60	; 0x3c
    18d4:	01 97       	sbiw	r24, 0x01	; 1
    18d6:	f1 f7       	brne	.-4      	; 0x18d4 <lcd_begin+0xb4e>
    18d8:	9c af       	std	Y+60, r25	; 0x3c
    18da:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    18dc:	89 ad       	ldd	r24, Y+57	; 0x39
    18de:	9a ad       	ldd	r25, Y+58	; 0x3a
    18e0:	01 97       	sbiw	r24, 0x01	; 1
    18e2:	9a af       	std	Y+58, r25	; 0x3a
    18e4:	89 af       	std	Y+57, r24	; 0x39
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    18e6:	89 ad       	ldd	r24, Y+57	; 0x39
    18e8:	9a ad       	ldd	r25, Y+58	; 0x3a
    18ea:	89 2b       	or	r24, r25
    18ec:	69 f7       	brne	.-38     	; 0x18c8 <lcd_begin+0xb42>
    18ee:	14 c0       	rjmp	.+40     	; 0x1918 <lcd_begin+0xb92>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    18f0:	6d a9       	ldd	r22, Y+53	; 0x35
    18f2:	7e a9       	ldd	r23, Y+54	; 0x36
    18f4:	8f a9       	ldd	r24, Y+55	; 0x37
    18f6:	98 ad       	ldd	r25, Y+56	; 0x38
    18f8:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    18fc:	dc 01       	movw	r26, r24
    18fe:	cb 01       	movw	r24, r22
    1900:	9a af       	std	Y+58, r25	; 0x3a
    1902:	89 af       	std	Y+57, r24	; 0x39
    1904:	89 ad       	ldd	r24, Y+57	; 0x39
    1906:	9a ad       	ldd	r25, Y+58	; 0x3a
    1908:	9e af       	std	Y+62, r25	; 0x3e
    190a:	8d af       	std	Y+61, r24	; 0x3d
    190c:	8d ad       	ldd	r24, Y+61	; 0x3d
    190e:	9e ad       	ldd	r25, Y+62	; 0x3e
    1910:	01 97       	sbiw	r24, 0x01	; 1
    1912:	f1 f7       	brne	.-4      	; 0x1910 <lcd_begin+0xb8a>
    1914:	9e af       	std	Y+62, r25	; 0x3e
    1916:	8d af       	std	Y+61, r24	; 0x3d
	_delay_ms(10);
	lcd_write_cmd_byte(0x0C); //Display on, cursor off
    1918:	8c e0       	ldi	r24, 0x0C	; 12
    191a:	0e 94 51 05 	call	0xaa2	; 0xaa2 <lcd_write_cmd_byte>
    191e:	80 e0       	ldi	r24, 0x00	; 0
    1920:	90 e0       	ldi	r25, 0x00	; 0
    1922:	a0 e2       	ldi	r26, 0x20	; 32
    1924:	b1 e4       	ldi	r27, 0x41	; 65
    1926:	89 8f       	std	Y+25, r24	; 0x19
    1928:	9a 8f       	std	Y+26, r25	; 0x1a
    192a:	ab 8f       	std	Y+27, r26	; 0x1b
    192c:	bc 8f       	std	Y+28, r27	; 0x1c

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    192e:	20 e0       	ldi	r18, 0x00	; 0
    1930:	30 e0       	ldi	r19, 0x00	; 0
    1932:	4a e7       	ldi	r20, 0x7A	; 122
    1934:	55 e4       	ldi	r21, 0x45	; 69
    1936:	69 8d       	ldd	r22, Y+25	; 0x19
    1938:	7a 8d       	ldd	r23, Y+26	; 0x1a
    193a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    193c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    193e:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
    1942:	dc 01       	movw	r26, r24
    1944:	cb 01       	movw	r24, r22
    1946:	8b a7       	std	Y+43, r24	; 0x2b
    1948:	9c a7       	std	Y+44, r25	; 0x2c
    194a:	ad a7       	std	Y+45, r26	; 0x2d
    194c:	be a7       	std	Y+46, r27	; 0x2e
	if (__tmp < 1.0)
    194e:	20 e0       	ldi	r18, 0x00	; 0
    1950:	30 e0       	ldi	r19, 0x00	; 0
    1952:	40 e8       	ldi	r20, 0x80	; 128
    1954:	5f e3       	ldi	r21, 0x3F	; 63
    1956:	6b a5       	ldd	r22, Y+43	; 0x2b
    1958:	7c a5       	ldd	r23, Y+44	; 0x2c
    195a:	8d a5       	ldd	r24, Y+45	; 0x2d
    195c:	9e a5       	ldd	r25, Y+46	; 0x2e
    195e:	0e 94 00 1a 	call	0x3400	; 0x3400 <__cmpsf2>
    1962:	88 23       	and	r24, r24
    1964:	2c f4       	brge	.+10     	; 0x1970 <lcd_begin+0xbea>
		__ticks = 1;
    1966:	81 e0       	ldi	r24, 0x01	; 1
    1968:	90 e0       	ldi	r25, 0x00	; 0
    196a:	98 ab       	std	Y+48, r25	; 0x30
    196c:	8f a7       	std	Y+47, r24	; 0x2f
    196e:	3f c0       	rjmp	.+126    	; 0x19ee <lcd_begin+0xc68>
	else if (__tmp > 65535)
    1970:	20 e0       	ldi	r18, 0x00	; 0
    1972:	3f ef       	ldi	r19, 0xFF	; 255
    1974:	4f e7       	ldi	r20, 0x7F	; 127
    1976:	57 e4       	ldi	r21, 0x47	; 71
    1978:	6b a5       	ldd	r22, Y+43	; 0x2b
    197a:	7c a5       	ldd	r23, Y+44	; 0x2c
    197c:	8d a5       	ldd	r24, Y+45	; 0x2d
    197e:	9e a5       	ldd	r25, Y+46	; 0x2e
    1980:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
    1984:	18 16       	cp	r1, r24
    1986:	4c f5       	brge	.+82     	; 0x19da <lcd_begin+0xc54>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1988:	20 e0       	ldi	r18, 0x00	; 0
    198a:	30 e0       	ldi	r19, 0x00	; 0
    198c:	40 e2       	ldi	r20, 0x20	; 32
    198e:	51 e4       	ldi	r21, 0x41	; 65
    1990:	69 8d       	ldd	r22, Y+25	; 0x19
    1992:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1994:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1996:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1998:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
    199c:	dc 01       	movw	r26, r24
    199e:	cb 01       	movw	r24, r22
    19a0:	bc 01       	movw	r22, r24
    19a2:	cd 01       	movw	r24, r26
    19a4:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    19a8:	dc 01       	movw	r26, r24
    19aa:	cb 01       	movw	r24, r22
    19ac:	98 ab       	std	Y+48, r25	; 0x30
    19ae:	8f a7       	std	Y+47, r24	; 0x2f
    19b0:	0f c0       	rjmp	.+30     	; 0x19d0 <lcd_begin+0xc4a>
    19b2:	80 e9       	ldi	r24, 0x90	; 144
    19b4:	91 e0       	ldi	r25, 0x01	; 1
    19b6:	9a ab       	std	Y+50, r25	; 0x32
    19b8:	89 ab       	std	Y+49, r24	; 0x31
    19ba:	89 a9       	ldd	r24, Y+49	; 0x31
    19bc:	9a a9       	ldd	r25, Y+50	; 0x32
    19be:	01 97       	sbiw	r24, 0x01	; 1
    19c0:	f1 f7       	brne	.-4      	; 0x19be <lcd_begin+0xc38>
    19c2:	9a ab       	std	Y+50, r25	; 0x32
    19c4:	89 ab       	std	Y+49, r24	; 0x31
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    19c6:	8f a5       	ldd	r24, Y+47	; 0x2f
    19c8:	98 a9       	ldd	r25, Y+48	; 0x30
    19ca:	01 97       	sbiw	r24, 0x01	; 1
    19cc:	98 ab       	std	Y+48, r25	; 0x30
    19ce:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    19d0:	8f a5       	ldd	r24, Y+47	; 0x2f
    19d2:	98 a9       	ldd	r25, Y+48	; 0x30
    19d4:	89 2b       	or	r24, r25
    19d6:	69 f7       	brne	.-38     	; 0x19b2 <lcd_begin+0xc2c>
    19d8:	14 c0       	rjmp	.+40     	; 0x1a02 <lcd_begin+0xc7c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    19da:	6b a5       	ldd	r22, Y+43	; 0x2b
    19dc:	7c a5       	ldd	r23, Y+44	; 0x2c
    19de:	8d a5       	ldd	r24, Y+45	; 0x2d
    19e0:	9e a5       	ldd	r25, Y+46	; 0x2e
    19e2:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    19e6:	dc 01       	movw	r26, r24
    19e8:	cb 01       	movw	r24, r22
    19ea:	98 ab       	std	Y+48, r25	; 0x30
    19ec:	8f a7       	std	Y+47, r24	; 0x2f
    19ee:	8f a5       	ldd	r24, Y+47	; 0x2f
    19f0:	98 a9       	ldd	r25, Y+48	; 0x30
    19f2:	9c ab       	std	Y+52, r25	; 0x34
    19f4:	8b ab       	std	Y+51, r24	; 0x33
    19f6:	8b a9       	ldd	r24, Y+51	; 0x33
    19f8:	9c a9       	ldd	r25, Y+52	; 0x34
    19fa:	01 97       	sbiw	r24, 0x01	; 1
    19fc:	f1 f7       	brne	.-4      	; 0x19fa <lcd_begin+0xc74>
    19fe:	9c ab       	std	Y+52, r25	; 0x34
    1a00:	8b ab       	std	Y+51, r24	; 0x33
	_delay_ms(10);
	lcd_write_cmd_byte(0x80); //Beginning of the first line
    1a02:	80 e8       	ldi	r24, 0x80	; 128
    1a04:	0e 94 51 05 	call	0xaa2	; 0xaa2 <lcd_write_cmd_byte>
    1a08:	80 e0       	ldi	r24, 0x00	; 0
    1a0a:	90 e0       	ldi	r25, 0x00	; 0
    1a0c:	a0 e2       	ldi	r26, 0x20	; 32
    1a0e:	b1 e4       	ldi	r27, 0x41	; 65
    1a10:	8d 8f       	std	Y+29, r24	; 0x1d
    1a12:	9e 8f       	std	Y+30, r25	; 0x1e
    1a14:	af 8f       	std	Y+31, r26	; 0x1f
    1a16:	b8 a3       	std	Y+32, r27	; 0x20

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    1a18:	20 e0       	ldi	r18, 0x00	; 0
    1a1a:	30 e0       	ldi	r19, 0x00	; 0
    1a1c:	4a e7       	ldi	r20, 0x7A	; 122
    1a1e:	55 e4       	ldi	r21, 0x45	; 69
    1a20:	6d 8d       	ldd	r22, Y+29	; 0x1d
    1a22:	7e 8d       	ldd	r23, Y+30	; 0x1e
    1a24:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1a26:	98 a1       	ldd	r25, Y+32	; 0x20
    1a28:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
    1a2c:	dc 01       	movw	r26, r24
    1a2e:	cb 01       	movw	r24, r22
    1a30:	89 a3       	std	Y+33, r24	; 0x21
    1a32:	9a a3       	std	Y+34, r25	; 0x22
    1a34:	ab a3       	std	Y+35, r26	; 0x23
    1a36:	bc a3       	std	Y+36, r27	; 0x24
	if (__tmp < 1.0)
    1a38:	20 e0       	ldi	r18, 0x00	; 0
    1a3a:	30 e0       	ldi	r19, 0x00	; 0
    1a3c:	40 e8       	ldi	r20, 0x80	; 128
    1a3e:	5f e3       	ldi	r21, 0x3F	; 63
    1a40:	69 a1       	ldd	r22, Y+33	; 0x21
    1a42:	7a a1       	ldd	r23, Y+34	; 0x22
    1a44:	8b a1       	ldd	r24, Y+35	; 0x23
    1a46:	9c a1       	ldd	r25, Y+36	; 0x24
    1a48:	0e 94 00 1a 	call	0x3400	; 0x3400 <__cmpsf2>
    1a4c:	88 23       	and	r24, r24
    1a4e:	2c f4       	brge	.+10     	; 0x1a5a <lcd_begin+0xcd4>
		__ticks = 1;
    1a50:	81 e0       	ldi	r24, 0x01	; 1
    1a52:	90 e0       	ldi	r25, 0x00	; 0
    1a54:	9e a3       	std	Y+38, r25	; 0x26
    1a56:	8d a3       	std	Y+37, r24	; 0x25
    1a58:	3f c0       	rjmp	.+126    	; 0x1ad8 <lcd_begin+0xd52>
	else if (__tmp > 65535)
    1a5a:	20 e0       	ldi	r18, 0x00	; 0
    1a5c:	3f ef       	ldi	r19, 0xFF	; 255
    1a5e:	4f e7       	ldi	r20, 0x7F	; 127
    1a60:	57 e4       	ldi	r21, 0x47	; 71
    1a62:	69 a1       	ldd	r22, Y+33	; 0x21
    1a64:	7a a1       	ldd	r23, Y+34	; 0x22
    1a66:	8b a1       	ldd	r24, Y+35	; 0x23
    1a68:	9c a1       	ldd	r25, Y+36	; 0x24
    1a6a:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
    1a6e:	18 16       	cp	r1, r24
    1a70:	4c f5       	brge	.+82     	; 0x1ac4 <lcd_begin+0xd3e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1a72:	20 e0       	ldi	r18, 0x00	; 0
    1a74:	30 e0       	ldi	r19, 0x00	; 0
    1a76:	40 e2       	ldi	r20, 0x20	; 32
    1a78:	51 e4       	ldi	r21, 0x41	; 65
    1a7a:	6d 8d       	ldd	r22, Y+29	; 0x1d
    1a7c:	7e 8d       	ldd	r23, Y+30	; 0x1e
    1a7e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1a80:	98 a1       	ldd	r25, Y+32	; 0x20
    1a82:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
    1a86:	dc 01       	movw	r26, r24
    1a88:	cb 01       	movw	r24, r22
    1a8a:	bc 01       	movw	r22, r24
    1a8c:	cd 01       	movw	r24, r26
    1a8e:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    1a92:	dc 01       	movw	r26, r24
    1a94:	cb 01       	movw	r24, r22
    1a96:	9e a3       	std	Y+38, r25	; 0x26
    1a98:	8d a3       	std	Y+37, r24	; 0x25
    1a9a:	0f c0       	rjmp	.+30     	; 0x1aba <lcd_begin+0xd34>
    1a9c:	80 e9       	ldi	r24, 0x90	; 144
    1a9e:	91 e0       	ldi	r25, 0x01	; 1
    1aa0:	98 a7       	std	Y+40, r25	; 0x28
    1aa2:	8f a3       	std	Y+39, r24	; 0x27
    1aa4:	8f a1       	ldd	r24, Y+39	; 0x27
    1aa6:	98 a5       	ldd	r25, Y+40	; 0x28
    1aa8:	01 97       	sbiw	r24, 0x01	; 1
    1aaa:	f1 f7       	brne	.-4      	; 0x1aa8 <lcd_begin+0xd22>
    1aac:	98 a7       	std	Y+40, r25	; 0x28
    1aae:	8f a3       	std	Y+39, r24	; 0x27
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1ab0:	8d a1       	ldd	r24, Y+37	; 0x25
    1ab2:	9e a1       	ldd	r25, Y+38	; 0x26
    1ab4:	01 97       	sbiw	r24, 0x01	; 1
    1ab6:	9e a3       	std	Y+38, r25	; 0x26
    1ab8:	8d a3       	std	Y+37, r24	; 0x25
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1aba:	8d a1       	ldd	r24, Y+37	; 0x25
    1abc:	9e a1       	ldd	r25, Y+38	; 0x26
    1abe:	89 2b       	or	r24, r25
    1ac0:	69 f7       	brne	.-38     	; 0x1a9c <lcd_begin+0xd16>
	_delay_ms(10);
}
    1ac2:	14 c0       	rjmp	.+40     	; 0x1aec <lcd_begin+0xd66>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1ac4:	69 a1       	ldd	r22, Y+33	; 0x21
    1ac6:	7a a1       	ldd	r23, Y+34	; 0x22
    1ac8:	8b a1       	ldd	r24, Y+35	; 0x23
    1aca:	9c a1       	ldd	r25, Y+36	; 0x24
    1acc:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    1ad0:	dc 01       	movw	r26, r24
    1ad2:	cb 01       	movw	r24, r22
    1ad4:	9e a3       	std	Y+38, r25	; 0x26
    1ad6:	8d a3       	std	Y+37, r24	; 0x25
    1ad8:	8d a1       	ldd	r24, Y+37	; 0x25
    1ada:	9e a1       	ldd	r25, Y+38	; 0x26
    1adc:	9a a7       	std	Y+42, r25	; 0x2a
    1ade:	89 a7       	std	Y+41, r24	; 0x29
    1ae0:	89 a5       	ldd	r24, Y+41	; 0x29
    1ae2:	9a a5       	ldd	r25, Y+42	; 0x2a
    1ae4:	01 97       	sbiw	r24, 0x01	; 1
    1ae6:	f1 f7       	brne	.-4      	; 0x1ae4 <lcd_begin+0xd5e>
    1ae8:	9a a7       	std	Y+42, r25	; 0x2a
    1aea:	89 a7       	std	Y+41, r24	; 0x29
    1aec:	00 00       	nop
    1aee:	cc 56       	subi	r28, 0x6C	; 108
    1af0:	df 4f       	sbci	r29, 0xFF	; 255
    1af2:	0f b6       	in	r0, 0x3f	; 63
    1af4:	f8 94       	cli
    1af6:	de bf       	out	0x3e, r29	; 62
    1af8:	0f be       	out	0x3f, r0	; 63
    1afa:	cd bf       	out	0x3d, r28	; 61
    1afc:	df 91       	pop	r29
    1afe:	cf 91       	pop	r28
    1b00:	1f 91       	pop	r17
    1b02:	0f 91       	pop	r16
    1b04:	08 95       	ret

00001b06 <lcd_set_cursor>:

void lcd_set_cursor(char x,char y)
{
    1b06:	cf 93       	push	r28
    1b08:	df 93       	push	r29
    1b0a:	00 d0       	rcall	.+0      	; 0x1b0c <lcd_set_cursor+0x6>
    1b0c:	cd b7       	in	r28, 0x3d	; 61
    1b0e:	de b7       	in	r29, 0x3e	; 62
    1b10:	89 83       	std	Y+1, r24	; 0x01
    1b12:	6a 83       	std	Y+2, r22	; 0x02
	if(x<40)
    1b14:	89 81       	ldd	r24, Y+1	; 0x01
    1b16:	88 32       	cpi	r24, 0x28	; 40
    1b18:	3c f5       	brge	.+78     	; 0x1b68 <lcd_set_cursor+0x62>
	{
		switch(y)
    1b1a:	8a 81       	ldd	r24, Y+2	; 0x02
    1b1c:	08 2e       	mov	r0, r24
    1b1e:	00 0c       	add	r0, r0
    1b20:	99 0b       	sbc	r25, r25
    1b22:	81 30       	cpi	r24, 0x01	; 1
    1b24:	91 05       	cpc	r25, r1
    1b26:	81 f0       	breq	.+32     	; 0x1b48 <lcd_set_cursor+0x42>
    1b28:	82 30       	cpi	r24, 0x02	; 2
    1b2a:	91 05       	cpc	r25, r1
    1b2c:	1c f4       	brge	.+6      	; 0x1b34 <lcd_set_cursor+0x2e>
    1b2e:	89 2b       	or	r24, r25
    1b30:	39 f0       	breq	.+14     	; 0x1b40 <lcd_set_cursor+0x3a>
    1b32:	16 c0       	rjmp	.+44     	; 0x1b60 <lcd_set_cursor+0x5a>
    1b34:	82 30       	cpi	r24, 0x02	; 2
    1b36:	91 05       	cpc	r25, r1
    1b38:	59 f0       	breq	.+22     	; 0x1b50 <lcd_set_cursor+0x4a>
    1b3a:	03 97       	sbiw	r24, 0x03	; 3
    1b3c:	69 f0       	breq	.+26     	; 0x1b58 <lcd_set_cursor+0x52>
    1b3e:	10 c0       	rjmp	.+32     	; 0x1b60 <lcd_set_cursor+0x5a>
		{
			case 0://1 line starts at 080(0b10000000)
			x |=0b10000000;
    1b40:	89 81       	ldd	r24, Y+1	; 0x01
    1b42:	80 68       	ori	r24, 0x80	; 128
    1b44:	89 83       	std	Y+1, r24	; 0x01
			break;
    1b46:	0c c0       	rjmp	.+24     	; 0x1b60 <lcd_set_cursor+0x5a>
			case 1://2 line starts at 0xC0(0b11000000)
			x |=0b11000000;
    1b48:	89 81       	ldd	r24, Y+1	; 0x01
    1b4a:	80 6c       	ori	r24, 0xC0	; 192
    1b4c:	89 83       	std	Y+1, r24	; 0x01
			break;
    1b4e:	08 c0       	rjmp	.+16     	; 0x1b60 <lcd_set_cursor+0x5a>
			case 2://3 line starts at 094(0b10010100)
			x |=0b10010100;
    1b50:	89 81       	ldd	r24, Y+1	; 0x01
    1b52:	84 69       	ori	r24, 0x94	; 148
    1b54:	89 83       	std	Y+1, r24	; 0x01
			break;
    1b56:	04 c0       	rjmp	.+8      	; 0x1b60 <lcd_set_cursor+0x5a>
			case 3://4 line starts at 0xD4(0b11010100)
			x |=0b11010100;
    1b58:	89 81       	ldd	r24, Y+1	; 0x01
    1b5a:	84 6d       	ori	r24, 0xD4	; 212
    1b5c:	89 83       	std	Y+1, r24	; 0x01
			break;
    1b5e:	00 00       	nop
		}
		lcd_write_byte(x,CMD);
    1b60:	89 81       	ldd	r24, Y+1	; 0x01
    1b62:	60 e0       	ldi	r22, 0x00	; 0
    1b64:	0e 94 35 03 	call	0x66a	; 0x66a <lcd_write_byte>
		//_delay_ms(1);
	}
}
    1b68:	00 00       	nop
    1b6a:	0f 90       	pop	r0
    1b6c:	0f 90       	pop	r0
    1b6e:	df 91       	pop	r29
    1b70:	cf 91       	pop	r28
    1b72:	08 95       	ret

00001b74 <lcd_print>:

void lcd_print(char* str)
{
    1b74:	cf 93       	push	r28
    1b76:	df 93       	push	r29
    1b78:	00 d0       	rcall	.+0      	; 0x1b7a <lcd_print+0x6>
    1b7a:	1f 92       	push	r1
    1b7c:	cd b7       	in	r28, 0x3d	; 61
    1b7e:	de b7       	in	r29, 0x3e	; 62
    1b80:	9b 83       	std	Y+3, r25	; 0x03
    1b82:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t i = 0;
    1b84:	19 82       	std	Y+1, r1	; 0x01
	//lcd_write_byte(0x80,CMD);
	while(str[i] != '\0')
    1b86:	0f c0       	rjmp	.+30     	; 0x1ba6 <lcd_print+0x32>
	{
		lcd_write_byte(str[i],DATA);
    1b88:	89 81       	ldd	r24, Y+1	; 0x01
    1b8a:	88 2f       	mov	r24, r24
    1b8c:	90 e0       	ldi	r25, 0x00	; 0
    1b8e:	2a 81       	ldd	r18, Y+2	; 0x02
    1b90:	3b 81       	ldd	r19, Y+3	; 0x03
    1b92:	82 0f       	add	r24, r18
    1b94:	93 1f       	adc	r25, r19
    1b96:	fc 01       	movw	r30, r24
    1b98:	80 81       	ld	r24, Z
    1b9a:	61 e0       	ldi	r22, 0x01	; 1
    1b9c:	0e 94 35 03 	call	0x66a	; 0x66a <lcd_write_byte>
		i++;
    1ba0:	89 81       	ldd	r24, Y+1	; 0x01
    1ba2:	8f 5f       	subi	r24, 0xFF	; 255
    1ba4:	89 83       	std	Y+1, r24	; 0x01

void lcd_print(char* str)
{
	uint8_t i = 0;
	//lcd_write_byte(0x80,CMD);
	while(str[i] != '\0')
    1ba6:	89 81       	ldd	r24, Y+1	; 0x01
    1ba8:	88 2f       	mov	r24, r24
    1baa:	90 e0       	ldi	r25, 0x00	; 0
    1bac:	2a 81       	ldd	r18, Y+2	; 0x02
    1bae:	3b 81       	ldd	r19, Y+3	; 0x03
    1bb0:	82 0f       	add	r24, r18
    1bb2:	93 1f       	adc	r25, r19
    1bb4:	fc 01       	movw	r30, r24
    1bb6:	80 81       	ld	r24, Z
    1bb8:	88 23       	and	r24, r24
    1bba:	31 f7       	brne	.-52     	; 0x1b88 <lcd_print+0x14>
	{
		lcd_write_byte(str[i],DATA);
		i++;
	}
    1bbc:	00 00       	nop
    1bbe:	0f 90       	pop	r0
    1bc0:	0f 90       	pop	r0
    1bc2:	0f 90       	pop	r0
    1bc4:	df 91       	pop	r29
    1bc6:	cf 91       	pop	r28
    1bc8:	08 95       	ret

00001bca <ledClr>:
#include "ledNbutton.h"
#include "utils.h"
#include "config.h"

void ledClr(int led_p) {
    1bca:	cf 93       	push	r28
    1bcc:	df 93       	push	r29
    1bce:	00 d0       	rcall	.+0      	; 0x1bd0 <ledClr+0x6>
    1bd0:	cd b7       	in	r28, 0x3d	; 61
    1bd2:	de b7       	in	r29, 0x3e	; 62
    1bd4:	9a 83       	std	Y+2, r25	; 0x02
    1bd6:	89 83       	std	Y+1, r24	; 0x01
    PORTB &= ~(1<<led_p);
    1bd8:	85 e2       	ldi	r24, 0x25	; 37
    1bda:	90 e0       	ldi	r25, 0x00	; 0
    1bdc:	25 e2       	ldi	r18, 0x25	; 37
    1bde:	30 e0       	ldi	r19, 0x00	; 0
    1be0:	f9 01       	movw	r30, r18
    1be2:	20 81       	ld	r18, Z
    1be4:	42 2f       	mov	r20, r18
    1be6:	21 e0       	ldi	r18, 0x01	; 1
    1be8:	30 e0       	ldi	r19, 0x00	; 0
    1bea:	09 80       	ldd	r0, Y+1	; 0x01
    1bec:	02 c0       	rjmp	.+4      	; 0x1bf2 <ledClr+0x28>
    1bee:	22 0f       	add	r18, r18
    1bf0:	33 1f       	adc	r19, r19
    1bf2:	0a 94       	dec	r0
    1bf4:	e2 f7       	brpl	.-8      	; 0x1bee <ledClr+0x24>
    1bf6:	20 95       	com	r18
    1bf8:	24 23       	and	r18, r20
    1bfa:	fc 01       	movw	r30, r24
    1bfc:	20 83       	st	Z, r18
}
    1bfe:	00 00       	nop
    1c00:	0f 90       	pop	r0
    1c02:	0f 90       	pop	r0
    1c04:	df 91       	pop	r29
    1c06:	cf 91       	pop	r28
    1c08:	08 95       	ret

00001c0a <ledSet>:

void ledSet(int led_p) {
    1c0a:	cf 93       	push	r28
    1c0c:	df 93       	push	r29
    1c0e:	00 d0       	rcall	.+0      	; 0x1c10 <ledSet+0x6>
    1c10:	cd b7       	in	r28, 0x3d	; 61
    1c12:	de b7       	in	r29, 0x3e	; 62
    1c14:	9a 83       	std	Y+2, r25	; 0x02
    1c16:	89 83       	std	Y+1, r24	; 0x01
    PORTB |= (1<<led_p);
    1c18:	85 e2       	ldi	r24, 0x25	; 37
    1c1a:	90 e0       	ldi	r25, 0x00	; 0
    1c1c:	25 e2       	ldi	r18, 0x25	; 37
    1c1e:	30 e0       	ldi	r19, 0x00	; 0
    1c20:	f9 01       	movw	r30, r18
    1c22:	20 81       	ld	r18, Z
    1c24:	42 2f       	mov	r20, r18
    1c26:	21 e0       	ldi	r18, 0x01	; 1
    1c28:	30 e0       	ldi	r19, 0x00	; 0
    1c2a:	09 80       	ldd	r0, Y+1	; 0x01
    1c2c:	02 c0       	rjmp	.+4      	; 0x1c32 <ledSet+0x28>
    1c2e:	22 0f       	add	r18, r18
    1c30:	33 1f       	adc	r19, r19
    1c32:	0a 94       	dec	r0
    1c34:	e2 f7       	brpl	.-8      	; 0x1c2e <ledSet+0x24>
    1c36:	24 2b       	or	r18, r20
    1c38:	fc 01       	movw	r30, r24
    1c3a:	20 83       	st	Z, r18
}
    1c3c:	00 00       	nop
    1c3e:	0f 90       	pop	r0
    1c40:	0f 90       	pop	r0
    1c42:	df 91       	pop	r29
    1c44:	cf 91       	pop	r28
    1c46:	08 95       	ret

00001c48 <ledTog>:

void ledTog(int led_p) {
    1c48:	cf 93       	push	r28
    1c4a:	df 93       	push	r29
    1c4c:	00 d0       	rcall	.+0      	; 0x1c4e <ledTog+0x6>
    1c4e:	cd b7       	in	r28, 0x3d	; 61
    1c50:	de b7       	in	r29, 0x3e	; 62
    1c52:	9a 83       	std	Y+2, r25	; 0x02
    1c54:	89 83       	std	Y+1, r24	; 0x01
    PORTB ^= (1<<led_p);
    1c56:	85 e2       	ldi	r24, 0x25	; 37
    1c58:	90 e0       	ldi	r25, 0x00	; 0
    1c5a:	25 e2       	ldi	r18, 0x25	; 37
    1c5c:	30 e0       	ldi	r19, 0x00	; 0
    1c5e:	f9 01       	movw	r30, r18
    1c60:	20 81       	ld	r18, Z
    1c62:	42 2f       	mov	r20, r18
    1c64:	21 e0       	ldi	r18, 0x01	; 1
    1c66:	30 e0       	ldi	r19, 0x00	; 0
    1c68:	09 80       	ldd	r0, Y+1	; 0x01
    1c6a:	02 c0       	rjmp	.+4      	; 0x1c70 <ledTog+0x28>
    1c6c:	22 0f       	add	r18, r18
    1c6e:	33 1f       	adc	r19, r19
    1c70:	0a 94       	dec	r0
    1c72:	e2 f7       	brpl	.-8      	; 0x1c6c <ledTog+0x24>
    1c74:	24 27       	eor	r18, r20
    1c76:	fc 01       	movw	r30, r24
    1c78:	20 83       	st	Z, r18
}
    1c7a:	00 00       	nop
    1c7c:	0f 90       	pop	r0
    1c7e:	0f 90       	pop	r0
    1c80:	df 91       	pop	r29
    1c82:	cf 91       	pop	r28
    1c84:	08 95       	ret

00001c86 <getButtonSta>:

int getButtonSta(int btn_p) {
    1c86:	cf 93       	push	r28
    1c88:	df 93       	push	r29
    1c8a:	00 d0       	rcall	.+0      	; 0x1c8c <getButtonSta+0x6>
    1c8c:	00 d0       	rcall	.+0      	; 0x1c8e <getButtonSta+0x8>
    1c8e:	cd b7       	in	r28, 0x3d	; 61
    1c90:	de b7       	in	r29, 0x3e	; 62
    1c92:	9c 83       	std	Y+4, r25	; 0x04
    1c94:	8b 83       	std	Y+3, r24	; 0x03
    int state = (PINB & (1<<btn_p)) >> btn_p;
    1c96:	83 e2       	ldi	r24, 0x23	; 35
    1c98:	90 e0       	ldi	r25, 0x00	; 0
    1c9a:	fc 01       	movw	r30, r24
    1c9c:	80 81       	ld	r24, Z
    1c9e:	28 2f       	mov	r18, r24
    1ca0:	30 e0       	ldi	r19, 0x00	; 0
    1ca2:	81 e0       	ldi	r24, 0x01	; 1
    1ca4:	90 e0       	ldi	r25, 0x00	; 0
    1ca6:	0b 80       	ldd	r0, Y+3	; 0x03
    1ca8:	02 c0       	rjmp	.+4      	; 0x1cae <getButtonSta+0x28>
    1caa:	88 0f       	add	r24, r24
    1cac:	99 1f       	adc	r25, r25
    1cae:	0a 94       	dec	r0
    1cb0:	e2 f7       	brpl	.-8      	; 0x1caa <getButtonSta+0x24>
    1cb2:	82 23       	and	r24, r18
    1cb4:	93 23       	and	r25, r19
    1cb6:	0b 80       	ldd	r0, Y+3	; 0x03
    1cb8:	02 c0       	rjmp	.+4      	; 0x1cbe <getButtonSta+0x38>
    1cba:	95 95       	asr	r25
    1cbc:	87 95       	ror	r24
    1cbe:	0a 94       	dec	r0
    1cc0:	e2 f7       	brpl	.-8      	; 0x1cba <getButtonSta+0x34>
    1cc2:	9a 83       	std	Y+2, r25	; 0x02
    1cc4:	89 83       	std	Y+1, r24	; 0x01
    return state;
    1cc6:	89 81       	ldd	r24, Y+1	; 0x01
    1cc8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1cca:	0f 90       	pop	r0
    1ccc:	0f 90       	pop	r0
    1cce:	0f 90       	pop	r0
    1cd0:	0f 90       	pop	r0
    1cd2:	df 91       	pop	r29
    1cd4:	cf 91       	pop	r28
    1cd6:	08 95       	ret

00001cd8 <getButtonPrs>:

int getButtonPrs(int btn_p) {
    1cd8:	cf 93       	push	r28
    1cda:	df 93       	push	r29
    1cdc:	00 d0       	rcall	.+0      	; 0x1cde <getButtonPrs+0x6>
    1cde:	00 d0       	rcall	.+0      	; 0x1ce0 <getButtonPrs+0x8>
    1ce0:	cd b7       	in	r28, 0x3d	; 61
    1ce2:	de b7       	in	r29, 0x3e	; 62
    1ce4:	9c 83       	std	Y+4, r25	; 0x04
    1ce6:	8b 83       	std	Y+3, r24	; 0x03
    static int state_old = 0;

    int state = (PINB & (1<<btn_p)) >> btn_p;
    1ce8:	83 e2       	ldi	r24, 0x23	; 35
    1cea:	90 e0       	ldi	r25, 0x00	; 0
    1cec:	fc 01       	movw	r30, r24
    1cee:	80 81       	ld	r24, Z
    1cf0:	28 2f       	mov	r18, r24
    1cf2:	30 e0       	ldi	r19, 0x00	; 0
    1cf4:	81 e0       	ldi	r24, 0x01	; 1
    1cf6:	90 e0       	ldi	r25, 0x00	; 0
    1cf8:	0b 80       	ldd	r0, Y+3	; 0x03
    1cfa:	02 c0       	rjmp	.+4      	; 0x1d00 <getButtonPrs+0x28>
    1cfc:	88 0f       	add	r24, r24
    1cfe:	99 1f       	adc	r25, r25
    1d00:	0a 94       	dec	r0
    1d02:	e2 f7       	brpl	.-8      	; 0x1cfc <getButtonPrs+0x24>
    1d04:	82 23       	and	r24, r18
    1d06:	93 23       	and	r25, r19
    1d08:	0b 80       	ldd	r0, Y+3	; 0x03
    1d0a:	02 c0       	rjmp	.+4      	; 0x1d10 <getButtonPrs+0x38>
    1d0c:	95 95       	asr	r25
    1d0e:	87 95       	ror	r24
    1d10:	0a 94       	dec	r0
    1d12:	e2 f7       	brpl	.-8      	; 0x1d0c <getButtonPrs+0x34>
    1d14:	9a 83       	std	Y+2, r25	; 0x02
    1d16:	89 83       	std	Y+1, r24	; 0x01

    if (state_old != state) {
    1d18:	20 91 e9 02 	lds	r18, 0x02E9	; 0x8002e9 <state_old.1641>
    1d1c:	30 91 ea 02 	lds	r19, 0x02EA	; 0x8002ea <state_old.1641+0x1>
    1d20:	89 81       	ldd	r24, Y+1	; 0x01
    1d22:	9a 81       	ldd	r25, Y+2	; 0x02
    1d24:	28 17       	cp	r18, r24
    1d26:	39 07       	cpc	r19, r25
    1d28:	69 f0       	breq	.+26     	; 0x1d44 <getButtonPrs+0x6c>
        state_old = state;
    1d2a:	89 81       	ldd	r24, Y+1	; 0x01
    1d2c:	9a 81       	ldd	r25, Y+2	; 0x02
    1d2e:	90 93 ea 02 	sts	0x02EA, r25	; 0x8002ea <state_old.1641+0x1>
    1d32:	80 93 e9 02 	sts	0x02E9, r24	; 0x8002e9 <state_old.1641>
        if (state == 1) {
    1d36:	89 81       	ldd	r24, Y+1	; 0x01
    1d38:	9a 81       	ldd	r25, Y+2	; 0x02
    1d3a:	01 97       	sbiw	r24, 0x01	; 1
    1d3c:	19 f4       	brne	.+6      	; 0x1d44 <getButtonPrs+0x6c>
            return 1;
    1d3e:	81 e0       	ldi	r24, 0x01	; 1
    1d40:	90 e0       	ldi	r25, 0x00	; 0
    1d42:	02 c0       	rjmp	.+4      	; 0x1d48 <getButtonPrs+0x70>
        }
    }
    return 0;
    1d44:	80 e0       	ldi	r24, 0x00	; 0
    1d46:	90 e0       	ldi	r25, 0x00	; 0

}
    1d48:	0f 90       	pop	r0
    1d4a:	0f 90       	pop	r0
    1d4c:	0f 90       	pop	r0
    1d4e:	0f 90       	pop	r0
    1d50:	df 91       	pop	r29
    1d52:	cf 91       	pop	r28
    1d54:	08 95       	ret

00001d56 <adc_read>:

int adc_read(void) {
    1d56:	cf 93       	push	r28
    1d58:	df 93       	push	r29
    1d5a:	cd b7       	in	r28, 0x3d	; 61
    1d5c:	de b7       	in	r29, 0x3e	; 62
    /*return ADCL;*/
    //select ADC channel with safety mask
    ADMUX = (ADMUX & 0xF0) | (ADCchannel & 0x0F);
    1d5e:	8c e7       	ldi	r24, 0x7C	; 124
    1d60:	90 e0       	ldi	r25, 0x00	; 0
    1d62:	2c e7       	ldi	r18, 0x7C	; 124
    1d64:	30 e0       	ldi	r19, 0x00	; 0
    1d66:	f9 01       	movw	r30, r18
    1d68:	20 81       	ld	r18, Z
    1d6a:	20 7f       	andi	r18, 0xF0	; 240
    1d6c:	fc 01       	movw	r30, r24
    1d6e:	20 83       	st	Z, r18
    //single conversion mode
    ADCSRA |= (1<<ADSC);
    1d70:	8a e7       	ldi	r24, 0x7A	; 122
    1d72:	90 e0       	ldi	r25, 0x00	; 0
    1d74:	2a e7       	ldi	r18, 0x7A	; 122
    1d76:	30 e0       	ldi	r19, 0x00	; 0
    1d78:	f9 01       	movw	r30, r18
    1d7a:	20 81       	ld	r18, Z
    1d7c:	20 64       	ori	r18, 0x40	; 64
    1d7e:	fc 01       	movw	r30, r24
    1d80:	20 83       	st	Z, r18
    // wait until ADC conversion is complete
    while( ADCSRA & (1<<ADSC) );
    1d82:	00 00       	nop
    1d84:	8a e7       	ldi	r24, 0x7A	; 122
    1d86:	90 e0       	ldi	r25, 0x00	; 0
    1d88:	fc 01       	movw	r30, r24
    1d8a:	80 81       	ld	r24, Z
    1d8c:	88 2f       	mov	r24, r24
    1d8e:	90 e0       	ldi	r25, 0x00	; 0
    1d90:	80 74       	andi	r24, 0x40	; 64
    1d92:	99 27       	eor	r25, r25
    1d94:	89 2b       	or	r24, r25
    1d96:	b1 f7       	brne	.-20     	; 0x1d84 <adc_read+0x2e>
    return ADC;
    1d98:	88 e7       	ldi	r24, 0x78	; 120
    1d9a:	90 e0       	ldi	r25, 0x00	; 0
    1d9c:	fc 01       	movw	r30, r24
    1d9e:	80 81       	ld	r24, Z
    1da0:	91 81       	ldd	r25, Z+1	; 0x01
}
    1da2:	df 91       	pop	r29
    1da4:	cf 91       	pop	r28
    1da6:	08 95       	ret

00001da8 <__vector_13>:
#include "Task2/Task2.h"
#include "utils.h"

/* Timer interrupt. The OS_TaskTimer() shall be here. */
ISR (TIMER1_OVF_vect)
{
    1da8:	1f 92       	push	r1
    1daa:	0f 92       	push	r0
    1dac:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    1db0:	0f 92       	push	r0
    1db2:	11 24       	eor	r1, r1
    1db4:	2f 93       	push	r18
    1db6:	3f 93       	push	r19
    1db8:	4f 93       	push	r20
    1dba:	5f 93       	push	r21
    1dbc:	6f 93       	push	r22
    1dbe:	7f 93       	push	r23
    1dc0:	8f 93       	push	r24
    1dc2:	9f 93       	push	r25
    1dc4:	af 93       	push	r26
    1dc6:	bf 93       	push	r27
    1dc8:	ef 93       	push	r30
    1dca:	ff 93       	push	r31
    1dcc:	cf 93       	push	r28
    1dce:	df 93       	push	r29
    1dd0:	cd b7       	in	r28, 0x3d	; 61
    1dd2:	de b7       	in	r29, 0x3e	; 62
    TCNT1 = 31250;
    1dd4:	84 e8       	ldi	r24, 0x84	; 132
    1dd6:	90 e0       	ldi	r25, 0x00	; 0
    1dd8:	22 e1       	ldi	r18, 0x12	; 18
    1dda:	3a e7       	ldi	r19, 0x7A	; 122
    1ddc:	fc 01       	movw	r30, r24
    1dde:	31 83       	std	Z+1, r19	; 0x01
    1de0:	20 83       	st	Z, r18
    OS_TaskTimer();
    1de2:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <OS_TaskTimer>
}
    1de6:	00 00       	nop
    1de8:	df 91       	pop	r29
    1dea:	cf 91       	pop	r28
    1dec:	ff 91       	pop	r31
    1dee:	ef 91       	pop	r30
    1df0:	bf 91       	pop	r27
    1df2:	af 91       	pop	r26
    1df4:	9f 91       	pop	r25
    1df6:	8f 91       	pop	r24
    1df8:	7f 91       	pop	r23
    1dfa:	6f 91       	pop	r22
    1dfc:	5f 91       	pop	r21
    1dfe:	4f 91       	pop	r20
    1e00:	3f 91       	pop	r19
    1e02:	2f 91       	pop	r18
    1e04:	0f 90       	pop	r0
    1e06:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    1e0a:	0f 90       	pop	r0
    1e0c:	1f 90       	pop	r1
    1e0e:	18 95       	reti

00001e10 <main>:

/* Main function. */
int16_t main(void)
{
    1e10:	cf 93       	push	r28
    1e12:	df 93       	push	r29
    1e14:	cd b7       	in	r28, 0x3d	; 61
    1e16:	de b7       	in	r29, 0x3e	; 62
    /* Initialize the 3 LEDS and turn them off as default value. */
    //DDRD = (1 << DDD0) | (1 << DDD1) | (1 << DDD2);
    //PORTD &= ~(1 << PORTD0) & ~(1 << PORTD1) & ~(1 << PORTD2);
    configureLEDs();
    1e18:	0e 94 0c 19 	call	0x3218	; 0x3218 <configureLEDs>

    /* Set the timer interrupt to fire every 1 sec. */
    TCCR1B = (1 << CS12);
    1e1c:	81 e8       	ldi	r24, 0x81	; 129
    1e1e:	90 e0       	ldi	r25, 0x00	; 0
    1e20:	24 e0       	ldi	r18, 0x04	; 4
    1e22:	fc 01       	movw	r30, r24
    1e24:	20 83       	st	Z, r18
    TCNT1 = 31250;
    1e26:	84 e8       	ldi	r24, 0x84	; 132
    1e28:	90 e0       	ldi	r25, 0x00	; 0
    1e2a:	22 e1       	ldi	r18, 0x12	; 18
    1e2c:	3a e7       	ldi	r19, 0x7A	; 122
    1e2e:	fc 01       	movw	r30, r24
    1e30:	31 83       	std	Z+1, r19	; 0x01
    1e32:	20 83       	st	Z, r18
    TIMSK1 = (1 << TOIE1);
    1e34:	8f e6       	ldi	r24, 0x6F	; 111
    1e36:	90 e0       	ldi	r25, 0x00	; 0
    1e38:	21 e0       	ldi	r18, 0x01	; 1
    1e3a:	fc 01       	movw	r30, r24
    1e3c:	20 83       	st	Z, r18
    sei();
    1e3e:	78 94       	sei

    /* Register the three blinker tasks. */
    /* Note: Task1_Blink is registered as suspended. It is never going to be called until someone changes the task's state manually. */
    /* The recommended default state is BLOCKED, the SUSPENDED is only for demonstration purpose. */
    OS_TaskCreate(&Task0_Blink, 1, BLOCKED);
    1e40:	40 e0       	ldi	r20, 0x00	; 0
    1e42:	50 e0       	ldi	r21, 0x00	; 0
    1e44:	61 e0       	ldi	r22, 0x01	; 1
    1e46:	8d e1       	ldi	r24, 0x1D	; 29
    1e48:	91 e1       	ldi	r25, 0x11	; 17
    1e4a:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <OS_TaskCreate>
    OS_TaskCreate(&Task1_Blink, 2, SUSPENDED);
    1e4e:	42 e0       	ldi	r20, 0x02	; 2
    1e50:	50 e0       	ldi	r21, 0x00	; 0
    1e52:	62 e0       	ldi	r22, 0x02	; 2
    1e54:	89 e2       	ldi	r24, 0x29	; 41
    1e56:	91 e1       	ldi	r25, 0x11	; 17
    1e58:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <OS_TaskCreate>
    OS_TaskCreate(&Task2_Blink, 5, BLOCKED);
    1e5c:	40 e0       	ldi	r20, 0x00	; 0
    1e5e:	50 e0       	ldi	r21, 0x00	; 0
    1e60:	65 e0       	ldi	r22, 0x05	; 5
    1e62:	85 e3       	ldi	r24, 0x35	; 53
    1e64:	91 e1       	ldi	r25, 0x11	; 17
    1e66:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <OS_TaskCreate>

    /* The infinte loop, only the OS_TaskExecution() function shall be here. */
    while (1)
    {
        OS_TaskExecution();
    1e6a:	0e 94 36 10 	call	0x206c	; 0x206c <OS_TaskExecution>
    }
    1e6e:	fd cf       	rjmp	.-6      	; 0x1e6a <main+0x5a>

00001e70 <OS_TaskCreate>:
 * @param   default_time_burst: The time it gets called periodically.
 * @param   default_state: The state it starts (recommended state: BLOCKED).
 * @return  OS_feedback: Feedback about the success or cause of error of the registration.
 */
OS_feedback OS_TaskCreate(fncPtr function, uint8_t default_time_burst, OS_state default_state)
{
    1e70:	cf 93       	push	r28
    1e72:	df 93       	push	r29
    1e74:	cd b7       	in	r28, 0x3d	; 61
    1e76:	de b7       	in	r29, 0x3e	; 62
    1e78:	27 97       	sbiw	r28, 0x07	; 7
    1e7a:	0f b6       	in	r0, 0x3f	; 63
    1e7c:	f8 94       	cli
    1e7e:	de bf       	out	0x3e, r29	; 62
    1e80:	0f be       	out	0x3f, r0	; 63
    1e82:	cd bf       	out	0x3d, r28	; 61
    1e84:	9c 83       	std	Y+4, r25	; 0x04
    1e86:	8b 83       	std	Y+3, r24	; 0x03
    1e88:	6d 83       	std	Y+5, r22	; 0x05
    1e8a:	5f 83       	std	Y+7, r21	; 0x07
    1e8c:	4e 83       	std	Y+6, r20	; 0x06
    OS_feedback ret = NOK_UNKNOWN;
    1e8e:	84 e0       	ldi	r24, 0x04	; 4
    1e90:	90 e0       	ldi	r25, 0x00	; 0
    1e92:	9a 83       	std	Y+2, r25	; 0x02
    1e94:	89 83       	std	Y+1, r24	; 0x01
    if (NULL == task_array)
    {
        ret = NOK_NULL_PTR;
    }
    /* Time limit. */
    else if ((OS_MIN_TIME > default_time_burst) || (OS_MAX_TIME < default_time_burst))
    1e96:	8d 81       	ldd	r24, Y+5	; 0x05
    1e98:	88 23       	and	r24, r24
    1e9a:	19 f0       	breq	.+6      	; 0x1ea2 <OS_TaskCreate+0x32>
    1e9c:	8d 81       	ldd	r24, Y+5	; 0x05
    1e9e:	8b 30       	cpi	r24, 0x0B	; 11
    1ea0:	28 f0       	brcs	.+10     	; 0x1eac <OS_TaskCreate+0x3c>
    {
        ret = NOK_TIME_LIMIT;
    1ea2:	82 e0       	ldi	r24, 0x02	; 2
    1ea4:	90 e0       	ldi	r25, 0x00	; 0
    1ea6:	9a 83       	std	Y+2, r25	; 0x02
    1ea8:	89 83       	std	Y+1, r24	; 0x01
    1eaa:	54 c0       	rjmp	.+168    	; 0x1f54 <OS_TaskCreate+0xe4>
    }
    /* Task number limit. */
    else if (OS_MAX_TASK_NUM <= task_number)
    1eac:	80 91 27 03 	lds	r24, 0x0327	; 0x800327 <task_number>
    1eb0:	8a 30       	cpi	r24, 0x0A	; 10
    1eb2:	28 f0       	brcs	.+10     	; 0x1ebe <OS_TaskCreate+0x4e>
    {
        ret = NOK_CNT_LIMIT;
    1eb4:	83 e0       	ldi	r24, 0x03	; 3
    1eb6:	90 e0       	ldi	r25, 0x00	; 0
    1eb8:	9a 83       	std	Y+2, r25	; 0x02
    1eba:	89 83       	std	Y+1, r24	; 0x01
    1ebc:	4b c0       	rjmp	.+150    	; 0x1f54 <OS_TaskCreate+0xe4>
    }
    /* Everything is fine, save. */
    else
    {
        task_array[task_number].function = function;
    1ebe:	80 91 27 03 	lds	r24, 0x0327	; 0x800327 <task_number>
    1ec2:	28 2f       	mov	r18, r24
    1ec4:	30 e0       	ldi	r19, 0x00	; 0
    1ec6:	c9 01       	movw	r24, r18
    1ec8:	88 0f       	add	r24, r24
    1eca:	99 1f       	adc	r25, r25
    1ecc:	82 0f       	add	r24, r18
    1ece:	93 1f       	adc	r25, r19
    1ed0:	88 0f       	add	r24, r24
    1ed2:	99 1f       	adc	r25, r25
    1ed4:	85 51       	subi	r24, 0x15	; 21
    1ed6:	9d 4f       	sbci	r25, 0xFD	; 253
    1ed8:	2b 81       	ldd	r18, Y+3	; 0x03
    1eda:	3c 81       	ldd	r19, Y+4	; 0x04
    1edc:	fc 01       	movw	r30, r24
    1ede:	31 83       	std	Z+1, r19	; 0x01
    1ee0:	20 83       	st	Z, r18
        task_array[task_number].time_burst = default_time_burst;
    1ee2:	80 91 27 03 	lds	r24, 0x0327	; 0x800327 <task_number>
    1ee6:	28 2f       	mov	r18, r24
    1ee8:	30 e0       	ldi	r19, 0x00	; 0
    1eea:	c9 01       	movw	r24, r18
    1eec:	88 0f       	add	r24, r24
    1eee:	99 1f       	adc	r25, r25
    1ef0:	82 0f       	add	r24, r18
    1ef2:	93 1f       	adc	r25, r19
    1ef4:	88 0f       	add	r24, r24
    1ef6:	99 1f       	adc	r25, r25
    1ef8:	83 51       	subi	r24, 0x13	; 19
    1efa:	9d 4f       	sbci	r25, 0xFD	; 253
    1efc:	2d 81       	ldd	r18, Y+5	; 0x05
    1efe:	fc 01       	movw	r30, r24
    1f00:	20 83       	st	Z, r18
        task_array[task_number].state = default_state;
    1f02:	80 91 27 03 	lds	r24, 0x0327	; 0x800327 <task_number>
    1f06:	28 2f       	mov	r18, r24
    1f08:	30 e0       	ldi	r19, 0x00	; 0
    1f0a:	c9 01       	movw	r24, r18
    1f0c:	88 0f       	add	r24, r24
    1f0e:	99 1f       	adc	r25, r25
    1f10:	82 0f       	add	r24, r18
    1f12:	93 1f       	adc	r25, r19
    1f14:	88 0f       	add	r24, r24
    1f16:	99 1f       	adc	r25, r25
    1f18:	81 51       	subi	r24, 0x11	; 17
    1f1a:	9d 4f       	sbci	r25, 0xFD	; 253
    1f1c:	2e 81       	ldd	r18, Y+6	; 0x06
    1f1e:	3f 81       	ldd	r19, Y+7	; 0x07
    1f20:	fc 01       	movw	r30, r24
    1f22:	31 83       	std	Z+1, r19	; 0x01
    1f24:	20 83       	st	Z, r18
        task_array[task_number].time_cnt = 1u;
    1f26:	80 91 27 03 	lds	r24, 0x0327	; 0x800327 <task_number>
    1f2a:	28 2f       	mov	r18, r24
    1f2c:	30 e0       	ldi	r19, 0x00	; 0
    1f2e:	c9 01       	movw	r24, r18
    1f30:	88 0f       	add	r24, r24
    1f32:	99 1f       	adc	r25, r25
    1f34:	82 0f       	add	r24, r18
    1f36:	93 1f       	adc	r25, r19
    1f38:	88 0f       	add	r24, r24
    1f3a:	99 1f       	adc	r25, r25
    1f3c:	82 51       	subi	r24, 0x12	; 18
    1f3e:	9d 4f       	sbci	r25, 0xFD	; 253
    1f40:	21 e0       	ldi	r18, 0x01	; 1
    1f42:	fc 01       	movw	r30, r24
    1f44:	20 83       	st	Z, r18
        task_number++;
    1f46:	80 91 27 03 	lds	r24, 0x0327	; 0x800327 <task_number>
    1f4a:	8f 5f       	subi	r24, 0xFF	; 255
    1f4c:	80 93 27 03 	sts	0x0327, r24	; 0x800327 <task_number>
        ret = OK;
    1f50:	1a 82       	std	Y+2, r1	; 0x02
    1f52:	19 82       	std	Y+1, r1	; 0x01
    }

    return ret;
    1f54:	89 81       	ldd	r24, Y+1	; 0x01
    1f56:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1f58:	27 96       	adiw	r28, 0x07	; 7
    1f5a:	0f b6       	in	r0, 0x3f	; 63
    1f5c:	f8 94       	cli
    1f5e:	de bf       	out	0x3e, r29	; 62
    1f60:	0f be       	out	0x3f, r0	; 63
    1f62:	cd bf       	out	0x3d, r28	; 61
    1f64:	df 91       	pop	r29
    1f66:	cf 91       	pop	r28
    1f68:	08 95       	ret

00001f6a <OS_TaskTimer>:
 *          This function SHALL be called in a timer interrupt.
 * @param   void
 * @return  void
 */
void OS_TaskTimer(void)
{
    1f6a:	cf 93       	push	r28
    1f6c:	df 93       	push	r29
    1f6e:	1f 92       	push	r1
    1f70:	cd b7       	in	r28, 0x3d	; 61
    1f72:	de b7       	in	r29, 0x3e	; 62
    for (uint8_t i = 0u; i < task_number; i++)
    1f74:	19 82       	std	Y+1, r1	; 0x01
    1f76:	6f c0       	rjmp	.+222    	; 0x2056 <OS_TaskTimer+0xec>
    {
        /* Ignore SUSPENDED tasks. */
        if (SUSPENDED != task_array[i].state)
    1f78:	89 81       	ldd	r24, Y+1	; 0x01
    1f7a:	28 2f       	mov	r18, r24
    1f7c:	30 e0       	ldi	r19, 0x00	; 0
    1f7e:	c9 01       	movw	r24, r18
    1f80:	88 0f       	add	r24, r24
    1f82:	99 1f       	adc	r25, r25
    1f84:	82 0f       	add	r24, r18
    1f86:	93 1f       	adc	r25, r19
    1f88:	88 0f       	add	r24, r24
    1f8a:	99 1f       	adc	r25, r25
    1f8c:	81 51       	subi	r24, 0x11	; 17
    1f8e:	9d 4f       	sbci	r25, 0xFD	; 253
    1f90:	fc 01       	movw	r30, r24
    1f92:	80 81       	ld	r24, Z
    1f94:	91 81       	ldd	r25, Z+1	; 0x01
    1f96:	02 97       	sbiw	r24, 0x02	; 2
    1f98:	09 f4       	brne	.+2      	; 0x1f9c <OS_TaskTimer+0x32>
    1f9a:	5a c0       	rjmp	.+180    	; 0x2050 <OS_TaskTimer+0xe6>
        {
            /* Put it into READY state. */
            if (task_array[i].time_burst <= task_array[i].time_cnt)
    1f9c:	89 81       	ldd	r24, Y+1	; 0x01
    1f9e:	28 2f       	mov	r18, r24
    1fa0:	30 e0       	ldi	r19, 0x00	; 0
    1fa2:	c9 01       	movw	r24, r18
    1fa4:	88 0f       	add	r24, r24
    1fa6:	99 1f       	adc	r25, r25
    1fa8:	82 0f       	add	r24, r18
    1faa:	93 1f       	adc	r25, r19
    1fac:	88 0f       	add	r24, r24
    1fae:	99 1f       	adc	r25, r25
    1fb0:	83 51       	subi	r24, 0x13	; 19
    1fb2:	9d 4f       	sbci	r25, 0xFD	; 253
    1fb4:	fc 01       	movw	r30, r24
    1fb6:	40 81       	ld	r20, Z
    1fb8:	89 81       	ldd	r24, Y+1	; 0x01
    1fba:	28 2f       	mov	r18, r24
    1fbc:	30 e0       	ldi	r19, 0x00	; 0
    1fbe:	c9 01       	movw	r24, r18
    1fc0:	88 0f       	add	r24, r24
    1fc2:	99 1f       	adc	r25, r25
    1fc4:	82 0f       	add	r24, r18
    1fc6:	93 1f       	adc	r25, r19
    1fc8:	88 0f       	add	r24, r24
    1fca:	99 1f       	adc	r25, r25
    1fcc:	82 51       	subi	r24, 0x12	; 18
    1fce:	9d 4f       	sbci	r25, 0xFD	; 253
    1fd0:	fc 01       	movw	r30, r24
    1fd2:	80 81       	ld	r24, Z
    1fd4:	84 17       	cp	r24, r20
    1fd6:	08 f1       	brcs	.+66     	; 0x201a <OS_TaskTimer+0xb0>
            {
                task_array[i].time_cnt = 1u;
    1fd8:	89 81       	ldd	r24, Y+1	; 0x01
    1fda:	28 2f       	mov	r18, r24
    1fdc:	30 e0       	ldi	r19, 0x00	; 0
    1fde:	c9 01       	movw	r24, r18
    1fe0:	88 0f       	add	r24, r24
    1fe2:	99 1f       	adc	r25, r25
    1fe4:	82 0f       	add	r24, r18
    1fe6:	93 1f       	adc	r25, r19
    1fe8:	88 0f       	add	r24, r24
    1fea:	99 1f       	adc	r25, r25
    1fec:	82 51       	subi	r24, 0x12	; 18
    1fee:	9d 4f       	sbci	r25, 0xFD	; 253
    1ff0:	21 e0       	ldi	r18, 0x01	; 1
    1ff2:	fc 01       	movw	r30, r24
    1ff4:	20 83       	st	Z, r18
                task_array[i].state	= READY;
    1ff6:	89 81       	ldd	r24, Y+1	; 0x01
    1ff8:	28 2f       	mov	r18, r24
    1ffa:	30 e0       	ldi	r19, 0x00	; 0
    1ffc:	c9 01       	movw	r24, r18
    1ffe:	88 0f       	add	r24, r24
    2000:	99 1f       	adc	r25, r25
    2002:	82 0f       	add	r24, r18
    2004:	93 1f       	adc	r25, r19
    2006:	88 0f       	add	r24, r24
    2008:	99 1f       	adc	r25, r25
    200a:	81 51       	subi	r24, 0x11	; 17
    200c:	9d 4f       	sbci	r25, 0xFD	; 253
    200e:	21 e0       	ldi	r18, 0x01	; 1
    2010:	30 e0       	ldi	r19, 0x00	; 0
    2012:	fc 01       	movw	r30, r24
    2014:	31 83       	std	Z+1, r19	; 0x01
    2016:	20 83       	st	Z, r18
    2018:	1b c0       	rjmp	.+54     	; 0x2050 <OS_TaskTimer+0xe6>
            }
            /* Or keep counting. */
            else
            {
                task_array[i].time_cnt++;
    201a:	89 81       	ldd	r24, Y+1	; 0x01
    201c:	28 2f       	mov	r18, r24
    201e:	30 e0       	ldi	r19, 0x00	; 0
    2020:	c9 01       	movw	r24, r18
    2022:	88 0f       	add	r24, r24
    2024:	99 1f       	adc	r25, r25
    2026:	82 0f       	add	r24, r18
    2028:	93 1f       	adc	r25, r19
    202a:	88 0f       	add	r24, r24
    202c:	99 1f       	adc	r25, r25
    202e:	82 51       	subi	r24, 0x12	; 18
    2030:	9d 4f       	sbci	r25, 0xFD	; 253
    2032:	fc 01       	movw	r30, r24
    2034:	80 81       	ld	r24, Z
    2036:	41 e0       	ldi	r20, 0x01	; 1
    2038:	48 0f       	add	r20, r24
    203a:	c9 01       	movw	r24, r18
    203c:	88 0f       	add	r24, r24
    203e:	99 1f       	adc	r25, r25
    2040:	82 0f       	add	r24, r18
    2042:	93 1f       	adc	r25, r19
    2044:	88 0f       	add	r24, r24
    2046:	99 1f       	adc	r25, r25
    2048:	82 51       	subi	r24, 0x12	; 18
    204a:	9d 4f       	sbci	r25, 0xFD	; 253
    204c:	fc 01       	movw	r30, r24
    204e:	40 83       	st	Z, r20
 * @param   void
 * @return  void
 */
void OS_TaskTimer(void)
{
    for (uint8_t i = 0u; i < task_number; i++)
    2050:	89 81       	ldd	r24, Y+1	; 0x01
    2052:	8f 5f       	subi	r24, 0xFF	; 255
    2054:	89 83       	std	Y+1, r24	; 0x01
    2056:	80 91 27 03 	lds	r24, 0x0327	; 0x800327 <task_number>
    205a:	99 81       	ldd	r25, Y+1	; 0x01
    205c:	98 17       	cp	r25, r24
    205e:	08 f4       	brcc	.+2      	; 0x2062 <OS_TaskTimer+0xf8>
    2060:	8b cf       	rjmp	.-234    	; 0x1f78 <OS_TaskTimer+0xe>
            {
                task_array[i].time_cnt++;
            }
        }
    }
}
    2062:	00 00       	nop
    2064:	0f 90       	pop	r0
    2066:	df 91       	pop	r29
    2068:	cf 91       	pop	r28
    206a:	08 95       	ret

0000206c <OS_TaskExecution>:
 *          This function SHALL be called in the infinite loop.
 * @param   void
 * @return  void
 */
void OS_TaskExecution(void)
{
    206c:	cf 93       	push	r28
    206e:	df 93       	push	r29
    2070:	1f 92       	push	r1
    2072:	cd b7       	in	r28, 0x3d	; 61
    2074:	de b7       	in	r29, 0x3e	; 62
    for (uint8_t i = 0u; i < task_number; i++)
    2076:	19 82       	std	Y+1, r1	; 0x01
    2078:	34 c0       	rjmp	.+104    	; 0x20e2 <OS_TaskExecution+0x76>
    {
        /* If it is ready, then call it.*/
        if (READY == task_array[i].state)
    207a:	89 81       	ldd	r24, Y+1	; 0x01
    207c:	28 2f       	mov	r18, r24
    207e:	30 e0       	ldi	r19, 0x00	; 0
    2080:	c9 01       	movw	r24, r18
    2082:	88 0f       	add	r24, r24
    2084:	99 1f       	adc	r25, r25
    2086:	82 0f       	add	r24, r18
    2088:	93 1f       	adc	r25, r19
    208a:	88 0f       	add	r24, r24
    208c:	99 1f       	adc	r25, r25
    208e:	81 51       	subi	r24, 0x11	; 17
    2090:	9d 4f       	sbci	r25, 0xFD	; 253
    2092:	fc 01       	movw	r30, r24
    2094:	80 81       	ld	r24, Z
    2096:	91 81       	ldd	r25, Z+1	; 0x01
    2098:	01 97       	sbiw	r24, 0x01	; 1
    209a:	01 f5       	brne	.+64     	; 0x20dc <OS_TaskExecution+0x70>
        {
            task_array[i].function();
    209c:	89 81       	ldd	r24, Y+1	; 0x01
    209e:	28 2f       	mov	r18, r24
    20a0:	30 e0       	ldi	r19, 0x00	; 0
    20a2:	c9 01       	movw	r24, r18
    20a4:	88 0f       	add	r24, r24
    20a6:	99 1f       	adc	r25, r25
    20a8:	82 0f       	add	r24, r18
    20aa:	93 1f       	adc	r25, r19
    20ac:	88 0f       	add	r24, r24
    20ae:	99 1f       	adc	r25, r25
    20b0:	85 51       	subi	r24, 0x15	; 21
    20b2:	9d 4f       	sbci	r25, 0xFD	; 253
    20b4:	fc 01       	movw	r30, r24
    20b6:	80 81       	ld	r24, Z
    20b8:	91 81       	ldd	r25, Z+1	; 0x01
    20ba:	fc 01       	movw	r30, r24
    20bc:	09 95       	icall
            task_array[i].state = BLOCKED;
    20be:	89 81       	ldd	r24, Y+1	; 0x01
    20c0:	28 2f       	mov	r18, r24
    20c2:	30 e0       	ldi	r19, 0x00	; 0
    20c4:	c9 01       	movw	r24, r18
    20c6:	88 0f       	add	r24, r24
    20c8:	99 1f       	adc	r25, r25
    20ca:	82 0f       	add	r24, r18
    20cc:	93 1f       	adc	r25, r19
    20ce:	88 0f       	add	r24, r24
    20d0:	99 1f       	adc	r25, r25
    20d2:	81 51       	subi	r24, 0x11	; 17
    20d4:	9d 4f       	sbci	r25, 0xFD	; 253
    20d6:	fc 01       	movw	r30, r24
    20d8:	11 82       	std	Z+1, r1	; 0x01
    20da:	10 82       	st	Z, r1
 * @param   void
 * @return  void
 */
void OS_TaskExecution(void)
{
    for (uint8_t i = 0u; i < task_number; i++)
    20dc:	89 81       	ldd	r24, Y+1	; 0x01
    20de:	8f 5f       	subi	r24, 0xFF	; 255
    20e0:	89 83       	std	Y+1, r24	; 0x01
    20e2:	80 91 27 03 	lds	r24, 0x0327	; 0x800327 <task_number>
    20e6:	99 81       	ldd	r25, Y+1	; 0x01
    20e8:	98 17       	cp	r25, r24
    20ea:	38 f2       	brcs	.-114    	; 0x207a <OS_TaskExecution+0xe>
        {
            task_array[i].function();
            task_array[i].state = BLOCKED;
        }
    }
}
    20ec:	00 00       	nop
    20ee:	0f 90       	pop	r0
    20f0:	df 91       	pop	r29
    20f2:	cf 91       	pop	r28
    20f4:	08 95       	ret

000020f6 <OS_GetTaskSate>:
 * @brief   Returns the state of the task.
 * @param   task_number: Which task's state.
 * @return  OS_state: state of the task.
 */
OS_state OS_GetTaskSate(uint8_t task_number)
{
    20f6:	cf 93       	push	r28
    20f8:	df 93       	push	r29
    20fa:	1f 92       	push	r1
    20fc:	cd b7       	in	r28, 0x3d	; 61
    20fe:	de b7       	in	r29, 0x3e	; 62
    2100:	89 83       	std	Y+1, r24	; 0x01
    return task_array[task_number].state;
    2102:	89 81       	ldd	r24, Y+1	; 0x01
    2104:	28 2f       	mov	r18, r24
    2106:	30 e0       	ldi	r19, 0x00	; 0
    2108:	c9 01       	movw	r24, r18
    210a:	88 0f       	add	r24, r24
    210c:	99 1f       	adc	r25, r25
    210e:	82 0f       	add	r24, r18
    2110:	93 1f       	adc	r25, r19
    2112:	88 0f       	add	r24, r24
    2114:	99 1f       	adc	r25, r25
    2116:	81 51       	subi	r24, 0x11	; 17
    2118:	9d 4f       	sbci	r25, 0xFD	; 253
    211a:	fc 01       	movw	r30, r24
    211c:	80 81       	ld	r24, Z
    211e:	91 81       	ldd	r25, Z+1	; 0x01
}
    2120:	0f 90       	pop	r0
    2122:	df 91       	pop	r29
    2124:	cf 91       	pop	r28
    2126:	08 95       	ret

00002128 <OS_GetTaskBurstTime>:
 * @brief   Returns the burst time of the task.
 * @param   task_number: Which task's burst time.
 * @return  The burst time.
 */
uint8_t OS_GetTaskBurstTime(uint8_t task_number)
{
    2128:	cf 93       	push	r28
    212a:	df 93       	push	r29
    212c:	1f 92       	push	r1
    212e:	cd b7       	in	r28, 0x3d	; 61
    2130:	de b7       	in	r29, 0x3e	; 62
    2132:	89 83       	std	Y+1, r24	; 0x01
    return task_array[task_number].time_burst;
    2134:	89 81       	ldd	r24, Y+1	; 0x01
    2136:	28 2f       	mov	r18, r24
    2138:	30 e0       	ldi	r19, 0x00	; 0
    213a:	c9 01       	movw	r24, r18
    213c:	88 0f       	add	r24, r24
    213e:	99 1f       	adc	r25, r25
    2140:	82 0f       	add	r24, r18
    2142:	93 1f       	adc	r25, r19
    2144:	88 0f       	add	r24, r24
    2146:	99 1f       	adc	r25, r25
    2148:	83 51       	subi	r24, 0x13	; 19
    214a:	9d 4f       	sbci	r25, 0xFD	; 253
    214c:	fc 01       	movw	r30, r24
    214e:	80 81       	ld	r24, Z
}
    2150:	0f 90       	pop	r0
    2152:	df 91       	pop	r29
    2154:	cf 91       	pop	r28
    2156:	08 95       	ret

00002158 <OS_GetTaskCntTime>:
 * @brief   Returns the current counter value of the task.
 * @param   task_number: Which task's counter.
 * @return  The counter.
 */
uint8_t	OS_GetTaskCntTime(uint8_t task_number)
{
    2158:	cf 93       	push	r28
    215a:	df 93       	push	r29
    215c:	1f 92       	push	r1
    215e:	cd b7       	in	r28, 0x3d	; 61
    2160:	de b7       	in	r29, 0x3e	; 62
    2162:	89 83       	std	Y+1, r24	; 0x01
    return task_array[task_number].time_cnt;
    2164:	89 81       	ldd	r24, Y+1	; 0x01
    2166:	28 2f       	mov	r18, r24
    2168:	30 e0       	ldi	r19, 0x00	; 0
    216a:	c9 01       	movw	r24, r18
    216c:	88 0f       	add	r24, r24
    216e:	99 1f       	adc	r25, r25
    2170:	82 0f       	add	r24, r18
    2172:	93 1f       	adc	r25, r19
    2174:	88 0f       	add	r24, r24
    2176:	99 1f       	adc	r25, r25
    2178:	82 51       	subi	r24, 0x12	; 18
    217a:	9d 4f       	sbci	r25, 0xFD	; 253
    217c:	fc 01       	movw	r30, r24
    217e:	80 81       	ld	r24, Z
}
    2180:	0f 90       	pop	r0
    2182:	df 91       	pop	r29
    2184:	cf 91       	pop	r28
    2186:	08 95       	ret

00002188 <OS_SetTaskSate>:
 * @param   task_number: Which task's new state.
 * @param   new_state: The new state of the task.
 * @return  void
 */
void OS_SetTaskSate(uint8_t task_number, OS_state new_state)
{
    2188:	cf 93       	push	r28
    218a:	df 93       	push	r29
    218c:	00 d0       	rcall	.+0      	; 0x218e <OS_SetTaskSate+0x6>
    218e:	1f 92       	push	r1
    2190:	cd b7       	in	r28, 0x3d	; 61
    2192:	de b7       	in	r29, 0x3e	; 62
    2194:	89 83       	std	Y+1, r24	; 0x01
    2196:	7b 83       	std	Y+3, r23	; 0x03
    2198:	6a 83       	std	Y+2, r22	; 0x02
    task_array[task_number].state = new_state;
    219a:	89 81       	ldd	r24, Y+1	; 0x01
    219c:	28 2f       	mov	r18, r24
    219e:	30 e0       	ldi	r19, 0x00	; 0
    21a0:	c9 01       	movw	r24, r18
    21a2:	88 0f       	add	r24, r24
    21a4:	99 1f       	adc	r25, r25
    21a6:	82 0f       	add	r24, r18
    21a8:	93 1f       	adc	r25, r19
    21aa:	88 0f       	add	r24, r24
    21ac:	99 1f       	adc	r25, r25
    21ae:	81 51       	subi	r24, 0x11	; 17
    21b0:	9d 4f       	sbci	r25, 0xFD	; 253
    21b2:	2a 81       	ldd	r18, Y+2	; 0x02
    21b4:	3b 81       	ldd	r19, Y+3	; 0x03
    21b6:	fc 01       	movw	r30, r24
    21b8:	31 83       	std	Z+1, r19	; 0x01
    21ba:	20 83       	st	Z, r18
}
    21bc:	00 00       	nop
    21be:	0f 90       	pop	r0
    21c0:	0f 90       	pop	r0
    21c2:	0f 90       	pop	r0
    21c4:	df 91       	pop	r29
    21c6:	cf 91       	pop	r28
    21c8:	08 95       	ret

000021ca <OS_SetTaskBurstTime>:
 * @param   task_number: Which task's new burst time.
 * @param   new_time_burst: The new burst time of the task.
 * @return  void
 */
void OS_SetTaskBurstTime(uint8_t task_number, uint8_t new_time_burst)
{
    21ca:	cf 93       	push	r28
    21cc:	df 93       	push	r29
    21ce:	00 d0       	rcall	.+0      	; 0x21d0 <OS_SetTaskBurstTime+0x6>
    21d0:	cd b7       	in	r28, 0x3d	; 61
    21d2:	de b7       	in	r29, 0x3e	; 62
    21d4:	89 83       	std	Y+1, r24	; 0x01
    21d6:	6a 83       	std	Y+2, r22	; 0x02
    task_array[task_number].time_burst = new_time_burst;
    21d8:	89 81       	ldd	r24, Y+1	; 0x01
    21da:	28 2f       	mov	r18, r24
    21dc:	30 e0       	ldi	r19, 0x00	; 0
    21de:	c9 01       	movw	r24, r18
    21e0:	88 0f       	add	r24, r24
    21e2:	99 1f       	adc	r25, r25
    21e4:	82 0f       	add	r24, r18
    21e6:	93 1f       	adc	r25, r19
    21e8:	88 0f       	add	r24, r24
    21ea:	99 1f       	adc	r25, r25
    21ec:	83 51       	subi	r24, 0x13	; 19
    21ee:	9d 4f       	sbci	r25, 0xFD	; 253
    21f0:	2a 81       	ldd	r18, Y+2	; 0x02
    21f2:	fc 01       	movw	r30, r24
    21f4:	20 83       	st	Z, r18
}
    21f6:	00 00       	nop
    21f8:	0f 90       	pop	r0
    21fa:	0f 90       	pop	r0
    21fc:	df 91       	pop	r29
    21fe:	cf 91       	pop	r28
    2200:	08 95       	ret

00002202 <OS_SetTaskCntTime>:
 * @param   task_number: Which task's new counter value.
 * @param   new_time_cnt: The new counter value of the task.
 * @return  void
 */
void OS_SetTaskCntTime(uint8_t task_number, uint8_t new_time_cnt)
{
    2202:	cf 93       	push	r28
    2204:	df 93       	push	r29
    2206:	00 d0       	rcall	.+0      	; 0x2208 <OS_SetTaskCntTime+0x6>
    2208:	cd b7       	in	r28, 0x3d	; 61
    220a:	de b7       	in	r29, 0x3e	; 62
    220c:	89 83       	std	Y+1, r24	; 0x01
    220e:	6a 83       	std	Y+2, r22	; 0x02
    task_array[task_number].time_cnt = new_time_cnt; 
    2210:	89 81       	ldd	r24, Y+1	; 0x01
    2212:	28 2f       	mov	r18, r24
    2214:	30 e0       	ldi	r19, 0x00	; 0
    2216:	c9 01       	movw	r24, r18
    2218:	88 0f       	add	r24, r24
    221a:	99 1f       	adc	r25, r25
    221c:	82 0f       	add	r24, r18
    221e:	93 1f       	adc	r25, r19
    2220:	88 0f       	add	r24, r24
    2222:	99 1f       	adc	r25, r25
    2224:	82 51       	subi	r24, 0x12	; 18
    2226:	9d 4f       	sbci	r25, 0xFD	; 253
    2228:	2a 81       	ldd	r18, Y+2	; 0x02
    222a:	fc 01       	movw	r30, r24
    222c:	20 83       	st	Z, r18
    222e:	00 00       	nop
    2230:	0f 90       	pop	r0
    2232:	0f 90       	pop	r0
    2234:	df 91       	pop	r29
    2236:	cf 91       	pop	r28
    2238:	08 95       	ret

0000223a <Task0_Blink>:
 * @brief   Changes the state of a pin.
 * @param   void
 * @return  void
 */
void Task0_Blink(void)
{
    223a:	cf 93       	push	r28
    223c:	df 93       	push	r29
    223e:	cd b7       	in	r28, 0x3d	; 61
    2240:	de b7       	in	r29, 0x3e	; 62
    //PORTD ^= (1 << PORTD0);
    ledTog(LEDG);
    2242:	84 e0       	ldi	r24, 0x04	; 4
    2244:	90 e0       	ldi	r25, 0x00	; 0
    2246:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <ledTog>
}
    224a:	00 00       	nop
    224c:	df 91       	pop	r29
    224e:	cf 91       	pop	r28
    2250:	08 95       	ret

00002252 <Task1_Blink>:
 * @brief   Changes the state of a pin.
 * @param   void
 * @return  void
 */
void Task1_Blink(void)
{
    2252:	cf 93       	push	r28
    2254:	df 93       	push	r29
    2256:	cd b7       	in	r28, 0x3d	; 61
    2258:	de b7       	in	r29, 0x3e	; 62
    //PORTD ^= (1 << PORTD1);
    ledTog(LEDR);
    225a:	82 e0       	ldi	r24, 0x02	; 2
    225c:	90 e0       	ldi	r25, 0x00	; 0
    225e:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <ledTog>
}
    2262:	00 00       	nop
    2264:	df 91       	pop	r29
    2266:	cf 91       	pop	r28
    2268:	08 95       	ret

0000226a <Task2_Blink>:
 * @brief   Changes the state of a pin.
 * @param   void
 * @return  void
 */
void Task2_Blink(void)
{
    226a:	cf 93       	push	r28
    226c:	df 93       	push	r29
    226e:	cd b7       	in	r28, 0x3d	; 61
    2270:	de b7       	in	r29, 0x3e	; 62
    //PORTD ^= (1 << PORTD2);
    ledTog(LEDB);
    2272:	83 e0       	ldi	r24, 0x03	; 3
    2274:	90 e0       	ldi	r25, 0x00	; 0
    2276:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <ledTog>
}
    227a:	00 00       	nop
    227c:	df 91       	pop	r29
    227e:	cf 91       	pop	r28
    2280:	08 95       	ret

00002282 <OLED_Init>:
 * Return value : none
 * description  :This function is used to initialize the OLED in the normal mode.
 After initializing the OLED, It clears the OLED and sets the cursor to first line first position. .
 **************************************************************************************************/
void OLED_Init(void)
{
    2282:	cf 93       	push	r28
    2284:	df 93       	push	r29
    2286:	cd b7       	in	r28, 0x3d	; 61
    2288:	de b7       	in	r29, 0x3e	; 62
    i2c_init();
    228a:	0e 94 a7 00 	call	0x14e	; 0x14e <i2c_init>
    
    oledSendCommand(SSD1306_DISPLAY_OFF);
    228e:	8e ea       	ldi	r24, 0xAE	; 174
    2290:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(SSD1306_SET_DISPLAY_CLOCK_DIV_RATIO);
    2294:	85 ed       	ldi	r24, 0xD5	; 213
    2296:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(0x80);
    229a:	80 e8       	ldi	r24, 0x80	; 128
    229c:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(SSD1306_SET_MULTIPLEX_RATIO);
    22a0:	88 ea       	ldi	r24, 0xA8	; 168
    22a2:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(0x3F);
    22a6:	8f e3       	ldi	r24, 0x3F	; 63
    22a8:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(SSD1306_SET_DISPLAY_OFFSET);
    22ac:	83 ed       	ldi	r24, 0xD3	; 211
    22ae:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(0x0);
    22b2:	80 e0       	ldi	r24, 0x00	; 0
    22b4:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(SSD1306_SET_START_LINE | 0x0);
    22b8:	80 e4       	ldi	r24, 0x40	; 64
    22ba:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(SSD1306_CHARGE_PUMP);
    22be:	8d e8       	ldi	r24, 0x8D	; 141
    22c0:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(0x14);
    22c4:	84 e1       	ldi	r24, 0x14	; 20
    22c6:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(SSD1306_MEMORY_ADDR_MODE);
    22ca:	80 e2       	ldi	r24, 0x20	; 32
    22cc:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(0x00);
    22d0:	80 e0       	ldi	r24, 0x00	; 0
    22d2:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(SSD1306_SET_SEGMENT_REMAP | 0x1);
    22d6:	81 ea       	ldi	r24, 0xA1	; 161
    22d8:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(SSD1306_COM_SCAN_DIR_DEC);
    22dc:	88 ec       	ldi	r24, 0xC8	; 200
    22de:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(SSD1306_SET_COM_PINS);
    22e2:	8a ed       	ldi	r24, 0xDA	; 218
    22e4:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(0x12);
    22e8:	82 e1       	ldi	r24, 0x12	; 18
    22ea:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(SSD1306_SET_CONTRAST_CONTROL);
    22ee:	81 e8       	ldi	r24, 0x81	; 129
    22f0:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(0xCF);
    22f4:	8f ec       	ldi	r24, 0xCF	; 207
    22f6:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(SSD1306_SET_PRECHARGE_PERIOD);
    22fa:	89 ed       	ldi	r24, 0xD9	; 217
    22fc:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(0xF1);
    2300:	81 ef       	ldi	r24, 0xF1	; 241
    2302:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(SSD1306_SET_VCOM_DESELECT);
    2306:	8b ed       	ldi	r24, 0xDB	; 219
    2308:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(0x40);
    230c:	80 e4       	ldi	r24, 0x40	; 64
    230e:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(SSD1306_DISPLAY_ALL_ON_RESUME);
    2312:	84 ea       	ldi	r24, 0xA4	; 164
    2314:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(SSD1306_NORMAL_DISPLAY);
    2318:	86 ea       	ldi	r24, 0xA6	; 166
    231a:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(SSD1306_DISPLAY_ON);
    231e:	8f ea       	ldi	r24, 0xAF	; 175
    2320:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    
    OLED_Clear();  /* Clear the complete LCD during init */
    2324:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <OLED_Clear>
}
    2328:	00 00       	nop
    232a:	df 91       	pop	r29
    232c:	cf 91       	pop	r28
    232e:	08 95       	ret

00002330 <OLED_DisplayChar>:
 * Return value    : none
 * description  : This function sends a character to be displayed on LCD.
 Any valid ascii value can be passed to display respective character
 ****************************************************************************************************/
void OLED_DisplayChar(uint8_t ch)
{
    2330:	cf 93       	push	r28
    2332:	df 93       	push	r29
    2334:	00 d0       	rcall	.+0      	; 0x2336 <OLED_DisplayChar+0x6>
    2336:	1f 92       	push	r1
    2338:	cd b7       	in	r28, 0x3d	; 61
    233a:	de b7       	in	r29, 0x3e	; 62
    233c:	8b 83       	std	Y+3, r24	; 0x03
    uint8_t dat,i=0;
    233e:	19 82       	std	Y+1, r1	; 0x01
    
    if(((OledCursorPos+FONT_SIZE)>=128) || (ch=='\n'))
    2340:	80 91 29 03 	lds	r24, 0x0329	; 0x800329 <OledCursorPos>
    2344:	88 2f       	mov	r24, r24
    2346:	90 e0       	ldi	r25, 0x00	; 0
    2348:	05 96       	adiw	r24, 0x05	; 5
    234a:	80 38       	cpi	r24, 0x80	; 128
    234c:	91 05       	cpc	r25, r1
    234e:	1c f4       	brge	.+6      	; 0x2356 <OLED_DisplayChar+0x26>
    2350:	8b 81       	ldd	r24, Y+3	; 0x03
    2352:	8a 30       	cpi	r24, 0x0A	; 10
    2354:	11 f4       	brne	.+4      	; 0x235a <OLED_DisplayChar+0x2a>
    {
        /* If the cursor has reached to end of line on page1
         OR NewLine command is issued Then Move the cursor to next line */
        OLED_GoToNextLine();
    2356:	0e 94 6d 17 	call	0x2eda	; 0x2eda <OLED_GoToNextLine>
    }
    if(ch!='\n') /* TODO */
    235a:	8b 81       	ldd	r24, Y+3	; 0x03
    235c:	8a 30       	cpi	r24, 0x0A	; 10
    235e:	71 f1       	breq	.+92     	; 0x23bc <OLED_DisplayChar+0x8c>
    {
        ch = ch-0x20; // As the lookup table starts from Space(0x20)
    2360:	8b 81       	ldd	r24, Y+3	; 0x03
    2362:	80 52       	subi	r24, 0x20	; 32
    2364:	8b 83       	std	Y+3, r24	; 0x03
        
        while(1)
        {
            dat= OledFontTable[ch][i]; /* Get the data to be displayed for LookUptable*/
    2366:	8b 81       	ldd	r24, Y+3	; 0x03
    2368:	28 2f       	mov	r18, r24
    236a:	30 e0       	ldi	r19, 0x00	; 0
    236c:	89 81       	ldd	r24, Y+1	; 0x01
    236e:	48 2f       	mov	r20, r24
    2370:	50 e0       	ldi	r21, 0x00	; 0
    2372:	c9 01       	movw	r24, r18
    2374:	88 0f       	add	r24, r24
    2376:	99 1f       	adc	r25, r25
    2378:	88 0f       	add	r24, r24
    237a:	99 1f       	adc	r25, r25
    237c:	82 0f       	add	r24, r18
    237e:	93 1f       	adc	r25, r19
    2380:	84 0f       	add	r24, r20
    2382:	95 1f       	adc	r25, r21
    2384:	80 50       	subi	r24, 0x00	; 0
    2386:	9f 4f       	sbci	r25, 0xFF	; 255
    2388:	fc 01       	movw	r30, r24
    238a:	80 81       	ld	r24, Z
    238c:	8a 83       	std	Y+2, r24	; 0x02
            
            
            oledSendByte(dat); /* Display the data and keep track of cursor */
    238e:	8a 81       	ldd	r24, Y+2	; 0x02
    2390:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <oledSendByte>
            OledCursorPos++;
    2394:	80 91 29 03 	lds	r24, 0x0329	; 0x800329 <OledCursorPos>
    2398:	8f 5f       	subi	r24, 0xFF	; 255
    239a:	80 93 29 03 	sts	0x0329, r24	; 0x800329 <OledCursorPos>
            
            i++;
    239e:	89 81       	ldd	r24, Y+1	; 0x01
    23a0:	8f 5f       	subi	r24, 0xFF	; 255
    23a2:	89 83       	std	Y+1, r24	; 0x01
            
            if(i==FONT_SIZE) /* Exit the loop if End of char is encountered */
    23a4:	89 81       	ldd	r24, Y+1	; 0x01
    23a6:	85 30       	cpi	r24, 0x05	; 5
    23a8:	f1 f6       	brne	.-68     	; 0x2366 <OLED_DisplayChar+0x36>
            {
                oledSendByte(0x00); /* Display the data and keep track of cursor */
    23aa:	80 e0       	ldi	r24, 0x00	; 0
    23ac:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <oledSendByte>
                OledCursorPos++;
    23b0:	80 91 29 03 	lds	r24, 0x0329	; 0x800329 <OledCursorPos>
    23b4:	8f 5f       	subi	r24, 0xFF	; 255
    23b6:	80 93 29 03 	sts	0x0329, r24	; 0x800329 <OledCursorPos>
                break;
    23ba:	00 00       	nop
            }
        }
    }
}
    23bc:	00 00       	nop
    23be:	0f 90       	pop	r0
    23c0:	0f 90       	pop	r0
    23c2:	0f 90       	pop	r0
    23c4:	df 91       	pop	r29
    23c6:	cf 91       	pop	r28
    23c8:	08 95       	ret

000023ca <OLED_DisplayString>:
 1.The ptr_stringPointer_u8 points to the first char of the string
 and traverses till the end(NULL CHAR)and displays a char each time.
 ****************************************************************************************************/
#if(Enable_OLED_DisplayString==1)
void OLED_DisplayString(uint8_t *ptr)
{
    23ca:	cf 93       	push	r28
    23cc:	df 93       	push	r29
    23ce:	00 d0       	rcall	.+0      	; 0x23d0 <OLED_DisplayString+0x6>
    23d0:	cd b7       	in	r28, 0x3d	; 61
    23d2:	de b7       	in	r29, 0x3e	; 62
    23d4:	9a 83       	std	Y+2, r25	; 0x02
    23d6:	89 83       	std	Y+1, r24	; 0x01
    while(*ptr)
    23d8:	0b c0       	rjmp	.+22     	; 0x23f0 <OLED_DisplayString+0x26>
        OLED_DisplayChar(*ptr++);
    23da:	89 81       	ldd	r24, Y+1	; 0x01
    23dc:	9a 81       	ldd	r25, Y+2	; 0x02
    23de:	9c 01       	movw	r18, r24
    23e0:	2f 5f       	subi	r18, 0xFF	; 255
    23e2:	3f 4f       	sbci	r19, 0xFF	; 255
    23e4:	3a 83       	std	Y+2, r19	; 0x02
    23e6:	29 83       	std	Y+1, r18	; 0x01
    23e8:	fc 01       	movw	r30, r24
    23ea:	80 81       	ld	r24, Z
    23ec:	0e 94 98 11 	call	0x2330	; 0x2330 <OLED_DisplayChar>
 and traverses till the end(NULL CHAR)and displays a char each time.
 ****************************************************************************************************/
#if(Enable_OLED_DisplayString==1)
void OLED_DisplayString(uint8_t *ptr)
{
    while(*ptr)
    23f0:	89 81       	ldd	r24, Y+1	; 0x01
    23f2:	9a 81       	ldd	r25, Y+2	; 0x02
    23f4:	fc 01       	movw	r30, r24
    23f6:	80 81       	ld	r24, Z
    23f8:	88 23       	and	r24, r24
    23fa:	79 f7       	brne	.-34     	; 0x23da <OLED_DisplayString+0x10>
        OLED_DisplayChar(*ptr++);
}
    23fc:	00 00       	nop
    23fe:	0f 90       	pop	r0
    2400:	0f 90       	pop	r0
    2402:	df 91       	pop	r29
    2404:	cf 91       	pop	r28
    2406:	08 95       	ret

00002408 <OLED_ScrollMessage>:
 If the specified line number is out of range then the message
 will be scrolled on first line
 ****************************************************************************************************/
#if (Enable_OLED_ScrollMessage == 1)
void OLED_ScrollMessage(uint8_t lineNum, char *strptr)
{
    2408:	cf 93       	push	r28
    240a:	df 93       	push	r29
    240c:	cd b7       	in	r28, 0x3d	; 61
    240e:	de b7       	in	r29, 0x3e	; 62
    2410:	e7 97       	sbiw	r28, 0x37	; 55
    2412:	0f b6       	in	r0, 0x3f	; 63
    2414:	f8 94       	cli
    2416:	de bf       	out	0x3e, r29	; 62
    2418:	0f be       	out	0x3f, r0	; 63
    241a:	cd bf       	out	0x3d, r28	; 61
    241c:	8d ab       	std	Y+53, r24	; 0x35
    241e:	7f ab       	std	Y+55, r23	; 0x37
    2420:	6e ab       	std	Y+54, r22	; 0x36
    unsigned char i,j,k,l,cursor,ch;
    
    if(lineNum > 7)
    2422:	8d a9       	ldd	r24, Y+53	; 0x35
    2424:	88 30       	cpi	r24, 0x08	; 8
    2426:	08 f0       	brcs	.+2      	; 0x242a <OLED_ScrollMessage+0x22>
        lineNum = 0; // Select first line if the lineNumberToStartDisplay is out of range
    2428:	1d aa       	std	Y+53, r1	; 0x35
    
    for(i=0;strptr[i];i++)
    242a:	19 82       	std	Y+1, r1	; 0x01
    242c:	d0 c1       	rjmp	.+928    	; 0x27ce <OLED_ScrollMessage+0x3c6>
    {
        /* Loop to display the complete string,    each time 16 chars are displayed and
         pointer is incremented to point to next char */
        
        for(k=0;k<6;k++)
    242e:	1b 82       	std	Y+3, r1	; 0x03
    2430:	c7 c1       	rjmp	.+910    	; 0x27c0 <OLED_ScrollMessage+0x3b8>
        {
            OLED_SetCursor(lineNum,6-k);     //Move the Cursor to first line
    2432:	96 e0       	ldi	r25, 0x06	; 6
    2434:	8b 81       	ldd	r24, Y+3	; 0x03
    2436:	29 2f       	mov	r18, r25
    2438:	28 1b       	sub	r18, r24
    243a:	82 2f       	mov	r24, r18
    243c:	68 2f       	mov	r22, r24
    243e:	8d a9       	ldd	r24, Y+53	; 0x35
    2440:	0e 94 84 17 	call	0x2f08	; 0x2f08 <OLED_SetCursor>
            cursor = 6-k;
    2444:	96 e0       	ldi	r25, 0x06	; 6
    2446:	8b 81       	ldd	r24, Y+3	; 0x03
    2448:	e9 2f       	mov	r30, r25
    244a:	e8 1b       	sub	r30, r24
    244c:	8e 2f       	mov	r24, r30
    244e:	8d 83       	std	Y+5, r24	; 0x05
            
            for(j=0;(strptr[i+j] && (cursor<128));j++)
    2450:	1a 82       	std	Y+2, r1	; 0x02
    2452:	2c c1       	rjmp	.+600    	; 0x26ac <OLED_ScrollMessage+0x2a4>
            {
                ch = strptr[i+j]-0x20;
    2454:	89 81       	ldd	r24, Y+1	; 0x01
    2456:	28 2f       	mov	r18, r24
    2458:	30 e0       	ldi	r19, 0x00	; 0
    245a:	8a 81       	ldd	r24, Y+2	; 0x02
    245c:	88 2f       	mov	r24, r24
    245e:	90 e0       	ldi	r25, 0x00	; 0
    2460:	82 0f       	add	r24, r18
    2462:	93 1f       	adc	r25, r19
    2464:	9c 01       	movw	r18, r24
    2466:	8e a9       	ldd	r24, Y+54	; 0x36
    2468:	9f a9       	ldd	r25, Y+55	; 0x37
    246a:	82 0f       	add	r24, r18
    246c:	93 1f       	adc	r25, r19
    246e:	fc 01       	movw	r30, r24
    2470:	80 81       	ld	r24, Z
    2472:	80 52       	subi	r24, 0x20	; 32
    2474:	8e 83       	std	Y+6, r24	; 0x06
                for(l=0;(l<5) && (cursor<128);l++)//Display first 16 Chars or till Null char is reached
    2476:	1c 82       	std	Y+4, r1	; 0x04
    2478:	1b c0       	rjmp	.+54     	; 0x24b0 <OLED_ScrollMessage+0xa8>
                {
                    oledSendByte(OledFontTable[ch][l]);
    247a:	8e 81       	ldd	r24, Y+6	; 0x06
    247c:	28 2f       	mov	r18, r24
    247e:	30 e0       	ldi	r19, 0x00	; 0
    2480:	8c 81       	ldd	r24, Y+4	; 0x04
    2482:	48 2f       	mov	r20, r24
    2484:	50 e0       	ldi	r21, 0x00	; 0
    2486:	c9 01       	movw	r24, r18
    2488:	88 0f       	add	r24, r24
    248a:	99 1f       	adc	r25, r25
    248c:	88 0f       	add	r24, r24
    248e:	99 1f       	adc	r25, r25
    2490:	82 0f       	add	r24, r18
    2492:	93 1f       	adc	r25, r19
    2494:	84 0f       	add	r24, r20
    2496:	95 1f       	adc	r25, r21
    2498:	80 50       	subi	r24, 0x00	; 0
    249a:	9f 4f       	sbci	r25, 0xFF	; 255
    249c:	fc 01       	movw	r30, r24
    249e:	80 81       	ld	r24, Z
    24a0:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <oledSendByte>
                    cursor++;
    24a4:	8d 81       	ldd	r24, Y+5	; 0x05
    24a6:	8f 5f       	subi	r24, 0xFF	; 255
    24a8:	8d 83       	std	Y+5, r24	; 0x05
            cursor = 6-k;
            
            for(j=0;(strptr[i+j] && (cursor<128));j++)
            {
                ch = strptr[i+j]-0x20;
                for(l=0;(l<5) && (cursor<128);l++)//Display first 16 Chars or till Null char is reached
    24aa:	8c 81       	ldd	r24, Y+4	; 0x04
    24ac:	8f 5f       	subi	r24, 0xFF	; 255
    24ae:	8c 83       	std	Y+4, r24	; 0x04
    24b0:	8c 81       	ldd	r24, Y+4	; 0x04
    24b2:	85 30       	cpi	r24, 0x05	; 5
    24b4:	18 f4       	brcc	.+6      	; 0x24bc <OLED_ScrollMessage+0xb4>
    24b6:	8d 81       	ldd	r24, Y+5	; 0x05
    24b8:	88 23       	and	r24, r24
    24ba:	fc f6       	brge	.-66     	; 0x247a <OLED_ScrollMessage+0x72>
                {
                    oledSendByte(OledFontTable[ch][l]);
                    cursor++;
                }
                
                oledSendByte(0);
    24bc:	80 e0       	ldi	r24, 0x00	; 0
    24be:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <oledSendByte>
    24c2:	80 e0       	ldi	r24, 0x00	; 0
    24c4:	90 e0       	ldi	r25, 0x00	; 0
    24c6:	a0 e2       	ldi	r26, 0x20	; 32
    24c8:	b1 e4       	ldi	r27, 0x41	; 65
    24ca:	8b 87       	std	Y+11, r24	; 0x0b
    24cc:	9c 87       	std	Y+12, r25	; 0x0c
    24ce:	ad 87       	std	Y+13, r26	; 0x0d
    24d0:	be 87       	std	Y+14, r27	; 0x0e
	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint8_t __ticks;
	double __tmp2 ;
	__tmp = ((F_CPU) / 3e6) * __us;
    24d2:	2b ea       	ldi	r18, 0xAB	; 171
    24d4:	3a ea       	ldi	r19, 0xAA	; 170
    24d6:	4a ea       	ldi	r20, 0xAA	; 170
    24d8:	50 e4       	ldi	r21, 0x40	; 64
    24da:	6b 85       	ldd	r22, Y+11	; 0x0b
    24dc:	7c 85       	ldd	r23, Y+12	; 0x0c
    24de:	8d 85       	ldd	r24, Y+13	; 0x0d
    24e0:	9e 85       	ldd	r25, Y+14	; 0x0e
    24e2:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
    24e6:	dc 01       	movw	r26, r24
    24e8:	cb 01       	movw	r24, r22
    24ea:	8f 87       	std	Y+15, r24	; 0x0f
    24ec:	98 8b       	std	Y+16, r25	; 0x10
    24ee:	a9 8b       	std	Y+17, r26	; 0x11
    24f0:	ba 8b       	std	Y+18, r27	; 0x12
	__tmp2 = ((F_CPU) / 4e6) * __us;
    24f2:	20 e0       	ldi	r18, 0x00	; 0
    24f4:	30 e0       	ldi	r19, 0x00	; 0
    24f6:	40 e8       	ldi	r20, 0x80	; 128
    24f8:	50 e4       	ldi	r21, 0x40	; 64
    24fa:	6b 85       	ldd	r22, Y+11	; 0x0b
    24fc:	7c 85       	ldd	r23, Y+12	; 0x0c
    24fe:	8d 85       	ldd	r24, Y+13	; 0x0d
    2500:	9e 85       	ldd	r25, Y+14	; 0x0e
    2502:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
    2506:	dc 01       	movw	r26, r24
    2508:	cb 01       	movw	r24, r22
    250a:	8b 8b       	std	Y+19, r24	; 0x13
    250c:	9c 8b       	std	Y+20, r25	; 0x14
    250e:	ad 8b       	std	Y+21, r26	; 0x15
    2510:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    2512:	20 e0       	ldi	r18, 0x00	; 0
    2514:	30 e0       	ldi	r19, 0x00	; 0
    2516:	40 e8       	ldi	r20, 0x80	; 128
    2518:	5f e3       	ldi	r21, 0x3F	; 63
    251a:	6f 85       	ldd	r22, Y+15	; 0x0f
    251c:	78 89       	ldd	r23, Y+16	; 0x10
    251e:	89 89       	ldd	r24, Y+17	; 0x11
    2520:	9a 89       	ldd	r25, Y+18	; 0x12
    2522:	0e 94 00 1a 	call	0x3400	; 0x3400 <__cmpsf2>
    2526:	88 23       	and	r24, r24
    2528:	1c f4       	brge	.+6      	; 0x2530 <OLED_ScrollMessage+0x128>
		__ticks = 1;
    252a:	81 e0       	ldi	r24, 0x01	; 1
    252c:	8f 8b       	std	Y+23, r24	; 0x17
    252e:	b2 c0       	rjmp	.+356    	; 0x2694 <OLED_ScrollMessage+0x28c>
	else if (__tmp2 > 65535)
    2530:	20 e0       	ldi	r18, 0x00	; 0
    2532:	3f ef       	ldi	r19, 0xFF	; 255
    2534:	4f e7       	ldi	r20, 0x7F	; 127
    2536:	57 e4       	ldi	r21, 0x47	; 71
    2538:	6b 89       	ldd	r22, Y+19	; 0x13
    253a:	7c 89       	ldd	r23, Y+20	; 0x14
    253c:	8d 89       	ldd	r24, Y+21	; 0x15
    253e:	9e 89       	ldd	r25, Y+22	; 0x16
    2540:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
    2544:	18 16       	cp	r1, r24
    2546:	0c f0       	brlt	.+2      	; 0x254a <OLED_ScrollMessage+0x142>
    2548:	7b c0       	rjmp	.+246    	; 0x2640 <OLED_ScrollMessage+0x238>
	{
		_delay_ms(__us / 1000.0);
    254a:	20 e0       	ldi	r18, 0x00	; 0
    254c:	30 e0       	ldi	r19, 0x00	; 0
    254e:	4a e7       	ldi	r20, 0x7A	; 122
    2550:	54 e4       	ldi	r21, 0x44	; 68
    2552:	6b 85       	ldd	r22, Y+11	; 0x0b
    2554:	7c 85       	ldd	r23, Y+12	; 0x0c
    2556:	8d 85       	ldd	r24, Y+13	; 0x0d
    2558:	9e 85       	ldd	r25, Y+14	; 0x0e
    255a:	0e 94 05 1a 	call	0x340a	; 0x340a <__divsf3>
    255e:	dc 01       	movw	r26, r24
    2560:	cb 01       	movw	r24, r22
    2562:	88 8f       	std	Y+24, r24	; 0x18
    2564:	99 8f       	std	Y+25, r25	; 0x19
    2566:	aa 8f       	std	Y+26, r26	; 0x1a
    2568:	bb 8f       	std	Y+27, r27	; 0x1b

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    256a:	20 e0       	ldi	r18, 0x00	; 0
    256c:	30 e0       	ldi	r19, 0x00	; 0
    256e:	4a e7       	ldi	r20, 0x7A	; 122
    2570:	55 e4       	ldi	r21, 0x45	; 69
    2572:	68 8d       	ldd	r22, Y+24	; 0x18
    2574:	79 8d       	ldd	r23, Y+25	; 0x19
    2576:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2578:	9b 8d       	ldd	r25, Y+27	; 0x1b
    257a:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
    257e:	dc 01       	movw	r26, r24
    2580:	cb 01       	movw	r24, r22
    2582:	8c 8f       	std	Y+28, r24	; 0x1c
    2584:	9d 8f       	std	Y+29, r25	; 0x1d
    2586:	ae 8f       	std	Y+30, r26	; 0x1e
    2588:	bf 8f       	std	Y+31, r27	; 0x1f
	if (__tmp < 1.0)
    258a:	20 e0       	ldi	r18, 0x00	; 0
    258c:	30 e0       	ldi	r19, 0x00	; 0
    258e:	40 e8       	ldi	r20, 0x80	; 128
    2590:	5f e3       	ldi	r21, 0x3F	; 63
    2592:	6c 8d       	ldd	r22, Y+28	; 0x1c
    2594:	7d 8d       	ldd	r23, Y+29	; 0x1d
    2596:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2598:	9f 8d       	ldd	r25, Y+31	; 0x1f
    259a:	0e 94 00 1a 	call	0x3400	; 0x3400 <__cmpsf2>
    259e:	88 23       	and	r24, r24
    25a0:	2c f4       	brge	.+10     	; 0x25ac <OLED_ScrollMessage+0x1a4>
		__ticks = 1;
    25a2:	81 e0       	ldi	r24, 0x01	; 1
    25a4:	90 e0       	ldi	r25, 0x00	; 0
    25a6:	99 a3       	std	Y+33, r25	; 0x21
    25a8:	88 a3       	std	Y+32, r24	; 0x20
    25aa:	3f c0       	rjmp	.+126    	; 0x262a <OLED_ScrollMessage+0x222>
	else if (__tmp > 65535)
    25ac:	20 e0       	ldi	r18, 0x00	; 0
    25ae:	3f ef       	ldi	r19, 0xFF	; 255
    25b0:	4f e7       	ldi	r20, 0x7F	; 127
    25b2:	57 e4       	ldi	r21, 0x47	; 71
    25b4:	6c 8d       	ldd	r22, Y+28	; 0x1c
    25b6:	7d 8d       	ldd	r23, Y+29	; 0x1d
    25b8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    25ba:	9f 8d       	ldd	r25, Y+31	; 0x1f
    25bc:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
    25c0:	18 16       	cp	r1, r24
    25c2:	4c f5       	brge	.+82     	; 0x2616 <OLED_ScrollMessage+0x20e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    25c4:	20 e0       	ldi	r18, 0x00	; 0
    25c6:	30 e0       	ldi	r19, 0x00	; 0
    25c8:	40 e2       	ldi	r20, 0x20	; 32
    25ca:	51 e4       	ldi	r21, 0x41	; 65
    25cc:	68 8d       	ldd	r22, Y+24	; 0x18
    25ce:	79 8d       	ldd	r23, Y+25	; 0x19
    25d0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    25d2:	9b 8d       	ldd	r25, Y+27	; 0x1b
    25d4:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
    25d8:	dc 01       	movw	r26, r24
    25da:	cb 01       	movw	r24, r22
    25dc:	bc 01       	movw	r22, r24
    25de:	cd 01       	movw	r24, r26
    25e0:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    25e4:	dc 01       	movw	r26, r24
    25e6:	cb 01       	movw	r24, r22
    25e8:	99 a3       	std	Y+33, r25	; 0x21
    25ea:	88 a3       	std	Y+32, r24	; 0x20
    25ec:	0f c0       	rjmp	.+30     	; 0x260c <OLED_ScrollMessage+0x204>
    25ee:	80 e9       	ldi	r24, 0x90	; 144
    25f0:	91 e0       	ldi	r25, 0x01	; 1
    25f2:	9b a3       	std	Y+35, r25	; 0x23
    25f4:	8a a3       	std	Y+34, r24	; 0x22
    25f6:	8a a1       	ldd	r24, Y+34	; 0x22
    25f8:	9b a1       	ldd	r25, Y+35	; 0x23
    25fa:	01 97       	sbiw	r24, 0x01	; 1
    25fc:	f1 f7       	brne	.-4      	; 0x25fa <OLED_ScrollMessage+0x1f2>
    25fe:	9b a3       	std	Y+35, r25	; 0x23
    2600:	8a a3       	std	Y+34, r24	; 0x22
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2602:	88 a1       	ldd	r24, Y+32	; 0x20
    2604:	99 a1       	ldd	r25, Y+33	; 0x21
    2606:	01 97       	sbiw	r24, 0x01	; 1
    2608:	99 a3       	std	Y+33, r25	; 0x21
    260a:	88 a3       	std	Y+32, r24	; 0x20
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    260c:	88 a1       	ldd	r24, Y+32	; 0x20
    260e:	99 a1       	ldd	r25, Y+33	; 0x21
    2610:	89 2b       	or	r24, r25
    2612:	69 f7       	brne	.-38     	; 0x25ee <OLED_ScrollMessage+0x1e6>
    2614:	3f c0       	rjmp	.+126    	; 0x2694 <OLED_ScrollMessage+0x28c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2616:	6c 8d       	ldd	r22, Y+28	; 0x1c
    2618:	7d 8d       	ldd	r23, Y+29	; 0x1d
    261a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    261c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    261e:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    2622:	dc 01       	movw	r26, r24
    2624:	cb 01       	movw	r24, r22
    2626:	99 a3       	std	Y+33, r25	; 0x21
    2628:	88 a3       	std	Y+32, r24	; 0x20
    262a:	88 a1       	ldd	r24, Y+32	; 0x20
    262c:	99 a1       	ldd	r25, Y+33	; 0x21
    262e:	9d a3       	std	Y+37, r25	; 0x25
    2630:	8c a3       	std	Y+36, r24	; 0x24
    2632:	8c a1       	ldd	r24, Y+36	; 0x24
    2634:	9d a1       	ldd	r25, Y+37	; 0x25
    2636:	01 97       	sbiw	r24, 0x01	; 1
    2638:	f1 f7       	brne	.-4      	; 0x2636 <OLED_ScrollMessage+0x22e>
    263a:	9d a3       	std	Y+37, r25	; 0x25
    263c:	8c a3       	std	Y+36, r24	; 0x24
    263e:	2a c0       	rjmp	.+84     	; 0x2694 <OLED_ScrollMessage+0x28c>
		__ticks = 1;
	else if (__tmp2 > 65535)
	{
		_delay_ms(__us / 1000.0);
	}
	else if (__tmp > 255)
    2640:	20 e0       	ldi	r18, 0x00	; 0
    2642:	30 e0       	ldi	r19, 0x00	; 0
    2644:	4f e7       	ldi	r20, 0x7F	; 127
    2646:	53 e4       	ldi	r21, 0x43	; 67
    2648:	6f 85       	ldd	r22, Y+15	; 0x0f
    264a:	78 89       	ldd	r23, Y+16	; 0x10
    264c:	89 89       	ldd	r24, Y+17	; 0x11
    264e:	9a 89       	ldd	r25, Y+18	; 0x12
    2650:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
    2654:	18 16       	cp	r1, r24
    2656:	ac f4       	brge	.+42     	; 0x2682 <OLED_ScrollMessage+0x27a>
	{
		uint16_t __ticks=(uint16_t)__tmp2;
    2658:	6b 89       	ldd	r22, Y+19	; 0x13
    265a:	7c 89       	ldd	r23, Y+20	; 0x14
    265c:	8d 89       	ldd	r24, Y+21	; 0x15
    265e:	9e 89       	ldd	r25, Y+22	; 0x16
    2660:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    2664:	dc 01       	movw	r26, r24
    2666:	cb 01       	movw	r24, r22
    2668:	9f a3       	std	Y+39, r25	; 0x27
    266a:	8e a3       	std	Y+38, r24	; 0x26
    266c:	8e a1       	ldd	r24, Y+38	; 0x26
    266e:	9f a1       	ldd	r25, Y+39	; 0x27
    2670:	99 a7       	std	Y+41, r25	; 0x29
    2672:	88 a7       	std	Y+40, r24	; 0x28
    2674:	88 a5       	ldd	r24, Y+40	; 0x28
    2676:	99 a5       	ldd	r25, Y+41	; 0x29
    2678:	01 97       	sbiw	r24, 0x01	; 1
    267a:	f1 f7       	brne	.-4      	; 0x2678 <OLED_ScrollMessage+0x270>
    267c:	99 a7       	std	Y+41, r25	; 0x29
    267e:	88 a7       	std	Y+40, r24	; 0x28
    2680:	0f c0       	rjmp	.+30     	; 0x26a0 <OLED_ScrollMessage+0x298>
		_delay_loop_2(__ticks);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    2682:	6f 85       	ldd	r22, Y+15	; 0x0f
    2684:	78 89       	ldd	r23, Y+16	; 0x10
    2686:	89 89       	ldd	r24, Y+17	; 0x11
    2688:	9a 89       	ldd	r25, Y+18	; 0x12
    268a:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    268e:	dc 01       	movw	r26, r24
    2690:	cb 01       	movw	r24, r22
    2692:	8f 8b       	std	Y+23, r24	; 0x17
    2694:	8f 89       	ldd	r24, Y+23	; 0x17
    2696:	8a a7       	std	Y+42, r24	; 0x2a
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2698:	8a a5       	ldd	r24, Y+42	; 0x2a
    269a:	8a 95       	dec	r24
    269c:	f1 f7       	brne	.-4      	; 0x269a <OLED_ScrollMessage+0x292>
    269e:	8a a7       	std	Y+42, r24	; 0x2a
                _delay_us(10);
                cursor++;
    26a0:	8d 81       	ldd	r24, Y+5	; 0x05
    26a2:	8f 5f       	subi	r24, 0xFF	; 255
    26a4:	8d 83       	std	Y+5, r24	; 0x05
        for(k=0;k<6;k++)
        {
            OLED_SetCursor(lineNum,6-k);     //Move the Cursor to first line
            cursor = 6-k;
            
            for(j=0;(strptr[i+j] && (cursor<128));j++)
    26a6:	8a 81       	ldd	r24, Y+2	; 0x02
    26a8:	8f 5f       	subi	r24, 0xFF	; 255
    26aa:	8a 83       	std	Y+2, r24	; 0x02
    26ac:	89 81       	ldd	r24, Y+1	; 0x01
    26ae:	28 2f       	mov	r18, r24
    26b0:	30 e0       	ldi	r19, 0x00	; 0
    26b2:	8a 81       	ldd	r24, Y+2	; 0x02
    26b4:	88 2f       	mov	r24, r24
    26b6:	90 e0       	ldi	r25, 0x00	; 0
    26b8:	82 0f       	add	r24, r18
    26ba:	93 1f       	adc	r25, r19
    26bc:	9c 01       	movw	r18, r24
    26be:	8e a9       	ldd	r24, Y+54	; 0x36
    26c0:	9f a9       	ldd	r25, Y+55	; 0x37
    26c2:	82 0f       	add	r24, r18
    26c4:	93 1f       	adc	r25, r19
    26c6:	fc 01       	movw	r30, r24
    26c8:	80 81       	ld	r24, Z
    26ca:	88 23       	and	r24, r24
    26cc:	21 f0       	breq	.+8      	; 0x26d6 <OLED_ScrollMessage+0x2ce>
    26ce:	8d 81       	ldd	r24, Y+5	; 0x05
    26d0:	88 23       	and	r24, r24
    26d2:	0c f0       	brlt	.+2      	; 0x26d6 <OLED_ScrollMessage+0x2ce>
    26d4:	bf ce       	rjmp	.-642    	; 0x2454 <OLED_ScrollMessage+0x4c>
    26d6:	80 e0       	ldi	r24, 0x00	; 0
    26d8:	90 e0       	ldi	r25, 0x00	; 0
    26da:	a0 ea       	ldi	r26, 0xA0	; 160
    26dc:	b1 e4       	ldi	r27, 0x41	; 65
    26de:	8f 83       	std	Y+7, r24	; 0x07
    26e0:	98 87       	std	Y+8, r25	; 0x08
    26e2:	a9 87       	std	Y+9, r26	; 0x09
    26e4:	ba 87       	std	Y+10, r27	; 0x0a

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    26e6:	20 e0       	ldi	r18, 0x00	; 0
    26e8:	30 e0       	ldi	r19, 0x00	; 0
    26ea:	4a e7       	ldi	r20, 0x7A	; 122
    26ec:	55 e4       	ldi	r21, 0x45	; 69
    26ee:	6f 81       	ldd	r22, Y+7	; 0x07
    26f0:	78 85       	ldd	r23, Y+8	; 0x08
    26f2:	89 85       	ldd	r24, Y+9	; 0x09
    26f4:	9a 85       	ldd	r25, Y+10	; 0x0a
    26f6:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
    26fa:	dc 01       	movw	r26, r24
    26fc:	cb 01       	movw	r24, r22
    26fe:	8b a7       	std	Y+43, r24	; 0x2b
    2700:	9c a7       	std	Y+44, r25	; 0x2c
    2702:	ad a7       	std	Y+45, r26	; 0x2d
    2704:	be a7       	std	Y+46, r27	; 0x2e
	if (__tmp < 1.0)
    2706:	20 e0       	ldi	r18, 0x00	; 0
    2708:	30 e0       	ldi	r19, 0x00	; 0
    270a:	40 e8       	ldi	r20, 0x80	; 128
    270c:	5f e3       	ldi	r21, 0x3F	; 63
    270e:	6b a5       	ldd	r22, Y+43	; 0x2b
    2710:	7c a5       	ldd	r23, Y+44	; 0x2c
    2712:	8d a5       	ldd	r24, Y+45	; 0x2d
    2714:	9e a5       	ldd	r25, Y+46	; 0x2e
    2716:	0e 94 00 1a 	call	0x3400	; 0x3400 <__cmpsf2>
    271a:	88 23       	and	r24, r24
    271c:	2c f4       	brge	.+10     	; 0x2728 <OLED_ScrollMessage+0x320>
		__ticks = 1;
    271e:	81 e0       	ldi	r24, 0x01	; 1
    2720:	90 e0       	ldi	r25, 0x00	; 0
    2722:	98 ab       	std	Y+48, r25	; 0x30
    2724:	8f a7       	std	Y+47, r24	; 0x2f
    2726:	3f c0       	rjmp	.+126    	; 0x27a6 <OLED_ScrollMessage+0x39e>
	else if (__tmp > 65535)
    2728:	20 e0       	ldi	r18, 0x00	; 0
    272a:	3f ef       	ldi	r19, 0xFF	; 255
    272c:	4f e7       	ldi	r20, 0x7F	; 127
    272e:	57 e4       	ldi	r21, 0x47	; 71
    2730:	6b a5       	ldd	r22, Y+43	; 0x2b
    2732:	7c a5       	ldd	r23, Y+44	; 0x2c
    2734:	8d a5       	ldd	r24, Y+45	; 0x2d
    2736:	9e a5       	ldd	r25, Y+46	; 0x2e
    2738:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__gesf2>
    273c:	18 16       	cp	r1, r24
    273e:	4c f5       	brge	.+82     	; 0x2792 <OLED_ScrollMessage+0x38a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2740:	20 e0       	ldi	r18, 0x00	; 0
    2742:	30 e0       	ldi	r19, 0x00	; 0
    2744:	40 e2       	ldi	r20, 0x20	; 32
    2746:	51 e4       	ldi	r21, 0x41	; 65
    2748:	6f 81       	ldd	r22, Y+7	; 0x07
    274a:	78 85       	ldd	r23, Y+8	; 0x08
    274c:	89 85       	ldd	r24, Y+9	; 0x09
    274e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2750:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
    2754:	dc 01       	movw	r26, r24
    2756:	cb 01       	movw	r24, r22
    2758:	bc 01       	movw	r22, r24
    275a:	cd 01       	movw	r24, r26
    275c:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    2760:	dc 01       	movw	r26, r24
    2762:	cb 01       	movw	r24, r22
    2764:	98 ab       	std	Y+48, r25	; 0x30
    2766:	8f a7       	std	Y+47, r24	; 0x2f
    2768:	0f c0       	rjmp	.+30     	; 0x2788 <OLED_ScrollMessage+0x380>
    276a:	80 e9       	ldi	r24, 0x90	; 144
    276c:	91 e0       	ldi	r25, 0x01	; 1
    276e:	9a ab       	std	Y+50, r25	; 0x32
    2770:	89 ab       	std	Y+49, r24	; 0x31
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2772:	89 a9       	ldd	r24, Y+49	; 0x31
    2774:	9a a9       	ldd	r25, Y+50	; 0x32
    2776:	01 97       	sbiw	r24, 0x01	; 1
    2778:	f1 f7       	brne	.-4      	; 0x2776 <OLED_ScrollMessage+0x36e>
    277a:	9a ab       	std	Y+50, r25	; 0x32
    277c:	89 ab       	std	Y+49, r24	; 0x31
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    277e:	8f a5       	ldd	r24, Y+47	; 0x2f
    2780:	98 a9       	ldd	r25, Y+48	; 0x30
    2782:	01 97       	sbiw	r24, 0x01	; 1
    2784:	98 ab       	std	Y+48, r25	; 0x30
    2786:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2788:	8f a5       	ldd	r24, Y+47	; 0x2f
    278a:	98 a9       	ldd	r25, Y+48	; 0x30
    278c:	89 2b       	or	r24, r25
    278e:	69 f7       	brne	.-38     	; 0x276a <OLED_ScrollMessage+0x362>
    2790:	14 c0       	rjmp	.+40     	; 0x27ba <OLED_ScrollMessage+0x3b2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2792:	6b a5       	ldd	r22, Y+43	; 0x2b
    2794:	7c a5       	ldd	r23, Y+44	; 0x2c
    2796:	8d a5       	ldd	r24, Y+45	; 0x2d
    2798:	9e a5       	ldd	r25, Y+46	; 0x2e
    279a:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    279e:	dc 01       	movw	r26, r24
    27a0:	cb 01       	movw	r24, r22
    27a2:	98 ab       	std	Y+48, r25	; 0x30
    27a4:	8f a7       	std	Y+47, r24	; 0x2f
    27a6:	8f a5       	ldd	r24, Y+47	; 0x2f
    27a8:	98 a9       	ldd	r25, Y+48	; 0x30
    27aa:	9c ab       	std	Y+52, r25	; 0x34
    27ac:	8b ab       	std	Y+51, r24	; 0x33
    27ae:	8b a9       	ldd	r24, Y+51	; 0x33
    27b0:	9c a9       	ldd	r25, Y+52	; 0x34
    27b2:	01 97       	sbiw	r24, 0x01	; 1
    27b4:	f1 f7       	brne	.-4      	; 0x27b2 <OLED_ScrollMessage+0x3aa>
    27b6:	9c ab       	std	Y+52, r25	; 0x34
    27b8:	8b ab       	std	Y+51, r24	; 0x33
    for(i=0;strptr[i];i++)
    {
        /* Loop to display the complete string,    each time 16 chars are displayed and
         pointer is incremented to point to next char */
        
        for(k=0;k<6;k++)
    27ba:	8b 81       	ldd	r24, Y+3	; 0x03
    27bc:	8f 5f       	subi	r24, 0xFF	; 255
    27be:	8b 83       	std	Y+3, r24	; 0x03
    27c0:	8b 81       	ldd	r24, Y+3	; 0x03
    27c2:	86 30       	cpi	r24, 0x06	; 6
    27c4:	08 f4       	brcc	.+2      	; 0x27c8 <OLED_ScrollMessage+0x3c0>
    27c6:	35 ce       	rjmp	.-918    	; 0x2432 <OLED_ScrollMessage+0x2a>
    unsigned char i,j,k,l,cursor,ch;
    
    if(lineNum > 7)
        lineNum = 0; // Select first line if the lineNumberToStartDisplay is out of range
    
    for(i=0;strptr[i];i++)
    27c8:	89 81       	ldd	r24, Y+1	; 0x01
    27ca:	8f 5f       	subi	r24, 0xFF	; 255
    27cc:	89 83       	std	Y+1, r24	; 0x01
    27ce:	89 81       	ldd	r24, Y+1	; 0x01
    27d0:	88 2f       	mov	r24, r24
    27d2:	90 e0       	ldi	r25, 0x00	; 0
    27d4:	2e a9       	ldd	r18, Y+54	; 0x36
    27d6:	3f a9       	ldd	r19, Y+55	; 0x37
    27d8:	82 0f       	add	r24, r18
    27da:	93 1f       	adc	r25, r19
    27dc:	fc 01       	movw	r30, r24
    27de:	80 81       	ld	r24, Z
    27e0:	88 23       	and	r24, r24
    27e2:	09 f0       	breq	.+2      	; 0x27e6 <OLED_ScrollMessage+0x3de>
    27e4:	24 ce       	rjmp	.-952    	; 0x242e <OLED_ScrollMessage+0x26>
                cursor++;
            }
            _delay_ms(20);
        }
    }
}
    27e6:	00 00       	nop
    27e8:	e7 96       	adiw	r28, 0x37	; 55
    27ea:	0f b6       	in	r0, 0x3f	; 63
    27ec:	f8 94       	cli
    27ee:	de bf       	out	0x3e, r29	; 62
    27f0:	0f be       	out	0x3f, r0	; 63
    27f2:	cd bf       	out	0x3d, r28	; 61
    27f4:	df 91       	pop	r29
    27f6:	cf 91       	pop	r28
    27f8:	08 95       	ret

000027fa <OLED_DisplayNumber>:
 8.(C_HEX_U8,0x12AB,6) then 6-digits ie. 0012AB will be displayed
 9.(C_HEX_U8,0x12AB,C_DisplayDefaultDigits_U8) then 12AB will be displayed.
 ****************************************************************************************************/
#if ((Enable_OLED_DisplayNumber == 1) || (Enable_OLED_DisplayFloatNumber == 1) || (Enable_OLED_Printf==1))
void OLED_DisplayNumber(uint8_t v_numericSystem_u8, uint32_t v_number_u32, uint8_t v_numOfDigitsToDisplay_u8)
{
    27fa:	ff 92       	push	r15
    27fc:	0f 93       	push	r16
    27fe:	1f 93       	push	r17
    2800:	cf 93       	push	r28
    2802:	df 93       	push	r29
    2804:	cd b7       	in	r28, 0x3d	; 61
    2806:	de b7       	in	r29, 0x3e	; 62
    2808:	61 97       	sbiw	r28, 0x11	; 17
    280a:	0f b6       	in	r0, 0x3f	; 63
    280c:	f8 94       	cli
    280e:	de bf       	out	0x3e, r29	; 62
    2810:	0f be       	out	0x3f, r0	; 63
    2812:	cd bf       	out	0x3d, r28	; 61
    2814:	8c 87       	std	Y+12, r24	; 0x0c
    2816:	4d 87       	std	Y+13, r20	; 0x0d
    2818:	5e 87       	std	Y+14, r21	; 0x0e
    281a:	6f 87       	std	Y+15, r22	; 0x0f
    281c:	78 8b       	std	Y+16, r23	; 0x10
    281e:	29 8b       	std	Y+17, r18	; 0x11
    uint8_t i=0,a[10];
    2820:	19 82       	std	Y+1, r1	; 0x01
    
    if(C_BINARY_U8 == v_numericSystem_u8)
    2822:	8c 85       	ldd	r24, Y+12	; 0x0c
    2824:	82 30       	cpi	r24, 0x02	; 2
    2826:	61 f5       	brne	.+88     	; 0x2880 <OLED_DisplayNumber+0x86>
    {
        while(v_numOfDigitsToDisplay_u8!=0)
    2828:	27 c0       	rjmp	.+78     	; 0x2878 <OLED_DisplayNumber+0x7e>
        {
            /* Start Extracting the bits from the specified bit positions.
             Get the Acsii values of the bits and display */
            i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToDisplay_u8-1));
    282a:	89 89       	ldd	r24, Y+17	; 0x11
    282c:	88 2f       	mov	r24, r24
    282e:	90 e0       	ldi	r25, 0x00	; 0
    2830:	9c 01       	movw	r18, r24
    2832:	21 50       	subi	r18, 0x01	; 1
    2834:	31 09       	sbc	r19, r1
    2836:	81 e0       	ldi	r24, 0x01	; 1
    2838:	90 e0       	ldi	r25, 0x00	; 0
    283a:	02 c0       	rjmp	.+4      	; 0x2840 <OLED_DisplayNumber+0x46>
    283c:	88 0f       	add	r24, r24
    283e:	99 1f       	adc	r25, r25
    2840:	2a 95       	dec	r18
    2842:	e2 f7       	brpl	.-8      	; 0x283c <OLED_DisplayNumber+0x42>
    2844:	9c 01       	movw	r18, r24
    2846:	99 0f       	add	r25, r25
    2848:	44 0b       	sbc	r20, r20
    284a:	55 0b       	sbc	r21, r21
    284c:	8d 85       	ldd	r24, Y+13	; 0x0d
    284e:	9e 85       	ldd	r25, Y+14	; 0x0e
    2850:	af 85       	ldd	r26, Y+15	; 0x0f
    2852:	b8 89       	ldd	r27, Y+16	; 0x10
    2854:	82 23       	and	r24, r18
    2856:	93 23       	and	r25, r19
    2858:	a4 23       	and	r26, r20
    285a:	b5 23       	and	r27, r21
    285c:	21 e0       	ldi	r18, 0x01	; 1
    285e:	89 2b       	or	r24, r25
    2860:	8a 2b       	or	r24, r26
    2862:	8b 2b       	or	r24, r27
    2864:	09 f4       	brne	.+2      	; 0x2868 <OLED_DisplayNumber+0x6e>
    2866:	20 e0       	ldi	r18, 0x00	; 0
    2868:	29 83       	std	Y+1, r18	; 0x01
            OLED_DisplayChar(util_Dec2Ascii(i));
    286a:	89 81       	ldd	r24, Y+1	; 0x01
    286c:	80 5d       	subi	r24, 0xD0	; 208
    286e:	0e 94 98 11 	call	0x2330	; 0x2330 <OLED_DisplayChar>
            v_numOfDigitsToDisplay_u8--;
    2872:	89 89       	ldd	r24, Y+17	; 0x11
    2874:	81 50       	subi	r24, 0x01	; 1
    2876:	89 8b       	std	Y+17, r24	; 0x11
{
    uint8_t i=0,a[10];
    
    if(C_BINARY_U8 == v_numericSystem_u8)
    {
        while(v_numOfDigitsToDisplay_u8!=0)
    2878:	89 89       	ldd	r24, Y+17	; 0x11
    287a:	88 23       	and	r24, r24
    287c:	b1 f6       	brne	.-84     	; 0x282a <OLED_DisplayNumber+0x30>
            /* Finally get the ascii values of the digits and display*/
            OLED_DisplayChar(util_Hex2Ascii(a[i-1]));
            i--;
        }
    }
}
    287e:	a0 c0       	rjmp	.+320    	; 0x29c0 <OLED_DisplayNumber+0x1c6>
            i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToDisplay_u8-1));
            OLED_DisplayChar(util_Dec2Ascii(i));
            v_numOfDigitsToDisplay_u8--;
        }
    }
    else if(v_number_u32==0)
    2880:	8d 85       	ldd	r24, Y+13	; 0x0d
    2882:	9e 85       	ldd	r25, Y+14	; 0x0e
    2884:	af 85       	ldd	r26, Y+15	; 0x0f
    2886:	b8 89       	ldd	r27, Y+16	; 0x10
    2888:	89 2b       	or	r24, r25
    288a:	8a 2b       	or	r24, r26
    288c:	8b 2b       	or	r24, r27
    288e:	89 f4       	brne	.+34     	; 0x28b2 <OLED_DisplayNumber+0xb8>
    {
        /* If the number is zero then update the array with the same for displaying */
        for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
    2890:	19 82       	std	Y+1, r1	; 0x01
    2892:	06 c0       	rjmp	.+12     	; 0x28a0 <OLED_DisplayNumber+0xa6>
            OLED_DisplayChar('0');
    2894:	80 e3       	ldi	r24, 0x30	; 48
    2896:	0e 94 98 11 	call	0x2330	; 0x2330 <OLED_DisplayChar>
        }
    }
    else if(v_number_u32==0)
    {
        /* If the number is zero then update the array with the same for displaying */
        for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
    289a:	89 81       	ldd	r24, Y+1	; 0x01
    289c:	8f 5f       	subi	r24, 0xFF	; 255
    289e:	89 83       	std	Y+1, r24	; 0x01
    28a0:	99 81       	ldd	r25, Y+1	; 0x01
    28a2:	89 89       	ldd	r24, Y+17	; 0x11
    28a4:	98 17       	cp	r25, r24
    28a6:	08 f0       	brcs	.+2      	; 0x28aa <OLED_DisplayNumber+0xb0>
    28a8:	8b c0       	rjmp	.+278    	; 0x29c0 <OLED_DisplayNumber+0x1c6>
    28aa:	89 81       	ldd	r24, Y+1	; 0x01
    28ac:	8a 30       	cpi	r24, 0x0A	; 10
    28ae:	90 f3       	brcs	.-28     	; 0x2894 <OLED_DisplayNumber+0x9a>
            /* Finally get the ascii values of the digits and display*/
            OLED_DisplayChar(util_Hex2Ascii(a[i-1]));
            i--;
        }
    }
}
    28b0:	87 c0       	rjmp	.+270    	; 0x29c0 <OLED_DisplayNumber+0x1c6>
        for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
            OLED_DisplayChar('0');
    }
    else
    {
        for(i=0;i<v_numOfDigitsToDisplay_u8;i++)
    28b2:	19 82       	std	Y+1, r1	; 0x01
    28b4:	51 c0       	rjmp	.+162    	; 0x2958 <OLED_DisplayNumber+0x15e>
        {
            /* Continue extracting the digits from right side
             till the Specified v_numOfDigitsToDisplay_u8 */
            if(v_number_u32!=0)
    28b6:	8d 85       	ldd	r24, Y+13	; 0x0d
    28b8:	9e 85       	ldd	r25, Y+14	; 0x0e
    28ba:	af 85       	ldd	r26, Y+15	; 0x0f
    28bc:	b8 89       	ldd	r27, Y+16	; 0x10
    28be:	89 2b       	or	r24, r25
    28c0:	8a 2b       	or	r24, r26
    28c2:	8b 2b       	or	r24, r27
    28c4:	a1 f1       	breq	.+104    	; 0x292e <OLED_DisplayNumber+0x134>
                /* Extract the digits from the number till it becomes zero.
                 First get the remainder and divide the number by TypeOfNum(10-Dec, 16-Hex) each time.
                 example for Decimal number:
                 If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
                 The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(v_number_u32,v_numericSystem_u8);
    28c6:	89 81       	ldd	r24, Y+1	; 0x01
    28c8:	08 2f       	mov	r16, r24
    28ca:	10 e0       	ldi	r17, 0x00	; 0
    28cc:	fd 84       	ldd	r15, Y+13	; 0x0d
    28ce:	8c 85       	ldd	r24, Y+12	; 0x0c
    28d0:	28 2f       	mov	r18, r24
    28d2:	30 e0       	ldi	r19, 0x00	; 0
    28d4:	40 e0       	ldi	r20, 0x00	; 0
    28d6:	50 e0       	ldi	r21, 0x00	; 0
    28d8:	8d 85       	ldd	r24, Y+13	; 0x0d
    28da:	9e 85       	ldd	r25, Y+14	; 0x0e
    28dc:	af 85       	ldd	r26, Y+15	; 0x0f
    28de:	b8 89       	ldd	r27, Y+16	; 0x10
    28e0:	bc 01       	movw	r22, r24
    28e2:	cd 01       	movw	r24, r26
    28e4:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <__udivmodsi4>
    28e8:	da 01       	movw	r26, r20
    28ea:	c9 01       	movw	r24, r18
    28ec:	98 2f       	mov	r25, r24
    28ee:	8c 85       	ldd	r24, Y+12	; 0x0c
    28f0:	98 9f       	mul	r25, r24
    28f2:	80 2d       	mov	r24, r0
    28f4:	11 24       	eor	r1, r1
    28f6:	2f 2d       	mov	r18, r15
    28f8:	28 1b       	sub	r18, r24
    28fa:	ce 01       	movw	r24, r28
    28fc:	02 96       	adiw	r24, 0x02	; 2
    28fe:	80 0f       	add	r24, r16
    2900:	91 1f       	adc	r25, r17
    2902:	fc 01       	movw	r30, r24
    2904:	20 83       	st	Z, r18
                v_number_u32=v_number_u32/v_numericSystem_u8;
    2906:	8c 85       	ldd	r24, Y+12	; 0x0c
    2908:	28 2f       	mov	r18, r24
    290a:	30 e0       	ldi	r19, 0x00	; 0
    290c:	40 e0       	ldi	r20, 0x00	; 0
    290e:	50 e0       	ldi	r21, 0x00	; 0
    2910:	8d 85       	ldd	r24, Y+13	; 0x0d
    2912:	9e 85       	ldd	r25, Y+14	; 0x0e
    2914:	af 85       	ldd	r26, Y+15	; 0x0f
    2916:	b8 89       	ldd	r27, Y+16	; 0x10
    2918:	bc 01       	movw	r22, r24
    291a:	cd 01       	movw	r24, r26
    291c:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <__udivmodsi4>
    2920:	da 01       	movw	r26, r20
    2922:	c9 01       	movw	r24, r18
    2924:	8d 87       	std	Y+13, r24	; 0x0d
    2926:	9e 87       	std	Y+14, r25	; 0x0e
    2928:	af 87       	std	Y+15, r26	; 0x0f
    292a:	b8 8b       	std	Y+16, r27	; 0x10
    292c:	12 c0       	rjmp	.+36     	; 0x2952 <OLED_DisplayNumber+0x158>
            }
            else if( (v_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8) ||
    292e:	89 89       	ldd	r24, Y+17	; 0x11
    2930:	8f 3f       	cpi	r24, 0xFF	; 255
    2932:	09 f4       	brne	.+2      	; 0x2936 <OLED_DisplayNumber+0x13c>
    2934:	42 c0       	rjmp	.+132    	; 0x29ba <OLED_DisplayNumber+0x1c0>
    2936:	89 89       	ldd	r24, Y+17	; 0x11
    2938:	8b 30       	cpi	r24, 0x0B	; 11
    293a:	08 f0       	brcs	.+2      	; 0x293e <OLED_DisplayNumber+0x144>
    293c:	3e c0       	rjmp	.+124    	; 0x29ba <OLED_DisplayNumber+0x1c0>
            else
            {
                /* In case user expects more digits to be displayed than the actual digits in number,
                 then update the remaining digits with zero.
                 Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
                a[i]=0;
    293e:	89 81       	ldd	r24, Y+1	; 0x01
    2940:	88 2f       	mov	r24, r24
    2942:	90 e0       	ldi	r25, 0x00	; 0
    2944:	9e 01       	movw	r18, r28
    2946:	2e 5f       	subi	r18, 0xFE	; 254
    2948:	3f 4f       	sbci	r19, 0xFF	; 255
    294a:	82 0f       	add	r24, r18
    294c:	93 1f       	adc	r25, r19
    294e:	fc 01       	movw	r30, r24
    2950:	10 82       	st	Z, r1
        for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
            OLED_DisplayChar('0');
    }
    else
    {
        for(i=0;i<v_numOfDigitsToDisplay_u8;i++)
    2952:	89 81       	ldd	r24, Y+1	; 0x01
    2954:	8f 5f       	subi	r24, 0xFF	; 255
    2956:	89 83       	std	Y+1, r24	; 0x01
    2958:	99 81       	ldd	r25, Y+1	; 0x01
    295a:	89 89       	ldd	r24, Y+17	; 0x11
    295c:	98 17       	cp	r25, r24
    295e:	08 f4       	brcc	.+2      	; 0x2962 <OLED_DisplayNumber+0x168>
    2960:	aa cf       	rjmp	.-172    	; 0x28b6 <OLED_DisplayNumber+0xbc>
                 Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
                a[i]=0;
            }
        }
        
        while(i!=0)
    2962:	2b c0       	rjmp	.+86     	; 0x29ba <OLED_DisplayNumber+0x1c0>
        {
            /* Finally get the ascii values of the digits and display*/
            OLED_DisplayChar(util_Hex2Ascii(a[i-1]));
    2964:	89 81       	ldd	r24, Y+1	; 0x01
    2966:	88 2f       	mov	r24, r24
    2968:	90 e0       	ldi	r25, 0x00	; 0
    296a:	01 97       	sbiw	r24, 0x01	; 1
    296c:	9e 01       	movw	r18, r28
    296e:	2e 5f       	subi	r18, 0xFE	; 254
    2970:	3f 4f       	sbci	r19, 0xFF	; 255
    2972:	82 0f       	add	r24, r18
    2974:	93 1f       	adc	r25, r19
    2976:	fc 01       	movw	r30, r24
    2978:	80 81       	ld	r24, Z
    297a:	8a 30       	cpi	r24, 0x0A	; 10
    297c:	68 f0       	brcs	.+26     	; 0x2998 <OLED_DisplayNumber+0x19e>
    297e:	89 81       	ldd	r24, Y+1	; 0x01
    2980:	88 2f       	mov	r24, r24
    2982:	90 e0       	ldi	r25, 0x00	; 0
    2984:	01 97       	sbiw	r24, 0x01	; 1
    2986:	9e 01       	movw	r18, r28
    2988:	2e 5f       	subi	r18, 0xFE	; 254
    298a:	3f 4f       	sbci	r19, 0xFF	; 255
    298c:	82 0f       	add	r24, r18
    298e:	93 1f       	adc	r25, r19
    2990:	fc 01       	movw	r30, r24
    2992:	80 81       	ld	r24, Z
    2994:	89 5c       	subi	r24, 0xC9	; 201
    2996:	0c c0       	rjmp	.+24     	; 0x29b0 <OLED_DisplayNumber+0x1b6>
    2998:	89 81       	ldd	r24, Y+1	; 0x01
    299a:	88 2f       	mov	r24, r24
    299c:	90 e0       	ldi	r25, 0x00	; 0
    299e:	01 97       	sbiw	r24, 0x01	; 1
    29a0:	9e 01       	movw	r18, r28
    29a2:	2e 5f       	subi	r18, 0xFE	; 254
    29a4:	3f 4f       	sbci	r19, 0xFF	; 255
    29a6:	82 0f       	add	r24, r18
    29a8:	93 1f       	adc	r25, r19
    29aa:	fc 01       	movw	r30, r24
    29ac:	80 81       	ld	r24, Z
    29ae:	80 5d       	subi	r24, 0xD0	; 208
    29b0:	0e 94 98 11 	call	0x2330	; 0x2330 <OLED_DisplayChar>
            i--;
    29b4:	89 81       	ldd	r24, Y+1	; 0x01
    29b6:	81 50       	subi	r24, 0x01	; 1
    29b8:	89 83       	std	Y+1, r24	; 0x01
                 Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
                a[i]=0;
            }
        }
        
        while(i!=0)
    29ba:	89 81       	ldd	r24, Y+1	; 0x01
    29bc:	88 23       	and	r24, r24
    29be:	91 f6       	brne	.-92     	; 0x2964 <OLED_DisplayNumber+0x16a>
            /* Finally get the ascii values of the digits and display*/
            OLED_DisplayChar(util_Hex2Ascii(a[i-1]));
            i--;
        }
    }
}
    29c0:	00 00       	nop
    29c2:	61 96       	adiw	r28, 0x11	; 17
    29c4:	0f b6       	in	r0, 0x3f	; 63
    29c6:	f8 94       	cli
    29c8:	de bf       	out	0x3e, r29	; 62
    29ca:	0f be       	out	0x3f, r0	; 63
    29cc:	cd bf       	out	0x3d, r28	; 61
    29ce:	df 91       	pop	r29
    29d0:	cf 91       	pop	r28
    29d2:	1f 91       	pop	r17
    29d4:	0f 91       	pop	r16
    29d6:	ff 90       	pop	r15
    29d8:	08 95       	ret

000029da <OLED_DisplayFloatNumber>:
 Note: Float will be disabled by default as it takes huge controller resources
 It can be enabled by changing value of Enable_OLED_DisplayFloatNumber to 1 in lcd.h
 ***************************************************************************************************/
#if (Enable_OLED_DisplayFloatNumber == 1)
void OLED_DisplayFloatNumber(double v_floatNum_f32)
{
    29da:	cf 93       	push	r28
    29dc:	df 93       	push	r29
    29de:	cd b7       	in	r28, 0x3d	; 61
    29e0:	de b7       	in	r29, 0x3e	; 62
    29e2:	28 97       	sbiw	r28, 0x08	; 8
    29e4:	0f b6       	in	r0, 0x3f	; 63
    29e6:	f8 94       	cli
    29e8:	de bf       	out	0x3e, r29	; 62
    29ea:	0f be       	out	0x3f, r0	; 63
    29ec:	cd bf       	out	0x3d, r28	; 61
    29ee:	6d 83       	std	Y+5, r22	; 0x05
    29f0:	7e 83       	std	Y+6, r23	; 0x06
    29f2:	8f 83       	std	Y+7, r24	; 0x07
    29f4:	98 87       	std	Y+8, r25	; 0x08
     1.Type cast the number to int to get the integer part.
     2.Display the extracted integer part followed by a decimal point(.)
     3.Later the integer part is made zero by subtracting with the extracted integer value.
     4.Finally the fractional part is multiplied by 100000 to support 6-digit precision */
    
    v_temp_u32 = (uint32_t) v_floatNum_f32;
    29f6:	6d 81       	ldd	r22, Y+5	; 0x05
    29f8:	7e 81       	ldd	r23, Y+6	; 0x06
    29fa:	8f 81       	ldd	r24, Y+7	; 0x07
    29fc:	98 85       	ldd	r25, Y+8	; 0x08
    29fe:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    2a02:	dc 01       	movw	r26, r24
    2a04:	cb 01       	movw	r24, r22
    2a06:	89 83       	std	Y+1, r24	; 0x01
    2a08:	9a 83       	std	Y+2, r25	; 0x02
    2a0a:	ab 83       	std	Y+3, r26	; 0x03
    2a0c:	bc 83       	std	Y+4, r27	; 0x04
    OLED_DisplayNumber(C_DECIMAL_U8,v_temp_u32,C_DisplayDefaultDigits_U8);
    2a0e:	89 81       	ldd	r24, Y+1	; 0x01
    2a10:	9a 81       	ldd	r25, Y+2	; 0x02
    2a12:	ab 81       	ldd	r26, Y+3	; 0x03
    2a14:	bc 81       	ldd	r27, Y+4	; 0x04
    2a16:	2f ef       	ldi	r18, 0xFF	; 255
    2a18:	ac 01       	movw	r20, r24
    2a1a:	bd 01       	movw	r22, r26
    2a1c:	8a e0       	ldi	r24, 0x0A	; 10
    2a1e:	0e 94 fd 13 	call	0x27fa	; 0x27fa <OLED_DisplayNumber>
    
    OLED_DisplayChar('.');
    2a22:	8e e2       	ldi	r24, 0x2E	; 46
    2a24:	0e 94 98 11 	call	0x2330	; 0x2330 <OLED_DisplayChar>
    
    v_floatNum_f32 = v_floatNum_f32 - v_temp_u32;
    2a28:	69 81       	ldd	r22, Y+1	; 0x01
    2a2a:	7a 81       	ldd	r23, Y+2	; 0x02
    2a2c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a2e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a30:	0e 94 a6 1a 	call	0x354c	; 0x354c <__floatunsisf>
    2a34:	dc 01       	movw	r26, r24
    2a36:	cb 01       	movw	r24, r22
    2a38:	9c 01       	movw	r18, r24
    2a3a:	ad 01       	movw	r20, r26
    2a3c:	6d 81       	ldd	r22, Y+5	; 0x05
    2a3e:	7e 81       	ldd	r23, Y+6	; 0x06
    2a40:	8f 81       	ldd	r24, Y+7	; 0x07
    2a42:	98 85       	ldd	r25, Y+8	; 0x08
    2a44:	0e 94 93 19 	call	0x3326	; 0x3326 <__subsf3>
    2a48:	dc 01       	movw	r26, r24
    2a4a:	cb 01       	movw	r24, r22
    2a4c:	8d 83       	std	Y+5, r24	; 0x05
    2a4e:	9e 83       	std	Y+6, r25	; 0x06
    2a50:	af 83       	std	Y+7, r26	; 0x07
    2a52:	b8 87       	std	Y+8, r27	; 0x08
    v_temp_u32 = v_floatNum_f32 * 1000000;
    2a54:	20 e0       	ldi	r18, 0x00	; 0
    2a56:	34 e2       	ldi	r19, 0x24	; 36
    2a58:	44 e7       	ldi	r20, 0x74	; 116
    2a5a:	59 e4       	ldi	r21, 0x49	; 73
    2a5c:	6d 81       	ldd	r22, Y+5	; 0x05
    2a5e:	7e 81       	ldd	r23, Y+6	; 0x06
    2a60:	8f 81       	ldd	r24, Y+7	; 0x07
    2a62:	98 85       	ldd	r25, Y+8	; 0x08
    2a64:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__mulsf3>
    2a68:	dc 01       	movw	r26, r24
    2a6a:	cb 01       	movw	r24, r22
    2a6c:	bc 01       	movw	r22, r24
    2a6e:	cd 01       	movw	r24, r26
    2a70:	0e 94 77 1a 	call	0x34ee	; 0x34ee <__fixunssfsi>
    2a74:	dc 01       	movw	r26, r24
    2a76:	cb 01       	movw	r24, r22
    2a78:	89 83       	std	Y+1, r24	; 0x01
    2a7a:	9a 83       	std	Y+2, r25	; 0x02
    2a7c:	ab 83       	std	Y+3, r26	; 0x03
    2a7e:	bc 83       	std	Y+4, r27	; 0x04
    OLED_DisplayNumber(C_DECIMAL_U8,v_temp_u32,C_DisplayDefaultDigits_U8);
    2a80:	89 81       	ldd	r24, Y+1	; 0x01
    2a82:	9a 81       	ldd	r25, Y+2	; 0x02
    2a84:	ab 81       	ldd	r26, Y+3	; 0x03
    2a86:	bc 81       	ldd	r27, Y+4	; 0x04
    2a88:	2f ef       	ldi	r18, 0xFF	; 255
    2a8a:	ac 01       	movw	r20, r24
    2a8c:	bd 01       	movw	r22, r26
    2a8e:	8a e0       	ldi	r24, 0x0A	; 10
    2a90:	0e 94 fd 13 	call	0x27fa	; 0x27fa <OLED_DisplayNumber>
}
    2a94:	00 00       	nop
    2a96:	28 96       	adiw	r28, 0x08	; 8
    2a98:	0f b6       	in	r0, 0x3f	; 63
    2a9a:	f8 94       	cli
    2a9c:	de bf       	out	0x3e, r29	; 62
    2a9e:	0f be       	out	0x3f, r0	; 63
    2aa0:	cd bf       	out	0x3d, r28	; 61
    2aa2:	df 91       	pop	r29
    2aa4:	cf 91       	pop	r28
    2aa6:	08 95       	ret

00002aa8 <OLED_Printf>:
 uint8_t v_Num_u8;
 OLED_Printf("num1:%u",(uint16_t)v_Num_u8);
 **************************************************************************************************/
#if ( Enable_OLED_Printf == 1 )
void OLED_Printf(const char *argList, ...)
{
    2aa8:	cf 93       	push	r28
    2aaa:	df 93       	push	r29
    2aac:	cd b7       	in	r28, 0x3d	; 61
    2aae:	de b7       	in	r29, 0x3e	; 62
    2ab0:	68 97       	sbiw	r28, 0x18	; 24
    2ab2:	0f b6       	in	r0, 0x3f	; 63
    2ab4:	f8 94       	cli
    2ab6:	de bf       	out	0x3e, r29	; 62
    2ab8:	0f be       	out	0x3f, r0	; 63
    2aba:	cd bf       	out	0x3d, r28	; 61
    uint8_t v_numOfDigitsToDisp_u8;
#if (Enable_OLED_DisplayFloatNumber == 1)
    double v_floatNum_f32;
#endif
    
    va_start(argp, argList);
    2abc:	ce 01       	movw	r24, r28
    2abe:	4f 96       	adiw	r24, 0x1f	; 31
    2ac0:	98 8f       	std	Y+24, r25	; 0x18
    2ac2:	8f 8b       	std	Y+23, r24	; 0x17
    
    /* Loop through the list to extract all the input arguments */
    for(ptr = argList; *ptr != '\0'; ptr++)
    2ac4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2ac6:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2ac8:	9a 83       	std	Y+2, r25	; 0x02
    2aca:	89 83       	std	Y+1, r24	; 0x01
    2acc:	94 c1       	rjmp	.+808    	; 0x2df6 <OLED_Printf+0x34e>
    {
        
        ch= *ptr;
    2ace:	89 81       	ldd	r24, Y+1	; 0x01
    2ad0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ad2:	fc 01       	movw	r30, r24
    2ad4:	80 81       	ld	r24, Z
    2ad6:	89 87       	std	Y+9, r24	; 0x09
        if(ch == '%')         /*Check for '%' as there will be format specifier after it */
    2ad8:	89 85       	ldd	r24, Y+9	; 0x09
    2ada:	85 32       	cpi	r24, 0x25	; 37
    2adc:	09 f0       	breq	.+2      	; 0x2ae0 <OLED_Printf+0x38>
    2ade:	83 c1       	rjmp	.+774    	; 0x2de6 <OLED_Printf+0x33e>
        {
            ptr++;
    2ae0:	89 81       	ldd	r24, Y+1	; 0x01
    2ae2:	9a 81       	ldd	r25, Y+2	; 0x02
    2ae4:	01 96       	adiw	r24, 0x01	; 1
    2ae6:	9a 83       	std	Y+2, r25	; 0x02
    2ae8:	89 83       	std	Y+1, r24	; 0x01
            ch = *ptr;
    2aea:	89 81       	ldd	r24, Y+1	; 0x01
    2aec:	9a 81       	ldd	r25, Y+2	; 0x02
    2aee:	fc 01       	movw	r30, r24
    2af0:	80 81       	ld	r24, Z
    2af2:	89 87       	std	Y+9, r24	; 0x09
            if((ch>=0x30) && (ch<=0x39))
    2af4:	89 85       	ldd	r24, Y+9	; 0x09
    2af6:	80 33       	cpi	r24, 0x30	; 48
    2af8:	04 f1       	brlt	.+64     	; 0x2b3a <OLED_Printf+0x92>
    2afa:	89 85       	ldd	r24, Y+9	; 0x09
    2afc:	8a 33       	cpi	r24, 0x3A	; 58
    2afe:	ec f4       	brge	.+58     	; 0x2b3a <OLED_Printf+0x92>
            {
                v_numOfDigitsToDisp_u8 = 0;
    2b00:	1a 86       	std	Y+10, r1	; 0x0a
                while((ch>=0x30) && (ch<=0x39))
    2b02:	14 c0       	rjmp	.+40     	; 0x2b2c <OLED_Printf+0x84>
                {
                    v_numOfDigitsToDisp_u8 = (v_numOfDigitsToDisp_u8 * 10) + (ch-0x30);
    2b04:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b06:	88 0f       	add	r24, r24
    2b08:	98 2f       	mov	r25, r24
    2b0a:	99 0f       	add	r25, r25
    2b0c:	99 0f       	add	r25, r25
    2b0e:	98 0f       	add	r25, r24
    2b10:	89 85       	ldd	r24, Y+9	; 0x09
    2b12:	89 0f       	add	r24, r25
    2b14:	80 53       	subi	r24, 0x30	; 48
    2b16:	8a 87       	std	Y+10, r24	; 0x0a
                    ptr++;
    2b18:	89 81       	ldd	r24, Y+1	; 0x01
    2b1a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b1c:	01 96       	adiw	r24, 0x01	; 1
    2b1e:	9a 83       	std	Y+2, r25	; 0x02
    2b20:	89 83       	std	Y+1, r24	; 0x01
                    ch = *ptr;
    2b22:	89 81       	ldd	r24, Y+1	; 0x01
    2b24:	9a 81       	ldd	r25, Y+2	; 0x02
    2b26:	fc 01       	movw	r30, r24
    2b28:	80 81       	ld	r24, Z
    2b2a:	89 87       	std	Y+9, r24	; 0x09
            ptr++;
            ch = *ptr;
            if((ch>=0x30) && (ch<=0x39))
            {
                v_numOfDigitsToDisp_u8 = 0;
                while((ch>=0x30) && (ch<=0x39))
    2b2c:	89 85       	ldd	r24, Y+9	; 0x09
    2b2e:	80 33       	cpi	r24, 0x30	; 48
    2b30:	3c f0       	brlt	.+14     	; 0x2b40 <OLED_Printf+0x98>
    2b32:	89 85       	ldd	r24, Y+9	; 0x09
    2b34:	8a 33       	cpi	r24, 0x3A	; 58
    2b36:	34 f3       	brlt	.-52     	; 0x2b04 <OLED_Printf+0x5c>
        ch= *ptr;
        if(ch == '%')         /*Check for '%' as there will be format specifier after it */
        {
            ptr++;
            ch = *ptr;
            if((ch>=0x30) && (ch<=0x39))
    2b38:	03 c0       	rjmp	.+6      	; 0x2b40 <OLED_Printf+0x98>
                    ch = *ptr;
                }
            }
            else
            {
                v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
    2b3a:	8f ef       	ldi	r24, 0xFF	; 255
    2b3c:	8a 87       	std	Y+10, r24	; 0x0a
    2b3e:	01 c0       	rjmp	.+2      	; 0x2b42 <OLED_Printf+0x9a>
        ch= *ptr;
        if(ch == '%')         /*Check for '%' as there will be format specifier after it */
        {
            ptr++;
            ch = *ptr;
            if((ch>=0x30) && (ch<=0x39))
    2b40:	00 00       	nop
            {
                v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }
            
            
            switch(ch)       /* Decode the type of the argument */
    2b42:	89 85       	ldd	r24, Y+9	; 0x09
    2b44:	08 2e       	mov	r0, r24
    2b46:	00 0c       	add	r0, r0
    2b48:	99 0b       	sbc	r25, r25
    2b4a:	09 2e       	mov	r0, r25
    2b4c:	00 0c       	add	r0, r0
    2b4e:	aa 0b       	sbc	r26, r26
    2b50:	bb 0b       	sbc	r27, r27
    2b52:	45 e2       	ldi	r20, 0x25	; 37
    2b54:	50 e0       	ldi	r21, 0x00	; 0
    2b56:	23 e5       	ldi	r18, 0x53	; 83
    2b58:	30 e0       	ldi	r19, 0x00	; 0
    2b5a:	84 1b       	sub	r24, r20
    2b5c:	95 0b       	sbc	r25, r21
    2b5e:	28 17       	cp	r18, r24
    2b60:	39 07       	cpc	r19, r25
    2b62:	08 f4       	brcc	.+2      	; 0x2b66 <OLED_Printf+0xbe>
    2b64:	43 c1       	rjmp	.+646    	; 0x2dec <OLED_Printf+0x344>
    2b66:	8c 5c       	subi	r24, 0xCC	; 204
    2b68:	9f 4f       	sbci	r25, 0xFF	; 255
    2b6a:	fc 01       	movw	r30, r24
    2b6c:	0c 94 8d 19 	jmp	0x331a	; 0x331a <__tablejump2__>
            {
                case 'C':
                case 'c':     /* Argument type is of char, hence read char data from the argp */
                    ch = va_arg(argp, int);
    2b70:	8f 89       	ldd	r24, Y+23	; 0x17
    2b72:	98 8d       	ldd	r25, Y+24	; 0x18
    2b74:	9c 01       	movw	r18, r24
    2b76:	2e 5f       	subi	r18, 0xFE	; 254
    2b78:	3f 4f       	sbci	r19, 0xFF	; 255
    2b7a:	38 8f       	std	Y+24, r19	; 0x18
    2b7c:	2f 8b       	std	Y+23, r18	; 0x17
    2b7e:	fc 01       	movw	r30, r24
    2b80:	80 81       	ld	r24, Z
    2b82:	91 81       	ldd	r25, Z+1	; 0x01
    2b84:	89 87       	std	Y+9, r24	; 0x09
                    OLED_DisplayChar(ch);
    2b86:	89 85       	ldd	r24, Y+9	; 0x09
    2b88:	0e 94 98 11 	call	0x2330	; 0x2330 <OLED_DisplayChar>
                    break;
    2b8c:	2f c1       	rjmp	.+606    	; 0x2dec <OLED_Printf+0x344>
                    
                case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
                    v_num_s16 = va_arg(argp, int);
    2b8e:	8f 89       	ldd	r24, Y+23	; 0x17
    2b90:	98 8d       	ldd	r25, Y+24	; 0x18
    2b92:	9c 01       	movw	r18, r24
    2b94:	2e 5f       	subi	r18, 0xFE	; 254
    2b96:	3f 4f       	sbci	r19, 0xFF	; 255
    2b98:	38 8f       	std	Y+24, r19	; 0x18
    2b9a:	2f 8b       	std	Y+23, r18	; 0x17
    2b9c:	fc 01       	movw	r30, r24
    2b9e:	80 81       	ld	r24, Z
    2ba0:	91 81       	ldd	r25, Z+1	; 0x01
    2ba2:	9c 83       	std	Y+4, r25	; 0x04
    2ba4:	8b 83       	std	Y+3, r24	; 0x03
                    if(v_num_s16<0)
    2ba6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ba8:	9c 81       	ldd	r25, Y+4	; 0x04
    2baa:	99 23       	and	r25, r25
    2bac:	54 f4       	brge	.+20     	; 0x2bc2 <OLED_Printf+0x11a>
                    { /* If the number is -ve then display the 2's complement along with '-' sign */
                        v_num_s16 = -v_num_s16;
    2bae:	8b 81       	ldd	r24, Y+3	; 0x03
    2bb0:	9c 81       	ldd	r25, Y+4	; 0x04
    2bb2:	91 95       	neg	r25
    2bb4:	81 95       	neg	r24
    2bb6:	91 09       	sbc	r25, r1
    2bb8:	9c 83       	std	Y+4, r25	; 0x04
    2bba:	8b 83       	std	Y+3, r24	; 0x03
                        OLED_DisplayChar('-');
    2bbc:	8d e2       	ldi	r24, 0x2D	; 45
    2bbe:	0e 94 98 11 	call	0x2330	; 0x2330 <OLED_DisplayChar>
                    }
                    OLED_DisplayNumber(C_DECIMAL_U8,v_num_s16,v_numOfDigitsToDisp_u8);
    2bc2:	8b 81       	ldd	r24, Y+3	; 0x03
    2bc4:	9c 81       	ldd	r25, Y+4	; 0x04
    2bc6:	09 2e       	mov	r0, r25
    2bc8:	00 0c       	add	r0, r0
    2bca:	aa 0b       	sbc	r26, r26
    2bcc:	bb 0b       	sbc	r27, r27
    2bce:	2a 85       	ldd	r18, Y+10	; 0x0a
    2bd0:	ac 01       	movw	r20, r24
    2bd2:	bd 01       	movw	r22, r26
    2bd4:	8a e0       	ldi	r24, 0x0A	; 10
    2bd6:	0e 94 fd 13 	call	0x27fa	; 0x27fa <OLED_DisplayNumber>
                    break;
    2bda:	08 c1       	rjmp	.+528    	; 0x2dec <OLED_Printf+0x344>
                    
                case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
                    v_num_s32 = va_arg(argp, sint32_t);
    2bdc:	8f 89       	ldd	r24, Y+23	; 0x17
    2bde:	98 8d       	ldd	r25, Y+24	; 0x18
    2be0:	9c 01       	movw	r18, r24
    2be2:	2c 5f       	subi	r18, 0xFC	; 252
    2be4:	3f 4f       	sbci	r19, 0xFF	; 255
    2be6:	38 8f       	std	Y+24, r19	; 0x18
    2be8:	2f 8b       	std	Y+23, r18	; 0x17
    2bea:	fc 01       	movw	r30, r24
    2bec:	80 81       	ld	r24, Z
    2bee:	91 81       	ldd	r25, Z+1	; 0x01
    2bf0:	a2 81       	ldd	r26, Z+2	; 0x02
    2bf2:	b3 81       	ldd	r27, Z+3	; 0x03
    2bf4:	8d 83       	std	Y+5, r24	; 0x05
    2bf6:	9e 83       	std	Y+6, r25	; 0x06
    2bf8:	af 83       	std	Y+7, r26	; 0x07
    2bfa:	b8 87       	std	Y+8, r27	; 0x08
                    if(v_num_s32<0)
    2bfc:	8d 81       	ldd	r24, Y+5	; 0x05
    2bfe:	9e 81       	ldd	r25, Y+6	; 0x06
    2c00:	af 81       	ldd	r26, Y+7	; 0x07
    2c02:	b8 85       	ldd	r27, Y+8	; 0x08
    2c04:	bb 23       	and	r27, r27
    2c06:	94 f4       	brge	.+36     	; 0x2c2c <OLED_Printf+0x184>
                    { /* If the number is -ve then display the 2's complement along with '-' sign */
                        v_num_s32 = -v_num_s32;
    2c08:	8d 81       	ldd	r24, Y+5	; 0x05
    2c0a:	9e 81       	ldd	r25, Y+6	; 0x06
    2c0c:	af 81       	ldd	r26, Y+7	; 0x07
    2c0e:	b8 85       	ldd	r27, Y+8	; 0x08
    2c10:	b0 95       	com	r27
    2c12:	a0 95       	com	r26
    2c14:	90 95       	com	r25
    2c16:	81 95       	neg	r24
    2c18:	9f 4f       	sbci	r25, 0xFF	; 255
    2c1a:	af 4f       	sbci	r26, 0xFF	; 255
    2c1c:	bf 4f       	sbci	r27, 0xFF	; 255
    2c1e:	8d 83       	std	Y+5, r24	; 0x05
    2c20:	9e 83       	std	Y+6, r25	; 0x06
    2c22:	af 83       	std	Y+7, r26	; 0x07
    2c24:	b8 87       	std	Y+8, r27	; 0x08
                        OLED_DisplayChar('-');
    2c26:	8d e2       	ldi	r24, 0x2D	; 45
    2c28:	0e 94 98 11 	call	0x2330	; 0x2330 <OLED_DisplayChar>
                    }
                    OLED_DisplayNumber(C_DECIMAL_U8,v_num_s32,v_numOfDigitsToDisp_u8);
    2c2c:	8d 81       	ldd	r24, Y+5	; 0x05
    2c2e:	9e 81       	ldd	r25, Y+6	; 0x06
    2c30:	af 81       	ldd	r26, Y+7	; 0x07
    2c32:	b8 85       	ldd	r27, Y+8	; 0x08
    2c34:	2a 85       	ldd	r18, Y+10	; 0x0a
    2c36:	ac 01       	movw	r20, r24
    2c38:	bd 01       	movw	r22, r26
    2c3a:	8a e0       	ldi	r24, 0x0A	; 10
    2c3c:	0e 94 fd 13 	call	0x27fa	; 0x27fa <OLED_DisplayNumber>
                    break;
    2c40:	d5 c0       	rjmp	.+426    	; 0x2dec <OLED_Printf+0x344>
                    
                case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
                    v_num_u16 = va_arg(argp, int);
    2c42:	8f 89       	ldd	r24, Y+23	; 0x17
    2c44:	98 8d       	ldd	r25, Y+24	; 0x18
    2c46:	9c 01       	movw	r18, r24
    2c48:	2e 5f       	subi	r18, 0xFE	; 254
    2c4a:	3f 4f       	sbci	r19, 0xFF	; 255
    2c4c:	38 8f       	std	Y+24, r19	; 0x18
    2c4e:	2f 8b       	std	Y+23, r18	; 0x17
    2c50:	fc 01       	movw	r30, r24
    2c52:	80 81       	ld	r24, Z
    2c54:	91 81       	ldd	r25, Z+1	; 0x01
    2c56:	9c 87       	std	Y+12, r25	; 0x0c
    2c58:	8b 87       	std	Y+11, r24	; 0x0b
                    OLED_DisplayNumber(C_DECIMAL_U8,v_num_u16,v_numOfDigitsToDisp_u8);
    2c5a:	8b 85       	ldd	r24, Y+11	; 0x0b
    2c5c:	9c 85       	ldd	r25, Y+12	; 0x0c
    2c5e:	cc 01       	movw	r24, r24
    2c60:	a0 e0       	ldi	r26, 0x00	; 0
    2c62:	b0 e0       	ldi	r27, 0x00	; 0
    2c64:	2a 85       	ldd	r18, Y+10	; 0x0a
    2c66:	ac 01       	movw	r20, r24
    2c68:	bd 01       	movw	r22, r26
    2c6a:	8a e0       	ldi	r24, 0x0A	; 10
    2c6c:	0e 94 fd 13 	call	0x27fa	; 0x27fa <OLED_DisplayNumber>
                    break;
    2c70:	bd c0       	rjmp	.+378    	; 0x2dec <OLED_Printf+0x344>
                    
                case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
                    v_num_u32 = va_arg(argp, uint32_t);
    2c72:	8f 89       	ldd	r24, Y+23	; 0x17
    2c74:	98 8d       	ldd	r25, Y+24	; 0x18
    2c76:	9c 01       	movw	r18, r24
    2c78:	2c 5f       	subi	r18, 0xFC	; 252
    2c7a:	3f 4f       	sbci	r19, 0xFF	; 255
    2c7c:	38 8f       	std	Y+24, r19	; 0x18
    2c7e:	2f 8b       	std	Y+23, r18	; 0x17
    2c80:	fc 01       	movw	r30, r24
    2c82:	80 81       	ld	r24, Z
    2c84:	91 81       	ldd	r25, Z+1	; 0x01
    2c86:	a2 81       	ldd	r26, Z+2	; 0x02
    2c88:	b3 81       	ldd	r27, Z+3	; 0x03
    2c8a:	8d 87       	std	Y+13, r24	; 0x0d
    2c8c:	9e 87       	std	Y+14, r25	; 0x0e
    2c8e:	af 87       	std	Y+15, r26	; 0x0f
    2c90:	b8 8b       	std	Y+16, r27	; 0x10
                    OLED_DisplayNumber(C_DECIMAL_U8,v_num_u32,v_numOfDigitsToDisp_u8);
    2c92:	8d 85       	ldd	r24, Y+13	; 0x0d
    2c94:	9e 85       	ldd	r25, Y+14	; 0x0e
    2c96:	af 85       	ldd	r26, Y+15	; 0x0f
    2c98:	b8 89       	ldd	r27, Y+16	; 0x10
    2c9a:	2a 85       	ldd	r18, Y+10	; 0x0a
    2c9c:	ac 01       	movw	r20, r24
    2c9e:	bd 01       	movw	r22, r26
    2ca0:	8a e0       	ldi	r24, 0x0A	; 10
    2ca2:	0e 94 fd 13 	call	0x27fa	; 0x27fa <OLED_DisplayNumber>
                    break;
    2ca6:	a2 c0       	rjmp	.+324    	; 0x2dec <OLED_Printf+0x344>
                    
                case 'x':  /* Argument type is of hex, hence hexadecimal data from the argp */
                    v_num_u16 = va_arg(argp, int);
    2ca8:	8f 89       	ldd	r24, Y+23	; 0x17
    2caa:	98 8d       	ldd	r25, Y+24	; 0x18
    2cac:	9c 01       	movw	r18, r24
    2cae:	2e 5f       	subi	r18, 0xFE	; 254
    2cb0:	3f 4f       	sbci	r19, 0xFF	; 255
    2cb2:	38 8f       	std	Y+24, r19	; 0x18
    2cb4:	2f 8b       	std	Y+23, r18	; 0x17
    2cb6:	fc 01       	movw	r30, r24
    2cb8:	80 81       	ld	r24, Z
    2cba:	91 81       	ldd	r25, Z+1	; 0x01
    2cbc:	9c 87       	std	Y+12, r25	; 0x0c
    2cbe:	8b 87       	std	Y+11, r24	; 0x0b
                    OLED_DisplayNumber(C_HEX_U8,v_num_u16,v_numOfDigitsToDisp_u8);
    2cc0:	8b 85       	ldd	r24, Y+11	; 0x0b
    2cc2:	9c 85       	ldd	r25, Y+12	; 0x0c
    2cc4:	cc 01       	movw	r24, r24
    2cc6:	a0 e0       	ldi	r26, 0x00	; 0
    2cc8:	b0 e0       	ldi	r27, 0x00	; 0
    2cca:	2a 85       	ldd	r18, Y+10	; 0x0a
    2ccc:	ac 01       	movw	r20, r24
    2cce:	bd 01       	movw	r22, r26
    2cd0:	80 e1       	ldi	r24, 0x10	; 16
    2cd2:	0e 94 fd 13 	call	0x27fa	; 0x27fa <OLED_DisplayNumber>
                    break;
    2cd6:	8a c0       	rjmp	.+276    	; 0x2dec <OLED_Printf+0x344>
                    
                case 'X':  /* Argument type is of hex, hence hexadecimal data from the argp */
                    v_num_u32 = va_arg(argp, uint32_t);
    2cd8:	8f 89       	ldd	r24, Y+23	; 0x17
    2cda:	98 8d       	ldd	r25, Y+24	; 0x18
    2cdc:	9c 01       	movw	r18, r24
    2cde:	2c 5f       	subi	r18, 0xFC	; 252
    2ce0:	3f 4f       	sbci	r19, 0xFF	; 255
    2ce2:	38 8f       	std	Y+24, r19	; 0x18
    2ce4:	2f 8b       	std	Y+23, r18	; 0x17
    2ce6:	fc 01       	movw	r30, r24
    2ce8:	80 81       	ld	r24, Z
    2cea:	91 81       	ldd	r25, Z+1	; 0x01
    2cec:	a2 81       	ldd	r26, Z+2	; 0x02
    2cee:	b3 81       	ldd	r27, Z+3	; 0x03
    2cf0:	8d 87       	std	Y+13, r24	; 0x0d
    2cf2:	9e 87       	std	Y+14, r25	; 0x0e
    2cf4:	af 87       	std	Y+15, r26	; 0x0f
    2cf6:	b8 8b       	std	Y+16, r27	; 0x10
                    OLED_DisplayNumber(C_HEX_U8,v_num_u32,v_numOfDigitsToDisp_u8);
    2cf8:	8d 85       	ldd	r24, Y+13	; 0x0d
    2cfa:	9e 85       	ldd	r25, Y+14	; 0x0e
    2cfc:	af 85       	ldd	r26, Y+15	; 0x0f
    2cfe:	b8 89       	ldd	r27, Y+16	; 0x10
    2d00:	2a 85       	ldd	r18, Y+10	; 0x0a
    2d02:	ac 01       	movw	r20, r24
    2d04:	bd 01       	movw	r22, r26
    2d06:	80 e1       	ldi	r24, 0x10	; 16
    2d08:	0e 94 fd 13 	call	0x27fa	; 0x27fa <OLED_DisplayNumber>
                    break;
    2d0c:	6f c0       	rjmp	.+222    	; 0x2dec <OLED_Printf+0x344>
                    
                    
                case 'b':  /* Argument type is of binary,Read int and convert to binary */
                    v_num_u16 = va_arg(argp, int);
    2d0e:	8f 89       	ldd	r24, Y+23	; 0x17
    2d10:	98 8d       	ldd	r25, Y+24	; 0x18
    2d12:	9c 01       	movw	r18, r24
    2d14:	2e 5f       	subi	r18, 0xFE	; 254
    2d16:	3f 4f       	sbci	r19, 0xFF	; 255
    2d18:	38 8f       	std	Y+24, r19	; 0x18
    2d1a:	2f 8b       	std	Y+23, r18	; 0x17
    2d1c:	fc 01       	movw	r30, r24
    2d1e:	80 81       	ld	r24, Z
    2d20:	91 81       	ldd	r25, Z+1	; 0x01
    2d22:	9c 87       	std	Y+12, r25	; 0x0c
    2d24:	8b 87       	std	Y+11, r24	; 0x0b
                    if(v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
    2d26:	8a 85       	ldd	r24, Y+10	; 0x0a
    2d28:	8f 3f       	cpi	r24, 0xFF	; 255
    2d2a:	11 f4       	brne	.+4      	; 0x2d30 <OLED_Printf+0x288>
                        v_numOfDigitsToDisp_u8 = 16;
    2d2c:	80 e1       	ldi	r24, 0x10	; 16
    2d2e:	8a 87       	std	Y+10, r24	; 0x0a
                    OLED_DisplayNumber(C_BINARY_U8,v_num_u16,v_numOfDigitsToDisp_u8);
    2d30:	8b 85       	ldd	r24, Y+11	; 0x0b
    2d32:	9c 85       	ldd	r25, Y+12	; 0x0c
    2d34:	cc 01       	movw	r24, r24
    2d36:	a0 e0       	ldi	r26, 0x00	; 0
    2d38:	b0 e0       	ldi	r27, 0x00	; 0
    2d3a:	2a 85       	ldd	r18, Y+10	; 0x0a
    2d3c:	ac 01       	movw	r20, r24
    2d3e:	bd 01       	movw	r22, r26
    2d40:	82 e0       	ldi	r24, 0x02	; 2
    2d42:	0e 94 fd 13 	call	0x27fa	; 0x27fa <OLED_DisplayNumber>
                    break;
    2d46:	52 c0       	rjmp	.+164    	; 0x2dec <OLED_Printf+0x344>
                    
                case 'B':  /* Argument type is of binary,Read int and convert to binary */
                    v_num_u32 = va_arg(argp, uint32_t);
    2d48:	8f 89       	ldd	r24, Y+23	; 0x17
    2d4a:	98 8d       	ldd	r25, Y+24	; 0x18
    2d4c:	9c 01       	movw	r18, r24
    2d4e:	2c 5f       	subi	r18, 0xFC	; 252
    2d50:	3f 4f       	sbci	r19, 0xFF	; 255
    2d52:	38 8f       	std	Y+24, r19	; 0x18
    2d54:	2f 8b       	std	Y+23, r18	; 0x17
    2d56:	fc 01       	movw	r30, r24
    2d58:	80 81       	ld	r24, Z
    2d5a:	91 81       	ldd	r25, Z+1	; 0x01
    2d5c:	a2 81       	ldd	r26, Z+2	; 0x02
    2d5e:	b3 81       	ldd	r27, Z+3	; 0x03
    2d60:	8d 87       	std	Y+13, r24	; 0x0d
    2d62:	9e 87       	std	Y+14, r25	; 0x0e
    2d64:	af 87       	std	Y+15, r26	; 0x0f
    2d66:	b8 8b       	std	Y+16, r27	; 0x10
                    if(v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
    2d68:	8a 85       	ldd	r24, Y+10	; 0x0a
    2d6a:	8f 3f       	cpi	r24, 0xFF	; 255
    2d6c:	11 f4       	brne	.+4      	; 0x2d72 <OLED_Printf+0x2ca>
                        v_numOfDigitsToDisp_u8 = 16;
    2d6e:	80 e1       	ldi	r24, 0x10	; 16
    2d70:	8a 87       	std	Y+10, r24	; 0x0a
                    OLED_DisplayNumber(C_BINARY_U8,v_num_u32,v_numOfDigitsToDisp_u8);
    2d72:	8d 85       	ldd	r24, Y+13	; 0x0d
    2d74:	9e 85       	ldd	r25, Y+14	; 0x0e
    2d76:	af 85       	ldd	r26, Y+15	; 0x0f
    2d78:	b8 89       	ldd	r27, Y+16	; 0x10
    2d7a:	2a 85       	ldd	r18, Y+10	; 0x0a
    2d7c:	ac 01       	movw	r20, r24
    2d7e:	bd 01       	movw	r22, r26
    2d80:	82 e0       	ldi	r24, 0x02	; 2
    2d82:	0e 94 fd 13 	call	0x27fa	; 0x27fa <OLED_DisplayNumber>
                    break;
    2d86:	32 c0       	rjmp	.+100    	; 0x2dec <OLED_Printf+0x344>
                    
                    
                case 'F':
                case 'f': /* Argument type is of float, hence read double data from the argp */
#if (Enable_OLED_DisplayFloatNumber == 1)
                    v_floatNum_f32 = va_arg(argp, double);
    2d88:	8f 89       	ldd	r24, Y+23	; 0x17
    2d8a:	98 8d       	ldd	r25, Y+24	; 0x18
    2d8c:	9c 01       	movw	r18, r24
    2d8e:	2c 5f       	subi	r18, 0xFC	; 252
    2d90:	3f 4f       	sbci	r19, 0xFF	; 255
    2d92:	38 8f       	std	Y+24, r19	; 0x18
    2d94:	2f 8b       	std	Y+23, r18	; 0x17
    2d96:	fc 01       	movw	r30, r24
    2d98:	80 81       	ld	r24, Z
    2d9a:	91 81       	ldd	r25, Z+1	; 0x01
    2d9c:	a2 81       	ldd	r26, Z+2	; 0x02
    2d9e:	b3 81       	ldd	r27, Z+3	; 0x03
    2da0:	89 8b       	std	Y+17, r24	; 0x11
    2da2:	9a 8b       	std	Y+18, r25	; 0x12
    2da4:	ab 8b       	std	Y+19, r26	; 0x13
    2da6:	bc 8b       	std	Y+20, r27	; 0x14
                    OLED_DisplayFloatNumber(v_floatNum_f32);
    2da8:	89 89       	ldd	r24, Y+17	; 0x11
    2daa:	9a 89       	ldd	r25, Y+18	; 0x12
    2dac:	ab 89       	ldd	r26, Y+19	; 0x13
    2dae:	bc 89       	ldd	r27, Y+20	; 0x14
    2db0:	bc 01       	movw	r22, r24
    2db2:	cd 01       	movw	r24, r26
    2db4:	0e 94 ed 14 	call	0x29da	; 0x29da <OLED_DisplayFloatNumber>
#endif
                    break;
    2db8:	19 c0       	rjmp	.+50     	; 0x2dec <OLED_Printf+0x344>
                    
                    
                case 'S':
                case 's': /* Argument type is of string, hence get the pointer to sting passed */
                    str = va_arg(argp, char *);
    2dba:	8f 89       	ldd	r24, Y+23	; 0x17
    2dbc:	98 8d       	ldd	r25, Y+24	; 0x18
    2dbe:	9c 01       	movw	r18, r24
    2dc0:	2e 5f       	subi	r18, 0xFE	; 254
    2dc2:	3f 4f       	sbci	r19, 0xFF	; 255
    2dc4:	38 8f       	std	Y+24, r19	; 0x18
    2dc6:	2f 8b       	std	Y+23, r18	; 0x17
    2dc8:	fc 01       	movw	r30, r24
    2dca:	80 81       	ld	r24, Z
    2dcc:	91 81       	ldd	r25, Z+1	; 0x01
    2dce:	9e 8b       	std	Y+22, r25	; 0x16
    2dd0:	8d 8b       	std	Y+21, r24	; 0x15
                    OLED_DisplayString(str);
    2dd2:	8d 89       	ldd	r24, Y+21	; 0x15
    2dd4:	9e 89       	ldd	r25, Y+22	; 0x16
    2dd6:	0e 94 e5 11 	call	0x23ca	; 0x23ca <OLED_DisplayString>
                    break;
    2dda:	08 c0       	rjmp	.+16     	; 0x2dec <OLED_Printf+0x344>
                    
                case '%':
                    OLED_DisplayChar('%');
    2ddc:	85 e2       	ldi	r24, 0x25	; 37
    2dde:	0e 94 98 11 	call	0x2330	; 0x2330 <OLED_DisplayChar>
                    break;
    2de2:	00 00       	nop
    2de4:	03 c0       	rjmp	.+6      	; 0x2dec <OLED_Printf+0x344>
            }
        }
        else
        {
            /* As '%' is not detected display/transmit the char passed */
            OLED_DisplayChar(ch);
    2de6:	89 85       	ldd	r24, Y+9	; 0x09
    2de8:	0e 94 98 11 	call	0x2330	; 0x2330 <OLED_DisplayChar>
#endif
    
    va_start(argp, argList);
    
    /* Loop through the list to extract all the input arguments */
    for(ptr = argList; *ptr != '\0'; ptr++)
    2dec:	89 81       	ldd	r24, Y+1	; 0x01
    2dee:	9a 81       	ldd	r25, Y+2	; 0x02
    2df0:	01 96       	adiw	r24, 0x01	; 1
    2df2:	9a 83       	std	Y+2, r25	; 0x02
    2df4:	89 83       	std	Y+1, r24	; 0x01
    2df6:	89 81       	ldd	r24, Y+1	; 0x01
    2df8:	9a 81       	ldd	r25, Y+2	; 0x02
    2dfa:	fc 01       	movw	r30, r24
    2dfc:	80 81       	ld	r24, Z
    2dfe:	88 23       	and	r24, r24
    2e00:	09 f0       	breq	.+2      	; 0x2e04 <OLED_Printf+0x35c>
    2e02:	65 ce       	rjmp	.-822    	; 0x2ace <OLED_Printf+0x26>
            OLED_DisplayChar(ch);
        }
    }
    
    va_end(argp);
}
    2e04:	00 00       	nop
    2e06:	68 96       	adiw	r28, 0x18	; 24
    2e08:	0f b6       	in	r0, 0x3f	; 63
    2e0a:	f8 94       	cli
    2e0c:	de bf       	out	0x3e, r29	; 62
    2e0e:	0f be       	out	0x3f, r0	; 63
    2e10:	cd bf       	out	0x3d, r28	; 61
    2e12:	df 91       	pop	r29
    2e14:	cf 91       	pop	r28
    2e16:	08 95       	ret

00002e18 <OLED_Clear>:
 * I/P Arguments: none.
 * Return value    : none
 * description  :This function clears the LCD and moves the cursor to beginning of first line
 ****************************************************************************************************/
void OLED_Clear()
{
    2e18:	cf 93       	push	r28
    2e1a:	df 93       	push	r29
    2e1c:	00 d0       	rcall	.+0      	; 0x2e1e <OLED_Clear+0x6>
    2e1e:	cd b7       	in	r28, 0x3d	; 61
    2e20:	de b7       	in	r29, 0x3e	; 62
    int i;
    
    oledSendCommand(SSD1306_SET_COLUMN_ADDR);
    2e22:	81 e2       	ldi	r24, 0x21	; 33
    2e24:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(0);
    2e28:	80 e0       	ldi	r24, 0x00	; 0
    2e2a:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(127);
    2e2e:	8f e7       	ldi	r24, 0x7F	; 127
    2e30:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    
    oledSendCommand(SSD1306_SET_PAGE_ADDR);
    2e34:	82 e2       	ldi	r24, 0x22	; 34
    2e36:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(0);
    2e3a:	80 e0       	ldi	r24, 0x00	; 0
    2e3c:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(7);
    2e40:	87 e0       	ldi	r24, 0x07	; 7
    2e42:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    
    
    oledSendStart(SSD1306_ADDRESS);
    2e46:	8c e3       	ldi	r24, 0x3C	; 60
    2e48:	0e 94 cd 18 	call	0x319a	; 0x319a <oledSendStart>
    oledSendByte(SSD1306_DATA_CONTINUE);
    2e4c:	80 e4       	ldi	r24, 0x40	; 64
    2e4e:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <oledSendByte>
    
    for (i=0; i<1024; i++)      // Write Zeros to clear the display
    2e52:	1a 82       	std	Y+2, r1	; 0x02
    2e54:	19 82       	std	Y+1, r1	; 0x01
    2e56:	08 c0       	rjmp	.+16     	; 0x2e68 <OLED_Clear+0x50>
    {
        oledSendByte(0);
    2e58:	80 e0       	ldi	r24, 0x00	; 0
    2e5a:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <oledSendByte>
    
    
    oledSendStart(SSD1306_ADDRESS);
    oledSendByte(SSD1306_DATA_CONTINUE);
    
    for (i=0; i<1024; i++)      // Write Zeros to clear the display
    2e5e:	89 81       	ldd	r24, Y+1	; 0x01
    2e60:	9a 81       	ldd	r25, Y+2	; 0x02
    2e62:	01 96       	adiw	r24, 0x01	; 1
    2e64:	9a 83       	std	Y+2, r25	; 0x02
    2e66:	89 83       	std	Y+1, r24	; 0x01
    2e68:	89 81       	ldd	r24, Y+1	; 0x01
    2e6a:	9a 81       	ldd	r25, Y+2	; 0x02
    2e6c:	81 15       	cp	r24, r1
    2e6e:	94 40       	sbci	r25, 0x04	; 4
    2e70:	9c f3       	brlt	.-26     	; 0x2e58 <OLED_Clear+0x40>
    {
        oledSendByte(0);
    }
    
    oledSendCommand(SSD1306_SET_COLUMN_ADDR);
    2e72:	81 e2       	ldi	r24, 0x21	; 33
    2e74:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(0);
    2e78:	80 e0       	ldi	r24, 0x00	; 0
    2e7a:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(127);
    2e7e:	8f e7       	ldi	r24, 0x7F	; 127
    2e80:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    
    oledSendCommand(SSD1306_SET_PAGE_ADDR);
    2e84:	82 e2       	ldi	r24, 0x22	; 34
    2e86:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(0);
    2e8a:	80 e0       	ldi	r24, 0x00	; 0
    2e8c:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(7);
    2e90:	87 e0       	ldi	r24, 0x07	; 7
    2e92:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    
    oledSendStart(SSD1306_ADDRESS);
    2e96:	8c e3       	ldi	r24, 0x3C	; 60
    2e98:	0e 94 cd 18 	call	0x319a	; 0x319a <oledSendStart>
    oledSendByte(SSD1306_DATA_CONTINUE);
    2e9c:	80 e4       	ldi	r24, 0x40	; 64
    2e9e:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <oledSendByte>
}
    2ea2:	00 00       	nop
    2ea4:	0f 90       	pop	r0
    2ea6:	0f 90       	pop	r0
    2ea8:	df 91       	pop	r29
    2eaa:	cf 91       	pop	r28
    2eac:	08 95       	ret

00002eae <OLED_GoToLine>:
 If the requested line number is out of range, it will not move the cursor.
 Note: The line numbers run from 0 to 7
 ****************************************************************************************************/
#if (Enable_OLED_GoToLine == 1)
void  OLED_GoToLine(uint8_t lineNumber)
{
    2eae:	cf 93       	push	r28
    2eb0:	df 93       	push	r29
    2eb2:	1f 92       	push	r1
    2eb4:	cd b7       	in	r28, 0x3d	; 61
    2eb6:	de b7       	in	r29, 0x3e	; 62
    2eb8:	89 83       	std	Y+1, r24	; 0x01
    if(lineNumber<8)
    2eba:	89 81       	ldd	r24, Y+1	; 0x01
    2ebc:	88 30       	cpi	r24, 0x08	; 8
    2ebe:	40 f4       	brcc	.+16     	; 0x2ed0 <OLED_GoToLine+0x22>
    {   /* If the line number is within range
         then move it to specified line and keep track*/
        OledLineNum = lineNumber;
    2ec0:	89 81       	ldd	r24, Y+1	; 0x01
    2ec2:	80 93 28 03 	sts	0x0328, r24	; 0x800328 <OledLineNum>
        OLED_SetCursor(OledLineNum,0);
    2ec6:	80 91 28 03 	lds	r24, 0x0328	; 0x800328 <OledLineNum>
    2eca:	60 e0       	ldi	r22, 0x00	; 0
    2ecc:	0e 94 84 17 	call	0x2f08	; 0x2f08 <OLED_SetCursor>
    }
}
    2ed0:	00 00       	nop
    2ed2:	0f 90       	pop	r0
    2ed4:	df 91       	pop	r29
    2ed6:	cf 91       	pop	r28
    2ed8:	08 95       	ret

00002eda <OLED_GoToNextLine>:
 * description  :This function moves the Cursor to beginning of the next line.
 If the cursor is on last line and NextLine command is issued then
 it will move the cursor to first line.
 ****************************************************************************************************/
void  OLED_GoToNextLine()
{
    2eda:	cf 93       	push	r28
    2edc:	df 93       	push	r29
    2ede:	cd b7       	in	r28, 0x3d	; 61
    2ee0:	de b7       	in	r29, 0x3e	; 62
    /*Increment the current line number.
     In case it exceeds the limit, rool it back to first line */
    OledLineNum++;
    2ee2:	80 91 28 03 	lds	r24, 0x0328	; 0x800328 <OledLineNum>
    2ee6:	8f 5f       	subi	r24, 0xFF	; 255
    2ee8:	80 93 28 03 	sts	0x0328, r24	; 0x800328 <OledLineNum>
    OledLineNum = OledLineNum&0x07;
    2eec:	80 91 28 03 	lds	r24, 0x0328	; 0x800328 <OledLineNum>
    2ef0:	87 70       	andi	r24, 0x07	; 7
    2ef2:	80 93 28 03 	sts	0x0328, r24	; 0x800328 <OledLineNum>
    OLED_SetCursor(OledLineNum,0); /* Finally move it to next line */
    2ef6:	80 91 28 03 	lds	r24, 0x0328	; 0x800328 <OledLineNum>
    2efa:	60 e0       	ldi	r22, 0x00	; 0
    2efc:	0e 94 84 17 	call	0x2f08	; 0x2f08 <OLED_SetCursor>
}
    2f00:	00 00       	nop
    2f02:	df 91       	pop	r29
    2f04:	cf 91       	pop	r28
    2f06:	08 95       	ret

00002f08 <OLED_SetCursor>:
 * description  :This function moves the Cursor to specified position
 Note:If the Input(Line/Char number) are out of range
 then no action will be taken
 ****************************************************************************************************/
void OLED_SetCursor(uint8_t lineNumber,uint8_t cursorPosition)
{
    2f08:	cf 93       	push	r28
    2f0a:	df 93       	push	r29
    2f0c:	00 d0       	rcall	.+0      	; 0x2f0e <OLED_SetCursor+0x6>
    2f0e:	cd b7       	in	r28, 0x3d	; 61
    2f10:	de b7       	in	r29, 0x3e	; 62
    2f12:	89 83       	std	Y+1, r24	; 0x01
    2f14:	6a 83       	std	Y+2, r22	; 0x02
    /* Move the Cursor to specified position only if it is in range */
    if((lineNumber <= C_OledLastLine_U8) && (cursorPosition <= 127))
    2f16:	89 81       	ldd	r24, Y+1	; 0x01
    2f18:	88 30       	cpi	r24, 0x08	; 8
    2f1a:	08 f5       	brcc	.+66     	; 0x2f5e <OLED_SetCursor+0x56>
    2f1c:	8a 81       	ldd	r24, Y+2	; 0x02
    2f1e:	88 23       	and	r24, r24
    2f20:	f4 f0       	brlt	.+60     	; 0x2f5e <OLED_SetCursor+0x56>
    {
        OledLineNum=lineNumber;   /* Save the specified line number */
    2f22:	89 81       	ldd	r24, Y+1	; 0x01
    2f24:	80 93 28 03 	sts	0x0328, r24	; 0x800328 <OledLineNum>
        OledCursorPos=cursorPosition; /* Save the specified cursor position */
    2f28:	8a 81       	ldd	r24, Y+2	; 0x02
    2f2a:	80 93 29 03 	sts	0x0329, r24	; 0x800329 <OledCursorPos>
        
        oledSendCommand(SSD1306_SET_COLUMN_ADDR);
    2f2e:	81 e2       	ldi	r24, 0x21	; 33
    2f30:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
        oledSendCommand(cursorPosition);
    2f34:	8a 81       	ldd	r24, Y+2	; 0x02
    2f36:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
        oledSendCommand(127);
    2f3a:	8f e7       	ldi	r24, 0x7F	; 127
    2f3c:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
        
        oledSendCommand(SSD1306_SET_PAGE_ADDR);
    2f40:	82 e2       	ldi	r24, 0x22	; 34
    2f42:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
        oledSendCommand(lineNumber);
    2f46:	89 81       	ldd	r24, Y+1	; 0x01
    2f48:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
        oledSendCommand(7);
    2f4c:	87 e0       	ldi	r24, 0x07	; 7
    2f4e:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
        
        oledSendStart(SSD1306_ADDRESS);
    2f52:	8c e3       	ldi	r24, 0x3C	; 60
    2f54:	0e 94 cd 18 	call	0x319a	; 0x319a <oledSendStart>
        oledSendByte(SSD1306_DATA_CONTINUE);
    2f58:	80 e4       	ldi	r24, 0x40	; 64
    2f5a:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <oledSendByte>
    }
}
    2f5e:	00 00       	nop
    2f60:	0f 90       	pop	r0
    2f62:	0f 90       	pop	r0
    2f64:	df 91       	pop	r29
    2f66:	cf 91       	pop	r28
    2f68:	08 95       	ret

00002f6a <OLED_DisplayLogo>:
 User can enable/disable the inversion of the dislpay by using the below functions.
 OLED_EnableInversion/OLED_DisableInversion
 ****************************************************************************************************/
#if (Enable_OLED_DisplayLogo == 1)
void OLED_DisplayLogo(char *ptr_Logo)
{
    2f6a:	cf 93       	push	r28
    2f6c:	df 93       	push	r29
    2f6e:	00 d0       	rcall	.+0      	; 0x2f70 <OLED_DisplayLogo+0x6>
    2f70:	00 d0       	rcall	.+0      	; 0x2f72 <OLED_DisplayLogo+0x8>
    2f72:	cd b7       	in	r28, 0x3d	; 61
    2f74:	de b7       	in	r29, 0x3e	; 62
    2f76:	9c 83       	std	Y+4, r25	; 0x04
    2f78:	8b 83       	std	Y+3, r24	; 0x03
    int i;
    
    OLED_SetCursor(0,0);
    2f7a:	60 e0       	ldi	r22, 0x00	; 0
    2f7c:	80 e0       	ldi	r24, 0x00	; 0
    2f7e:	0e 94 84 17 	call	0x2f08	; 0x2f08 <OLED_SetCursor>
    
    oledSendStart(SSD1306_ADDRESS);
    2f82:	8c e3       	ldi	r24, 0x3C	; 60
    2f84:	0e 94 cd 18 	call	0x319a	; 0x319a <oledSendStart>
    oledSendByte(SSD1306_DATA_CONTINUE);
    2f88:	80 e4       	ldi	r24, 0x40	; 64
    2f8a:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <oledSendByte>
    
    for ( i=0; i<1024; i++)      // Send data
    2f8e:	1a 82       	std	Y+2, r1	; 0x02
    2f90:	19 82       	std	Y+1, r1	; 0x01
    2f92:	0f c0       	rjmp	.+30     	; 0x2fb2 <OLED_DisplayLogo+0x48>
    {
        oledSendByte(ptr_Logo[i]);
    2f94:	89 81       	ldd	r24, Y+1	; 0x01
    2f96:	9a 81       	ldd	r25, Y+2	; 0x02
    2f98:	2b 81       	ldd	r18, Y+3	; 0x03
    2f9a:	3c 81       	ldd	r19, Y+4	; 0x04
    2f9c:	82 0f       	add	r24, r18
    2f9e:	93 1f       	adc	r25, r19
    2fa0:	fc 01       	movw	r30, r24
    2fa2:	80 81       	ld	r24, Z
    2fa4:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <oledSendByte>
    OLED_SetCursor(0,0);
    
    oledSendStart(SSD1306_ADDRESS);
    oledSendByte(SSD1306_DATA_CONTINUE);
    
    for ( i=0; i<1024; i++)      // Send data
    2fa8:	89 81       	ldd	r24, Y+1	; 0x01
    2faa:	9a 81       	ldd	r25, Y+2	; 0x02
    2fac:	01 96       	adiw	r24, 0x01	; 1
    2fae:	9a 83       	std	Y+2, r25	; 0x02
    2fb0:	89 83       	std	Y+1, r24	; 0x01
    2fb2:	89 81       	ldd	r24, Y+1	; 0x01
    2fb4:	9a 81       	ldd	r25, Y+2	; 0x02
    2fb6:	81 15       	cp	r24, r1
    2fb8:	94 40       	sbci	r25, 0x04	; 4
    2fba:	64 f3       	brlt	.-40     	; 0x2f94 <OLED_DisplayLogo+0x2a>
    {
        oledSendByte(ptr_Logo[i]);
    }
}
    2fbc:	00 00       	nop
    2fbe:	0f 90       	pop	r0
    2fc0:	0f 90       	pop	r0
    2fc2:	0f 90       	pop	r0
    2fc4:	0f 90       	pop	r0
    2fc6:	df 91       	pop	r29
    2fc8:	cf 91       	pop	r28
    2fca:	08 95       	ret

00002fcc <OLED_VerticalGraph>:
 * description  :
 This function displays bar graph in horizontal direction.
 ****************************************************************************************************/
#if (ENABLE_OLED_VerticalGraph ==1)
void OLED_VerticalGraph(uint8_t barGraphNumber, uint8_t percentageValue)
{
    2fcc:	cf 93       	push	r28
    2fce:	df 93       	push	r29
    2fd0:	cd b7       	in	r28, 0x3d	; 61
    2fd2:	de b7       	in	r29, 0x3e	; 62
    2fd4:	28 97       	sbiw	r28, 0x08	; 8
    2fd6:	0f b6       	in	r0, 0x3f	; 63
    2fd8:	f8 94       	cli
    2fda:	de bf       	out	0x3e, r29	; 62
    2fdc:	0f be       	out	0x3f, r0	; 63
    2fde:	cd bf       	out	0x3d, r28	; 61
    2fe0:	8f 83       	std	Y+7, r24	; 0x07
    2fe2:	68 87       	std	Y+8, r22	; 0x08
    uint8_t lineNumberToStartDisplay,i,j,barGraphPosition;
    uint8_t lineNumber,valueToDisplay;
    
    
    if((barGraphNumber < C_MaxBarGraphs_U8) && (percentageValue<=100))
    2fe4:	8f 81       	ldd	r24, Y+7	; 0x07
    2fe6:	85 30       	cpi	r24, 0x05	; 5
    2fe8:	08 f0       	brcs	.+2      	; 0x2fec <OLED_VerticalGraph+0x20>
    2fea:	61 c0       	rjmp	.+194    	; 0x30ae <OLED_VerticalGraph+0xe2>
    2fec:	88 85       	ldd	r24, Y+8	; 0x08
    2fee:	85 36       	cpi	r24, 0x65	; 101
    2ff0:	08 f0       	brcs	.+2      	; 0x2ff4 <OLED_VerticalGraph+0x28>
    2ff2:	5d c0       	rjmp	.+186    	; 0x30ae <OLED_VerticalGraph+0xe2>
    {
        barGraphPosition = barGraphNumber * 32;
    2ff4:	8f 81       	ldd	r24, Y+7	; 0x07
    2ff6:	82 95       	swap	r24
    2ff8:	88 0f       	add	r24, r24
    2ffa:	80 7e       	andi	r24, 0xE0	; 224
    2ffc:	8c 83       	std	Y+4, r24	; 0x04
        
        OLED_SetCursor(0,barGraphPosition+8);
    2ffe:	8c 81       	ldd	r24, Y+4	; 0x04
    3000:	88 5f       	subi	r24, 0xF8	; 248
    3002:	68 2f       	mov	r22, r24
    3004:	80 e0       	ldi	r24, 0x00	; 0
    3006:	0e 94 84 17 	call	0x2f08	; 0x2f08 <OLED_SetCursor>
        OLED_DisplayNumber(E_DECIMAL,percentageValue,3);
    300a:	88 85       	ldd	r24, Y+8	; 0x08
    300c:	88 2f       	mov	r24, r24
    300e:	90 e0       	ldi	r25, 0x00	; 0
    3010:	a0 e0       	ldi	r26, 0x00	; 0
    3012:	b0 e0       	ldi	r27, 0x00	; 0
    3014:	23 e0       	ldi	r18, 0x03	; 3
    3016:	ac 01       	movw	r20, r24
    3018:	bd 01       	movw	r22, r26
    301a:	8a e0       	ldi	r24, 0x0A	; 10
    301c:	0e 94 fd 13 	call	0x27fa	; 0x27fa <OLED_DisplayNumber>
        
        
        /* Divide the value by 8, as we have 8-pixels for each line */
        percentageValue = percentageValue/2;
    3020:	88 85       	ldd	r24, Y+8	; 0x08
    3022:	86 95       	lsr	r24
    3024:	88 87       	std	Y+8, r24	; 0x08
        lineNumberToStartDisplay = (percentageValue>>3);
    3026:	88 85       	ldd	r24, Y+8	; 0x08
    3028:	86 95       	lsr	r24
    302a:	86 95       	lsr	r24
    302c:	86 95       	lsr	r24
    302e:	8d 83       	std	Y+5, r24	; 0x05
        lineNumber = 7-lineNumberToStartDisplay;
    3030:	97 e0       	ldi	r25, 0x07	; 7
    3032:	8d 81       	ldd	r24, Y+5	; 0x05
    3034:	29 2f       	mov	r18, r25
    3036:	28 1b       	sub	r18, r24
    3038:	82 2f       	mov	r24, r18
    303a:	8e 83       	std	Y+6, r24	; 0x06
        
        
        for(i=1;i<8;i++)
    303c:	81 e0       	ldi	r24, 0x01	; 1
    303e:	89 83       	std	Y+1, r24	; 0x01
    3040:	33 c0       	rjmp	.+102    	; 0x30a8 <OLED_VerticalGraph+0xdc>
        {
            OLED_SetCursor(i,(barGraphPosition+12));
    3042:	8c 81       	ldd	r24, Y+4	; 0x04
    3044:	84 5f       	subi	r24, 0xF4	; 244
    3046:	68 2f       	mov	r22, r24
    3048:	89 81       	ldd	r24, Y+1	; 0x01
    304a:	0e 94 84 17 	call	0x2f08	; 0x2f08 <OLED_SetCursor>
            if(i<lineNumber)
    304e:	99 81       	ldd	r25, Y+1	; 0x01
    3050:	8e 81       	ldd	r24, Y+6	; 0x06
    3052:	98 17       	cp	r25, r24
    3054:	10 f4       	brcc	.+4      	; 0x305a <OLED_VerticalGraph+0x8e>
            {
                valueToDisplay = 0x00;
    3056:	1b 82       	std	Y+3, r1	; 0x03
    3058:	19 c0       	rjmp	.+50     	; 0x308c <OLED_VerticalGraph+0xc0>
            }
            else if(i== lineNumber)
    305a:	99 81       	ldd	r25, Y+1	; 0x01
    305c:	8e 81       	ldd	r24, Y+6	; 0x06
    305e:	98 17       	cp	r25, r24
    3060:	99 f4       	brne	.+38     	; 0x3088 <OLED_VerticalGraph+0xbc>
            {
                valueToDisplay = util_GetMod8(percentageValue,8);
    3062:	88 85       	ldd	r24, Y+8	; 0x08
    3064:	87 70       	andi	r24, 0x07	; 7
    3066:	8b 83       	std	Y+3, r24	; 0x03
                valueToDisplay = (0xff<<(8-valueToDisplay));
    3068:	8b 81       	ldd	r24, Y+3	; 0x03
    306a:	88 2f       	mov	r24, r24
    306c:	90 e0       	ldi	r25, 0x00	; 0
    306e:	28 e0       	ldi	r18, 0x08	; 8
    3070:	30 e0       	ldi	r19, 0x00	; 0
    3072:	28 1b       	sub	r18, r24
    3074:	39 0b       	sbc	r19, r25
    3076:	8f ef       	ldi	r24, 0xFF	; 255
    3078:	90 e0       	ldi	r25, 0x00	; 0
    307a:	02 c0       	rjmp	.+4      	; 0x3080 <OLED_VerticalGraph+0xb4>
    307c:	88 0f       	add	r24, r24
    307e:	99 1f       	adc	r25, r25
    3080:	2a 95       	dec	r18
    3082:	e2 f7       	brpl	.-8      	; 0x307c <OLED_VerticalGraph+0xb0>
    3084:	8b 83       	std	Y+3, r24	; 0x03
    3086:	02 c0       	rjmp	.+4      	; 0x308c <OLED_VerticalGraph+0xc0>
            }
            else
            {
                valueToDisplay = 0xff;
    3088:	8f ef       	ldi	r24, 0xFF	; 255
    308a:	8b 83       	std	Y+3, r24	; 0x03
            }
            
            for(j=0;j<12;j++)
    308c:	1a 82       	std	Y+2, r1	; 0x02
    308e:	06 c0       	rjmp	.+12     	; 0x309c <OLED_VerticalGraph+0xd0>
            {
                oledSendByte(valueToDisplay);
    3090:	8b 81       	ldd	r24, Y+3	; 0x03
    3092:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <oledSendByte>
            else
            {
                valueToDisplay = 0xff;
            }
            
            for(j=0;j<12;j++)
    3096:	8a 81       	ldd	r24, Y+2	; 0x02
    3098:	8f 5f       	subi	r24, 0xFF	; 255
    309a:	8a 83       	std	Y+2, r24	; 0x02
    309c:	8a 81       	ldd	r24, Y+2	; 0x02
    309e:	8c 30       	cpi	r24, 0x0C	; 12
    30a0:	b8 f3       	brcs	.-18     	; 0x3090 <OLED_VerticalGraph+0xc4>
        percentageValue = percentageValue/2;
        lineNumberToStartDisplay = (percentageValue>>3);
        lineNumber = 7-lineNumberToStartDisplay;
        
        
        for(i=1;i<8;i++)
    30a2:	89 81       	ldd	r24, Y+1	; 0x01
    30a4:	8f 5f       	subi	r24, 0xFF	; 255
    30a6:	89 83       	std	Y+1, r24	; 0x01
    30a8:	89 81       	ldd	r24, Y+1	; 0x01
    30aa:	88 30       	cpi	r24, 0x08	; 8
    30ac:	50 f2       	brcs	.-108    	; 0x3042 <OLED_VerticalGraph+0x76>
            {
                oledSendByte(valueToDisplay);
            }
        }
    }
}
    30ae:	00 00       	nop
    30b0:	28 96       	adiw	r28, 0x08	; 8
    30b2:	0f b6       	in	r0, 0x3f	; 63
    30b4:	f8 94       	cli
    30b6:	de bf       	out	0x3e, r29	; 62
    30b8:	0f be       	out	0x3f, r0	; 63
    30ba:	cd bf       	out	0x3d, r28	; 61
    30bc:	df 91       	pop	r29
    30be:	cf 91       	pop	r28
    30c0:	08 95       	ret

000030c2 <OLED_HorizontalGraph>:
 * description  :
 This function displays bar graph in vertical direction.
 ****************************************************************************************************/
#if (ENABLE_OLED_HorizontalGraph ==1)
void OLED_HorizontalGraph(uint8_t barGraphNumber, uint8_t percentageValue)
{
    30c2:	cf 93       	push	r28
    30c4:	df 93       	push	r29
    30c6:	00 d0       	rcall	.+0      	; 0x30c8 <OLED_HorizontalGraph+0x6>
    30c8:	00 d0       	rcall	.+0      	; 0x30ca <OLED_HorizontalGraph+0x8>
    30ca:	cd b7       	in	r28, 0x3d	; 61
    30cc:	de b7       	in	r29, 0x3e	; 62
    30ce:	8b 83       	std	Y+3, r24	; 0x03
    30d0:	6c 83       	std	Y+4, r22	; 0x04
    uint8_t lineNumberToStartDisplay,i;
    lineNumberToStartDisplay = (barGraphNumber * 2)+1;
    30d2:	8b 81       	ldd	r24, Y+3	; 0x03
    30d4:	88 0f       	add	r24, r24
    30d6:	8f 5f       	subi	r24, 0xFF	; 255
    30d8:	8a 83       	std	Y+2, r24	; 0x02
    
    if((barGraphNumber < C_MaxBarGraphs_U8) && (percentageValue<=100))
    30da:	8b 81       	ldd	r24, Y+3	; 0x03
    30dc:	85 30       	cpi	r24, 0x05	; 5
    30de:	70 f5       	brcc	.+92     	; 0x313c <OLED_HorizontalGraph+0x7a>
    30e0:	8c 81       	ldd	r24, Y+4	; 0x04
    30e2:	85 36       	cpi	r24, 0x65	; 101
    30e4:	58 f5       	brcc	.+86     	; 0x313c <OLED_HorizontalGraph+0x7a>
    {
        OLED_SetCursor(lineNumberToStartDisplay,0);
    30e6:	60 e0       	ldi	r22, 0x00	; 0
    30e8:	8a 81       	ldd	r24, Y+2	; 0x02
    30ea:	0e 94 84 17 	call	0x2f08	; 0x2f08 <OLED_SetCursor>
        
        for(i=0;i<percentageValue;i++)
    30ee:	19 82       	std	Y+1, r1	; 0x01
    30f0:	06 c0       	rjmp	.+12     	; 0x30fe <OLED_HorizontalGraph+0x3c>
        {
            oledSendByte(0xff);
    30f2:	8f ef       	ldi	r24, 0xFF	; 255
    30f4:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <oledSendByte>
    
    if((barGraphNumber < C_MaxBarGraphs_U8) && (percentageValue<=100))
    {
        OLED_SetCursor(lineNumberToStartDisplay,0);
        
        for(i=0;i<percentageValue;i++)
    30f8:	89 81       	ldd	r24, Y+1	; 0x01
    30fa:	8f 5f       	subi	r24, 0xFF	; 255
    30fc:	89 83       	std	Y+1, r24	; 0x01
    30fe:	99 81       	ldd	r25, Y+1	; 0x01
    3100:	8c 81       	ldd	r24, Y+4	; 0x04
    3102:	98 17       	cp	r25, r24
    3104:	b0 f3       	brcs	.-20     	; 0x30f2 <OLED_HorizontalGraph+0x30>
        {
            oledSendByte(0xff);
        }
        
        for(i=percentageValue;i<100;i++)
    3106:	8c 81       	ldd	r24, Y+4	; 0x04
    3108:	89 83       	std	Y+1, r24	; 0x01
    310a:	06 c0       	rjmp	.+12     	; 0x3118 <OLED_HorizontalGraph+0x56>
        {
            oledSendByte(0x00);
    310c:	80 e0       	ldi	r24, 0x00	; 0
    310e:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <oledSendByte>
        for(i=0;i<percentageValue;i++)
        {
            oledSendByte(0xff);
        }
        
        for(i=percentageValue;i<100;i++)
    3112:	89 81       	ldd	r24, Y+1	; 0x01
    3114:	8f 5f       	subi	r24, 0xFF	; 255
    3116:	89 83       	std	Y+1, r24	; 0x01
    3118:	89 81       	ldd	r24, Y+1	; 0x01
    311a:	84 36       	cpi	r24, 0x64	; 100
    311c:	b8 f3       	brcs	.-18     	; 0x310c <OLED_HorizontalGraph+0x4a>
        {
            oledSendByte(0x00);
        }
        
        OLED_SetCursor(lineNumberToStartDisplay,105);
    311e:	69 e6       	ldi	r22, 0x69	; 105
    3120:	8a 81       	ldd	r24, Y+2	; 0x02
    3122:	0e 94 84 17 	call	0x2f08	; 0x2f08 <OLED_SetCursor>
        
        OLED_DisplayNumber(E_DECIMAL,percentageValue,3);
    3126:	8c 81       	ldd	r24, Y+4	; 0x04
    3128:	88 2f       	mov	r24, r24
    312a:	90 e0       	ldi	r25, 0x00	; 0
    312c:	a0 e0       	ldi	r26, 0x00	; 0
    312e:	b0 e0       	ldi	r27, 0x00	; 0
    3130:	23 e0       	ldi	r18, 0x03	; 3
    3132:	ac 01       	movw	r20, r24
    3134:	bd 01       	movw	r22, r26
    3136:	8a e0       	ldi	r24, 0x0A	; 10
    3138:	0e 94 fd 13 	call	0x27fa	; 0x27fa <OLED_DisplayNumber>
    }
}
    313c:	00 00       	nop
    313e:	0f 90       	pop	r0
    3140:	0f 90       	pop	r0
    3142:	0f 90       	pop	r0
    3144:	0f 90       	pop	r0
    3146:	df 91       	pop	r29
    3148:	cf 91       	pop	r28
    314a:	08 95       	ret

0000314c <OLED_EnableInversion>:
 This function is used to Enable the display inversion.
 Once this is enabled the background pixels will be turned ON and char pixels will be OFF.
 ****************************************************************************************************/
#if (Enable_OLED_EnableInversion == 1)
void OLED_EnableInversion(void)
{
    314c:	cf 93       	push	r28
    314e:	df 93       	push	r29
    3150:	cd b7       	in	r28, 0x3d	; 61
    3152:	de b7       	in	r29, 0x3e	; 62
    oledSendCommand(SSD1306_INVERT_DISPLAY);
    3154:	87 ea       	ldi	r24, 0xA7	; 167
    3156:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
}
    315a:	00 00       	nop
    315c:	df 91       	pop	r29
    315e:	cf 91       	pop	r28
    3160:	08 95       	ret

00003162 <OLED_DisableInversion>:
 * description  :
 This function is used to clear the display inversion.
 ****************************************************************************************************/
#if (Enable_OLED_DisableInversion == 1)
void OLED_DisableInversion(void)
{
    3162:	cf 93       	push	r28
    3164:	df 93       	push	r29
    3166:	cd b7       	in	r28, 0x3d	; 61
    3168:	de b7       	in	r29, 0x3e	; 62
    oledSendCommand(SSD1306_NORMAL_DISPLAY);
    316a:	86 ea       	ldi	r24, 0xA6	; 166
    316c:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
}
    3170:	00 00       	nop
    3172:	df 91       	pop	r29
    3174:	cf 91       	pop	r28
    3176:	08 95       	ret

00003178 <OLED_SetBrightness>:
 * description  :
 This function is used to adjust the contrast/Brightness of the OLED.
 ****************************************************************************************************/
#if (Enable_OLED_SetBrightness == 1)
void OLED_SetBrightness(uint8_t brightnessValue)
{
    3178:	cf 93       	push	r28
    317a:	df 93       	push	r29
    317c:	1f 92       	push	r1
    317e:	cd b7       	in	r28, 0x3d	; 61
    3180:	de b7       	in	r29, 0x3e	; 62
    3182:	89 83       	std	Y+1, r24	; 0x01
    oledSendCommand(SSD1306_SET_CONTRAST_CONTROL);
    3184:	81 e8       	ldi	r24, 0x81	; 129
    3186:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
    oledSendCommand(brightnessValue);
    318a:	89 81       	ldd	r24, Y+1	; 0x01
    318c:	0e 94 f6 18 	call	0x31ec	; 0x31ec <oledSendCommand>
}
    3190:	00 00       	nop
    3192:	0f 90       	pop	r0
    3194:	df 91       	pop	r29
    3196:	cf 91       	pop	r28
    3198:	08 95       	ret

0000319a <oledSendStart>:

/********************************************************************************
 Local FUnctions for sending the command/data
 ********************************************************************************/

void oledSendStart(uint8_t address){
    319a:	cf 93       	push	r28
    319c:	df 93       	push	r29
    319e:	1f 92       	push	r1
    31a0:	cd b7       	in	r28, 0x3d	; 61
    31a2:	de b7       	in	r29, 0x3e	; 62
    31a4:	89 83       	std	Y+1, r24	; 0x01

    
    i2c_tx_start(MASTER_TRANSMITTER);
    31a6:	80 e0       	ldi	r24, 0x00	; 0
    31a8:	0e 94 bd 00 	call	0x17a	; 0x17a <i2c_tx_start>
    i2c_tx_address(address);
    31ac:	89 81       	ldd	r24, Y+1	; 0x01
    31ae:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <i2c_tx_address>
}
    31b2:	00 00       	nop
    31b4:	0f 90       	pop	r0
    31b6:	df 91       	pop	r29
    31b8:	cf 91       	pop	r28
    31ba:	08 95       	ret

000031bc <oledSendStop>:


void oledSendStop(void){
    31bc:	cf 93       	push	r28
    31be:	df 93       	push	r29
    31c0:	cd b7       	in	r28, 0x3d	; 61
    31c2:	de b7       	in	r29, 0x3e	; 62

    i2c_tx_stop();
    31c4:	0e 94 16 02 	call	0x42c	; 0x42c <i2c_tx_stop>
}
    31c8:	00 00       	nop
    31ca:	df 91       	pop	r29
    31cc:	cf 91       	pop	r28
    31ce:	08 95       	ret

000031d0 <oledSendByte>:





void oledSendByte(uint8_t ch){
    31d0:	cf 93       	push	r28
    31d2:	df 93       	push	r29
    31d4:	1f 92       	push	r1
    31d6:	cd b7       	in	r28, 0x3d	; 61
    31d8:	de b7       	in	r29, 0x3e	; 62
    31da:	89 83       	std	Y+1, r24	; 0x01

    
    i2c_tx_byte(ch);
    31dc:	89 81       	ldd	r24, Y+1	; 0x01
    31de:	0e 94 69 01 	call	0x2d2	; 0x2d2 <i2c_tx_byte>
    
}
    31e2:	00 00       	nop
    31e4:	0f 90       	pop	r0
    31e6:	df 91       	pop	r29
    31e8:	cf 91       	pop	r28
    31ea:	08 95       	ret

000031ec <oledSendCommand>:


void oledSendCommand(uint8_t cmd){
    31ec:	cf 93       	push	r28
    31ee:	df 93       	push	r29
    31f0:	1f 92       	push	r1
    31f2:	cd b7       	in	r28, 0x3d	; 61
    31f4:	de b7       	in	r29, 0x3e	; 62
    31f6:	89 83       	std	Y+1, r24	; 0x01
    //oledSendStart(SSD1306_ADDRESS<<1);
    oledSendStart(SSD1306_ADDRESS);
    31f8:	8c e3       	ldi	r24, 0x3C	; 60
    31fa:	0e 94 cd 18 	call	0x319a	; 0x319a <oledSendStart>
    oledSendByte(SSD1306_COMMAND);
    31fe:	80 e0       	ldi	r24, 0x00	; 0
    3200:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <oledSendByte>
    oledSendByte(cmd);
    3204:	89 81       	ldd	r24, Y+1	; 0x01
    3206:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <oledSendByte>
    oledSendStop();
    320a:	0e 94 de 18 	call	0x31bc	; 0x31bc <oledSendStop>
}
    320e:	00 00       	nop
    3210:	0f 90       	pop	r0
    3212:	df 91       	pop	r29
    3214:	cf 91       	pop	r28
    3216:	08 95       	ret

00003218 <configureLEDs>:
#include "utils.h"
#include "config.h"
#include "lcd.h"

void configureLEDs(void) {
    3218:	cf 93       	push	r28
    321a:	df 93       	push	r29
    321c:	cd b7       	in	r28, 0x3d	; 61
    321e:	de b7       	in	r29, 0x3e	; 62
    DDRB |= (1<<LEDB) | (1<<LEDG) | (1<<LEDR) | (1<<LEDsys);
    3220:	84 e2       	ldi	r24, 0x24	; 36
    3222:	90 e0       	ldi	r25, 0x00	; 0
    3224:	24 e2       	ldi	r18, 0x24	; 36
    3226:	30 e0       	ldi	r19, 0x00	; 0
    3228:	f9 01       	movw	r30, r18
    322a:	20 81       	ld	r18, Z
    322c:	2c 63       	ori	r18, 0x3C	; 60
    322e:	fc 01       	movw	r30, r24
    3230:	20 83       	st	Z, r18
};
    3232:	00 00       	nop
    3234:	df 91       	pop	r29
    3236:	cf 91       	pop	r28
    3238:	08 95       	ret

0000323a <configureLCD>:

void configureLCD(void) {
    323a:	cf 93       	push	r28
    323c:	df 93       	push	r29
    323e:	cd b7       	in	r28, 0x3d	; 61
    3240:	de b7       	in	r29, 0x3e	; 62
    lcd_begin();
    3242:	0e 94 c3 06 	call	0xd86	; 0xd86 <lcd_begin>
    //lcd_init();
    lcd_set_cursor(0, 0);
    3246:	60 e0       	ldi	r22, 0x00	; 0
    3248:	80 e0       	ldi	r24, 0x00	; 0
    324a:	0e 94 83 0d 	call	0x1b06	; 0x1b06 <lcd_set_cursor>
    lcd_print("Hello World!");
    324e:	8b ed       	ldi	r24, 0xDB	; 219
    3250:	92 e0       	ldi	r25, 0x02	; 2
    3252:	0e 94 ba 0d 	call	0x1b74	; 0x1b74 <lcd_print>
}
    3256:	00 00       	nop
    3258:	df 91       	pop	r29
    325a:	cf 91       	pop	r28
    325c:	08 95       	ret

0000325e <coifigureButtons>:

void coifigureButtons(void){
    325e:	cf 93       	push	r28
    3260:	df 93       	push	r29
    3262:	cd b7       	in	r28, 0x3d	; 61
    3264:	de b7       	in	r29, 0x3e	; 62
    DDRB &= ~(1<<BUTL) & ~(1<<BUTR);
    3266:	84 e2       	ldi	r24, 0x24	; 36
    3268:	90 e0       	ldi	r25, 0x00	; 0
    326a:	24 e2       	ldi	r18, 0x24	; 36
    326c:	30 e0       	ldi	r19, 0x00	; 0
    326e:	f9 01       	movw	r30, r18
    3270:	20 81       	ld	r18, Z
    3272:	2c 7f       	andi	r18, 0xFC	; 252
    3274:	fc 01       	movw	r30, r24
    3276:	20 83       	st	Z, r18
}
    3278:	00 00       	nop
    327a:	df 91       	pop	r29
    327c:	cf 91       	pop	r28
    327e:	08 95       	ret

00003280 <cofigureWaterLevel>:

void cofigureWaterLevel(void) {
    3280:	cf 93       	push	r28
    3282:	df 93       	push	r29
    3284:	cd b7       	in	r28, 0x3d	; 61
    3286:	de b7       	in	r29, 0x3e	; 62

    ADCSRA |= (1<<ADEN); //enable adc
    ADCSRA |= (1<<ADSC); //zanemo konverzijo
    */
    // Select Vref=AVcc
    ADMUX |= (1<<REFS0);
    3288:	8c e7       	ldi	r24, 0x7C	; 124
    328a:	90 e0       	ldi	r25, 0x00	; 0
    328c:	2c e7       	ldi	r18, 0x7C	; 124
    328e:	30 e0       	ldi	r19, 0x00	; 0
    3290:	f9 01       	movw	r30, r18
    3292:	20 81       	ld	r18, Z
    3294:	20 64       	ori	r18, 0x40	; 64
    3296:	fc 01       	movw	r30, r24
    3298:	20 83       	st	Z, r18
    //set prescaller to 128 and enable ADC
    ADCSRA |= (1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0)|(1<<ADEN);
    329a:	8a e7       	ldi	r24, 0x7A	; 122
    329c:	90 e0       	ldi	r25, 0x00	; 0
    329e:	2a e7       	ldi	r18, 0x7A	; 122
    32a0:	30 e0       	ldi	r19, 0x00	; 0
    32a2:	f9 01       	movw	r30, r18
    32a4:	20 81       	ld	r18, Z
    32a6:	27 68       	ori	r18, 0x87	; 135
    32a8:	fc 01       	movw	r30, r24
    32aa:	20 83       	st	Z, r18
};
    32ac:	00 00       	nop
    32ae:	df 91       	pop	r29
    32b0:	cf 91       	pop	r28
    32b2:	08 95       	ret

000032b4 <configureReles>:

void configureReles(void) {
    32b4:	cf 93       	push	r28
    32b6:	df 93       	push	r29
    32b8:	cd b7       	in	r28, 0x3d	; 61
    32ba:	de b7       	in	r29, 0x3e	; 62
    DDRC |= (1<<REL1) | (1<<REL2) | (1<<REL3) | (1<<REL4);
    32bc:	87 e2       	ldi	r24, 0x27	; 39
    32be:	90 e0       	ldi	r25, 0x00	; 0
    32c0:	27 e2       	ldi	r18, 0x27	; 39
    32c2:	30 e0       	ldi	r19, 0x00	; 0
    32c4:	f9 01       	movw	r30, r18
    32c6:	20 81       	ld	r18, Z
    32c8:	2e 62       	ori	r18, 0x2E	; 46
    32ca:	fc 01       	movw	r30, r24
    32cc:	20 83       	st	Z, r18
}
    32ce:	00 00       	nop
    32d0:	df 91       	pop	r29
    32d2:	cf 91       	pop	r28
    32d4:	08 95       	ret

000032d6 <__udivmodsi4>:
    32d6:	a1 e2       	ldi	r26, 0x21	; 33
    32d8:	1a 2e       	mov	r1, r26
    32da:	aa 1b       	sub	r26, r26
    32dc:	bb 1b       	sub	r27, r27
    32de:	fd 01       	movw	r30, r26
    32e0:	0d c0       	rjmp	.+26     	; 0x32fc <__udivmodsi4_ep>

000032e2 <__udivmodsi4_loop>:
    32e2:	aa 1f       	adc	r26, r26
    32e4:	bb 1f       	adc	r27, r27
    32e6:	ee 1f       	adc	r30, r30
    32e8:	ff 1f       	adc	r31, r31
    32ea:	a2 17       	cp	r26, r18
    32ec:	b3 07       	cpc	r27, r19
    32ee:	e4 07       	cpc	r30, r20
    32f0:	f5 07       	cpc	r31, r21
    32f2:	20 f0       	brcs	.+8      	; 0x32fc <__udivmodsi4_ep>
    32f4:	a2 1b       	sub	r26, r18
    32f6:	b3 0b       	sbc	r27, r19
    32f8:	e4 0b       	sbc	r30, r20
    32fa:	f5 0b       	sbc	r31, r21

000032fc <__udivmodsi4_ep>:
    32fc:	66 1f       	adc	r22, r22
    32fe:	77 1f       	adc	r23, r23
    3300:	88 1f       	adc	r24, r24
    3302:	99 1f       	adc	r25, r25
    3304:	1a 94       	dec	r1
    3306:	69 f7       	brne	.-38     	; 0x32e2 <__udivmodsi4_loop>
    3308:	60 95       	com	r22
    330a:	70 95       	com	r23
    330c:	80 95       	com	r24
    330e:	90 95       	com	r25
    3310:	9b 01       	movw	r18, r22
    3312:	ac 01       	movw	r20, r24
    3314:	bd 01       	movw	r22, r26
    3316:	cf 01       	movw	r24, r30
    3318:	08 95       	ret

0000331a <__tablejump2__>:
    331a:	ee 0f       	add	r30, r30
    331c:	ff 1f       	adc	r31, r31
    331e:	05 90       	lpm	r0, Z+
    3320:	f4 91       	lpm	r31, Z
    3322:	e0 2d       	mov	r30, r0
    3324:	09 94       	ijmp

00003326 <__subsf3>:
    3326:	50 58       	subi	r21, 0x80	; 128

00003328 <__addsf3>:
    3328:	bb 27       	eor	r27, r27
    332a:	aa 27       	eor	r26, r26
    332c:	0e 94 ab 19 	call	0x3356	; 0x3356 <__addsf3x>
    3330:	0c 94 1e 1b 	jmp	0x363c	; 0x363c <__fp_round>
    3334:	0e 94 10 1b 	call	0x3620	; 0x3620 <__fp_pscA>
    3338:	38 f0       	brcs	.+14     	; 0x3348 <__addsf3+0x20>
    333a:	0e 94 17 1b 	call	0x362e	; 0x362e <__fp_pscB>
    333e:	20 f0       	brcs	.+8      	; 0x3348 <__addsf3+0x20>
    3340:	39 f4       	brne	.+14     	; 0x3350 <__addsf3+0x28>
    3342:	9f 3f       	cpi	r25, 0xFF	; 255
    3344:	19 f4       	brne	.+6      	; 0x334c <__addsf3+0x24>
    3346:	26 f4       	brtc	.+8      	; 0x3350 <__addsf3+0x28>
    3348:	0c 94 0d 1b 	jmp	0x361a	; 0x361a <__fp_nan>
    334c:	0e f4       	brtc	.+2      	; 0x3350 <__addsf3+0x28>
    334e:	e0 95       	com	r30
    3350:	e7 fb       	bst	r30, 7
    3352:	0c 94 07 1b 	jmp	0x360e	; 0x360e <__fp_inf>

00003356 <__addsf3x>:
    3356:	e9 2f       	mov	r30, r25
    3358:	0e 94 2f 1b 	call	0x365e	; 0x365e <__fp_split3>
    335c:	58 f3       	brcs	.-42     	; 0x3334 <__addsf3+0xc>
    335e:	ba 17       	cp	r27, r26
    3360:	62 07       	cpc	r22, r18
    3362:	73 07       	cpc	r23, r19
    3364:	84 07       	cpc	r24, r20
    3366:	95 07       	cpc	r25, r21
    3368:	20 f0       	brcs	.+8      	; 0x3372 <__addsf3x+0x1c>
    336a:	79 f4       	brne	.+30     	; 0x338a <__addsf3x+0x34>
    336c:	a6 f5       	brtc	.+104    	; 0x33d6 <__addsf3x+0x80>
    336e:	0c 94 51 1b 	jmp	0x36a2	; 0x36a2 <__fp_zero>
    3372:	0e f4       	brtc	.+2      	; 0x3376 <__addsf3x+0x20>
    3374:	e0 95       	com	r30
    3376:	0b 2e       	mov	r0, r27
    3378:	ba 2f       	mov	r27, r26
    337a:	a0 2d       	mov	r26, r0
    337c:	0b 01       	movw	r0, r22
    337e:	b9 01       	movw	r22, r18
    3380:	90 01       	movw	r18, r0
    3382:	0c 01       	movw	r0, r24
    3384:	ca 01       	movw	r24, r20
    3386:	a0 01       	movw	r20, r0
    3388:	11 24       	eor	r1, r1
    338a:	ff 27       	eor	r31, r31
    338c:	59 1b       	sub	r21, r25
    338e:	99 f0       	breq	.+38     	; 0x33b6 <__addsf3x+0x60>
    3390:	59 3f       	cpi	r21, 0xF9	; 249
    3392:	50 f4       	brcc	.+20     	; 0x33a8 <__addsf3x+0x52>
    3394:	50 3e       	cpi	r21, 0xE0	; 224
    3396:	68 f1       	brcs	.+90     	; 0x33f2 <__addsf3x+0x9c>
    3398:	1a 16       	cp	r1, r26
    339a:	f0 40       	sbci	r31, 0x00	; 0
    339c:	a2 2f       	mov	r26, r18
    339e:	23 2f       	mov	r18, r19
    33a0:	34 2f       	mov	r19, r20
    33a2:	44 27       	eor	r20, r20
    33a4:	58 5f       	subi	r21, 0xF8	; 248
    33a6:	f3 cf       	rjmp	.-26     	; 0x338e <__addsf3x+0x38>
    33a8:	46 95       	lsr	r20
    33aa:	37 95       	ror	r19
    33ac:	27 95       	ror	r18
    33ae:	a7 95       	ror	r26
    33b0:	f0 40       	sbci	r31, 0x00	; 0
    33b2:	53 95       	inc	r21
    33b4:	c9 f7       	brne	.-14     	; 0x33a8 <__addsf3x+0x52>
    33b6:	7e f4       	brtc	.+30     	; 0x33d6 <__addsf3x+0x80>
    33b8:	1f 16       	cp	r1, r31
    33ba:	ba 0b       	sbc	r27, r26
    33bc:	62 0b       	sbc	r22, r18
    33be:	73 0b       	sbc	r23, r19
    33c0:	84 0b       	sbc	r24, r20
    33c2:	ba f0       	brmi	.+46     	; 0x33f2 <__addsf3x+0x9c>
    33c4:	91 50       	subi	r25, 0x01	; 1
    33c6:	a1 f0       	breq	.+40     	; 0x33f0 <__addsf3x+0x9a>
    33c8:	ff 0f       	add	r31, r31
    33ca:	bb 1f       	adc	r27, r27
    33cc:	66 1f       	adc	r22, r22
    33ce:	77 1f       	adc	r23, r23
    33d0:	88 1f       	adc	r24, r24
    33d2:	c2 f7       	brpl	.-16     	; 0x33c4 <__addsf3x+0x6e>
    33d4:	0e c0       	rjmp	.+28     	; 0x33f2 <__addsf3x+0x9c>
    33d6:	ba 0f       	add	r27, r26
    33d8:	62 1f       	adc	r22, r18
    33da:	73 1f       	adc	r23, r19
    33dc:	84 1f       	adc	r24, r20
    33de:	48 f4       	brcc	.+18     	; 0x33f2 <__addsf3x+0x9c>
    33e0:	87 95       	ror	r24
    33e2:	77 95       	ror	r23
    33e4:	67 95       	ror	r22
    33e6:	b7 95       	ror	r27
    33e8:	f7 95       	ror	r31
    33ea:	9e 3f       	cpi	r25, 0xFE	; 254
    33ec:	08 f0       	brcs	.+2      	; 0x33f0 <__addsf3x+0x9a>
    33ee:	b0 cf       	rjmp	.-160    	; 0x3350 <__addsf3+0x28>
    33f0:	93 95       	inc	r25
    33f2:	88 0f       	add	r24, r24
    33f4:	08 f0       	brcs	.+2      	; 0x33f8 <__addsf3x+0xa2>
    33f6:	99 27       	eor	r25, r25
    33f8:	ee 0f       	add	r30, r30
    33fa:	97 95       	ror	r25
    33fc:	87 95       	ror	r24
    33fe:	08 95       	ret

00003400 <__cmpsf2>:
    3400:	0e 94 e3 1a 	call	0x35c6	; 0x35c6 <__fp_cmp>
    3404:	08 f4       	brcc	.+2      	; 0x3408 <__cmpsf2+0x8>
    3406:	81 e0       	ldi	r24, 0x01	; 1
    3408:	08 95       	ret

0000340a <__divsf3>:
    340a:	0e 94 19 1a 	call	0x3432	; 0x3432 <__divsf3x>
    340e:	0c 94 1e 1b 	jmp	0x363c	; 0x363c <__fp_round>
    3412:	0e 94 17 1b 	call	0x362e	; 0x362e <__fp_pscB>
    3416:	58 f0       	brcs	.+22     	; 0x342e <__divsf3+0x24>
    3418:	0e 94 10 1b 	call	0x3620	; 0x3620 <__fp_pscA>
    341c:	40 f0       	brcs	.+16     	; 0x342e <__divsf3+0x24>
    341e:	29 f4       	brne	.+10     	; 0x342a <__divsf3+0x20>
    3420:	5f 3f       	cpi	r21, 0xFF	; 255
    3422:	29 f0       	breq	.+10     	; 0x342e <__divsf3+0x24>
    3424:	0c 94 07 1b 	jmp	0x360e	; 0x360e <__fp_inf>
    3428:	51 11       	cpse	r21, r1
    342a:	0c 94 52 1b 	jmp	0x36a4	; 0x36a4 <__fp_szero>
    342e:	0c 94 0d 1b 	jmp	0x361a	; 0x361a <__fp_nan>

00003432 <__divsf3x>:
    3432:	0e 94 2f 1b 	call	0x365e	; 0x365e <__fp_split3>
    3436:	68 f3       	brcs	.-38     	; 0x3412 <__divsf3+0x8>

00003438 <__divsf3_pse>:
    3438:	99 23       	and	r25, r25
    343a:	b1 f3       	breq	.-20     	; 0x3428 <__divsf3+0x1e>
    343c:	55 23       	and	r21, r21
    343e:	91 f3       	breq	.-28     	; 0x3424 <__divsf3+0x1a>
    3440:	95 1b       	sub	r25, r21
    3442:	55 0b       	sbc	r21, r21
    3444:	bb 27       	eor	r27, r27
    3446:	aa 27       	eor	r26, r26
    3448:	62 17       	cp	r22, r18
    344a:	73 07       	cpc	r23, r19
    344c:	84 07       	cpc	r24, r20
    344e:	38 f0       	brcs	.+14     	; 0x345e <__divsf3_pse+0x26>
    3450:	9f 5f       	subi	r25, 0xFF	; 255
    3452:	5f 4f       	sbci	r21, 0xFF	; 255
    3454:	22 0f       	add	r18, r18
    3456:	33 1f       	adc	r19, r19
    3458:	44 1f       	adc	r20, r20
    345a:	aa 1f       	adc	r26, r26
    345c:	a9 f3       	breq	.-22     	; 0x3448 <__divsf3_pse+0x10>
    345e:	35 d0       	rcall	.+106    	; 0x34ca <__divsf3_pse+0x92>
    3460:	0e 2e       	mov	r0, r30
    3462:	3a f0       	brmi	.+14     	; 0x3472 <__divsf3_pse+0x3a>
    3464:	e0 e8       	ldi	r30, 0x80	; 128
    3466:	32 d0       	rcall	.+100    	; 0x34cc <__divsf3_pse+0x94>
    3468:	91 50       	subi	r25, 0x01	; 1
    346a:	50 40       	sbci	r21, 0x00	; 0
    346c:	e6 95       	lsr	r30
    346e:	00 1c       	adc	r0, r0
    3470:	ca f7       	brpl	.-14     	; 0x3464 <__divsf3_pse+0x2c>
    3472:	2b d0       	rcall	.+86     	; 0x34ca <__divsf3_pse+0x92>
    3474:	fe 2f       	mov	r31, r30
    3476:	29 d0       	rcall	.+82     	; 0x34ca <__divsf3_pse+0x92>
    3478:	66 0f       	add	r22, r22
    347a:	77 1f       	adc	r23, r23
    347c:	88 1f       	adc	r24, r24
    347e:	bb 1f       	adc	r27, r27
    3480:	26 17       	cp	r18, r22
    3482:	37 07       	cpc	r19, r23
    3484:	48 07       	cpc	r20, r24
    3486:	ab 07       	cpc	r26, r27
    3488:	b0 e8       	ldi	r27, 0x80	; 128
    348a:	09 f0       	breq	.+2      	; 0x348e <__divsf3_pse+0x56>
    348c:	bb 0b       	sbc	r27, r27
    348e:	80 2d       	mov	r24, r0
    3490:	bf 01       	movw	r22, r30
    3492:	ff 27       	eor	r31, r31
    3494:	93 58       	subi	r25, 0x83	; 131
    3496:	5f 4f       	sbci	r21, 0xFF	; 255
    3498:	3a f0       	brmi	.+14     	; 0x34a8 <__divsf3_pse+0x70>
    349a:	9e 3f       	cpi	r25, 0xFE	; 254
    349c:	51 05       	cpc	r21, r1
    349e:	78 f0       	brcs	.+30     	; 0x34be <__divsf3_pse+0x86>
    34a0:	0c 94 07 1b 	jmp	0x360e	; 0x360e <__fp_inf>
    34a4:	0c 94 52 1b 	jmp	0x36a4	; 0x36a4 <__fp_szero>
    34a8:	5f 3f       	cpi	r21, 0xFF	; 255
    34aa:	e4 f3       	brlt	.-8      	; 0x34a4 <__divsf3_pse+0x6c>
    34ac:	98 3e       	cpi	r25, 0xE8	; 232
    34ae:	d4 f3       	brlt	.-12     	; 0x34a4 <__divsf3_pse+0x6c>
    34b0:	86 95       	lsr	r24
    34b2:	77 95       	ror	r23
    34b4:	67 95       	ror	r22
    34b6:	b7 95       	ror	r27
    34b8:	f7 95       	ror	r31
    34ba:	9f 5f       	subi	r25, 0xFF	; 255
    34bc:	c9 f7       	brne	.-14     	; 0x34b0 <__divsf3_pse+0x78>
    34be:	88 0f       	add	r24, r24
    34c0:	91 1d       	adc	r25, r1
    34c2:	96 95       	lsr	r25
    34c4:	87 95       	ror	r24
    34c6:	97 f9       	bld	r25, 7
    34c8:	08 95       	ret
    34ca:	e1 e0       	ldi	r30, 0x01	; 1
    34cc:	66 0f       	add	r22, r22
    34ce:	77 1f       	adc	r23, r23
    34d0:	88 1f       	adc	r24, r24
    34d2:	bb 1f       	adc	r27, r27
    34d4:	62 17       	cp	r22, r18
    34d6:	73 07       	cpc	r23, r19
    34d8:	84 07       	cpc	r24, r20
    34da:	ba 07       	cpc	r27, r26
    34dc:	20 f0       	brcs	.+8      	; 0x34e6 <__divsf3_pse+0xae>
    34de:	62 1b       	sub	r22, r18
    34e0:	73 0b       	sbc	r23, r19
    34e2:	84 0b       	sbc	r24, r20
    34e4:	ba 0b       	sbc	r27, r26
    34e6:	ee 1f       	adc	r30, r30
    34e8:	88 f7       	brcc	.-30     	; 0x34cc <__divsf3_pse+0x94>
    34ea:	e0 95       	com	r30
    34ec:	08 95       	ret

000034ee <__fixunssfsi>:
    34ee:	0e 94 37 1b 	call	0x366e	; 0x366e <__fp_splitA>
    34f2:	88 f0       	brcs	.+34     	; 0x3516 <__fixunssfsi+0x28>
    34f4:	9f 57       	subi	r25, 0x7F	; 127
    34f6:	98 f0       	brcs	.+38     	; 0x351e <__fixunssfsi+0x30>
    34f8:	b9 2f       	mov	r27, r25
    34fa:	99 27       	eor	r25, r25
    34fc:	b7 51       	subi	r27, 0x17	; 23
    34fe:	b0 f0       	brcs	.+44     	; 0x352c <__fixunssfsi+0x3e>
    3500:	e1 f0       	breq	.+56     	; 0x353a <__fixunssfsi+0x4c>
    3502:	66 0f       	add	r22, r22
    3504:	77 1f       	adc	r23, r23
    3506:	88 1f       	adc	r24, r24
    3508:	99 1f       	adc	r25, r25
    350a:	1a f0       	brmi	.+6      	; 0x3512 <__fixunssfsi+0x24>
    350c:	ba 95       	dec	r27
    350e:	c9 f7       	brne	.-14     	; 0x3502 <__fixunssfsi+0x14>
    3510:	14 c0       	rjmp	.+40     	; 0x353a <__fixunssfsi+0x4c>
    3512:	b1 30       	cpi	r27, 0x01	; 1
    3514:	91 f0       	breq	.+36     	; 0x353a <__fixunssfsi+0x4c>
    3516:	0e 94 51 1b 	call	0x36a2	; 0x36a2 <__fp_zero>
    351a:	b1 e0       	ldi	r27, 0x01	; 1
    351c:	08 95       	ret
    351e:	0c 94 51 1b 	jmp	0x36a2	; 0x36a2 <__fp_zero>
    3522:	67 2f       	mov	r22, r23
    3524:	78 2f       	mov	r23, r24
    3526:	88 27       	eor	r24, r24
    3528:	b8 5f       	subi	r27, 0xF8	; 248
    352a:	39 f0       	breq	.+14     	; 0x353a <__fixunssfsi+0x4c>
    352c:	b9 3f       	cpi	r27, 0xF9	; 249
    352e:	cc f3       	brlt	.-14     	; 0x3522 <__fixunssfsi+0x34>
    3530:	86 95       	lsr	r24
    3532:	77 95       	ror	r23
    3534:	67 95       	ror	r22
    3536:	b3 95       	inc	r27
    3538:	d9 f7       	brne	.-10     	; 0x3530 <__fixunssfsi+0x42>
    353a:	3e f4       	brtc	.+14     	; 0x354a <__fixunssfsi+0x5c>
    353c:	90 95       	com	r25
    353e:	80 95       	com	r24
    3540:	70 95       	com	r23
    3542:	61 95       	neg	r22
    3544:	7f 4f       	sbci	r23, 0xFF	; 255
    3546:	8f 4f       	sbci	r24, 0xFF	; 255
    3548:	9f 4f       	sbci	r25, 0xFF	; 255
    354a:	08 95       	ret

0000354c <__floatunsisf>:
    354c:	e8 94       	clt
    354e:	09 c0       	rjmp	.+18     	; 0x3562 <__floatsisf+0x12>

00003550 <__floatsisf>:
    3550:	97 fb       	bst	r25, 7
    3552:	3e f4       	brtc	.+14     	; 0x3562 <__floatsisf+0x12>
    3554:	90 95       	com	r25
    3556:	80 95       	com	r24
    3558:	70 95       	com	r23
    355a:	61 95       	neg	r22
    355c:	7f 4f       	sbci	r23, 0xFF	; 255
    355e:	8f 4f       	sbci	r24, 0xFF	; 255
    3560:	9f 4f       	sbci	r25, 0xFF	; 255
    3562:	99 23       	and	r25, r25
    3564:	a9 f0       	breq	.+42     	; 0x3590 <__floatsisf+0x40>
    3566:	f9 2f       	mov	r31, r25
    3568:	96 e9       	ldi	r25, 0x96	; 150
    356a:	bb 27       	eor	r27, r27
    356c:	93 95       	inc	r25
    356e:	f6 95       	lsr	r31
    3570:	87 95       	ror	r24
    3572:	77 95       	ror	r23
    3574:	67 95       	ror	r22
    3576:	b7 95       	ror	r27
    3578:	f1 11       	cpse	r31, r1
    357a:	f8 cf       	rjmp	.-16     	; 0x356c <__floatsisf+0x1c>
    357c:	fa f4       	brpl	.+62     	; 0x35bc <__floatsisf+0x6c>
    357e:	bb 0f       	add	r27, r27
    3580:	11 f4       	brne	.+4      	; 0x3586 <__floatsisf+0x36>
    3582:	60 ff       	sbrs	r22, 0
    3584:	1b c0       	rjmp	.+54     	; 0x35bc <__floatsisf+0x6c>
    3586:	6f 5f       	subi	r22, 0xFF	; 255
    3588:	7f 4f       	sbci	r23, 0xFF	; 255
    358a:	8f 4f       	sbci	r24, 0xFF	; 255
    358c:	9f 4f       	sbci	r25, 0xFF	; 255
    358e:	16 c0       	rjmp	.+44     	; 0x35bc <__floatsisf+0x6c>
    3590:	88 23       	and	r24, r24
    3592:	11 f0       	breq	.+4      	; 0x3598 <__floatsisf+0x48>
    3594:	96 e9       	ldi	r25, 0x96	; 150
    3596:	11 c0       	rjmp	.+34     	; 0x35ba <__floatsisf+0x6a>
    3598:	77 23       	and	r23, r23
    359a:	21 f0       	breq	.+8      	; 0x35a4 <__floatsisf+0x54>
    359c:	9e e8       	ldi	r25, 0x8E	; 142
    359e:	87 2f       	mov	r24, r23
    35a0:	76 2f       	mov	r23, r22
    35a2:	05 c0       	rjmp	.+10     	; 0x35ae <__floatsisf+0x5e>
    35a4:	66 23       	and	r22, r22
    35a6:	71 f0       	breq	.+28     	; 0x35c4 <__floatsisf+0x74>
    35a8:	96 e8       	ldi	r25, 0x86	; 134
    35aa:	86 2f       	mov	r24, r22
    35ac:	70 e0       	ldi	r23, 0x00	; 0
    35ae:	60 e0       	ldi	r22, 0x00	; 0
    35b0:	2a f0       	brmi	.+10     	; 0x35bc <__floatsisf+0x6c>
    35b2:	9a 95       	dec	r25
    35b4:	66 0f       	add	r22, r22
    35b6:	77 1f       	adc	r23, r23
    35b8:	88 1f       	adc	r24, r24
    35ba:	da f7       	brpl	.-10     	; 0x35b2 <__floatsisf+0x62>
    35bc:	88 0f       	add	r24, r24
    35be:	96 95       	lsr	r25
    35c0:	87 95       	ror	r24
    35c2:	97 f9       	bld	r25, 7
    35c4:	08 95       	ret

000035c6 <__fp_cmp>:
    35c6:	99 0f       	add	r25, r25
    35c8:	00 08       	sbc	r0, r0
    35ca:	55 0f       	add	r21, r21
    35cc:	aa 0b       	sbc	r26, r26
    35ce:	e0 e8       	ldi	r30, 0x80	; 128
    35d0:	fe ef       	ldi	r31, 0xFE	; 254
    35d2:	16 16       	cp	r1, r22
    35d4:	17 06       	cpc	r1, r23
    35d6:	e8 07       	cpc	r30, r24
    35d8:	f9 07       	cpc	r31, r25
    35da:	c0 f0       	brcs	.+48     	; 0x360c <__fp_cmp+0x46>
    35dc:	12 16       	cp	r1, r18
    35de:	13 06       	cpc	r1, r19
    35e0:	e4 07       	cpc	r30, r20
    35e2:	f5 07       	cpc	r31, r21
    35e4:	98 f0       	brcs	.+38     	; 0x360c <__fp_cmp+0x46>
    35e6:	62 1b       	sub	r22, r18
    35e8:	73 0b       	sbc	r23, r19
    35ea:	84 0b       	sbc	r24, r20
    35ec:	95 0b       	sbc	r25, r21
    35ee:	39 f4       	brne	.+14     	; 0x35fe <__fp_cmp+0x38>
    35f0:	0a 26       	eor	r0, r26
    35f2:	61 f0       	breq	.+24     	; 0x360c <__fp_cmp+0x46>
    35f4:	23 2b       	or	r18, r19
    35f6:	24 2b       	or	r18, r20
    35f8:	25 2b       	or	r18, r21
    35fa:	21 f4       	brne	.+8      	; 0x3604 <__fp_cmp+0x3e>
    35fc:	08 95       	ret
    35fe:	0a 26       	eor	r0, r26
    3600:	09 f4       	brne	.+2      	; 0x3604 <__fp_cmp+0x3e>
    3602:	a1 40       	sbci	r26, 0x01	; 1
    3604:	a6 95       	lsr	r26
    3606:	8f ef       	ldi	r24, 0xFF	; 255
    3608:	81 1d       	adc	r24, r1
    360a:	81 1d       	adc	r24, r1
    360c:	08 95       	ret

0000360e <__fp_inf>:
    360e:	97 f9       	bld	r25, 7
    3610:	9f 67       	ori	r25, 0x7F	; 127
    3612:	80 e8       	ldi	r24, 0x80	; 128
    3614:	70 e0       	ldi	r23, 0x00	; 0
    3616:	60 e0       	ldi	r22, 0x00	; 0
    3618:	08 95       	ret

0000361a <__fp_nan>:
    361a:	9f ef       	ldi	r25, 0xFF	; 255
    361c:	80 ec       	ldi	r24, 0xC0	; 192
    361e:	08 95       	ret

00003620 <__fp_pscA>:
    3620:	00 24       	eor	r0, r0
    3622:	0a 94       	dec	r0
    3624:	16 16       	cp	r1, r22
    3626:	17 06       	cpc	r1, r23
    3628:	18 06       	cpc	r1, r24
    362a:	09 06       	cpc	r0, r25
    362c:	08 95       	ret

0000362e <__fp_pscB>:
    362e:	00 24       	eor	r0, r0
    3630:	0a 94       	dec	r0
    3632:	12 16       	cp	r1, r18
    3634:	13 06       	cpc	r1, r19
    3636:	14 06       	cpc	r1, r20
    3638:	05 06       	cpc	r0, r21
    363a:	08 95       	ret

0000363c <__fp_round>:
    363c:	09 2e       	mov	r0, r25
    363e:	03 94       	inc	r0
    3640:	00 0c       	add	r0, r0
    3642:	11 f4       	brne	.+4      	; 0x3648 <__fp_round+0xc>
    3644:	88 23       	and	r24, r24
    3646:	52 f0       	brmi	.+20     	; 0x365c <__fp_round+0x20>
    3648:	bb 0f       	add	r27, r27
    364a:	40 f4       	brcc	.+16     	; 0x365c <__fp_round+0x20>
    364c:	bf 2b       	or	r27, r31
    364e:	11 f4       	brne	.+4      	; 0x3654 <__fp_round+0x18>
    3650:	60 ff       	sbrs	r22, 0
    3652:	04 c0       	rjmp	.+8      	; 0x365c <__fp_round+0x20>
    3654:	6f 5f       	subi	r22, 0xFF	; 255
    3656:	7f 4f       	sbci	r23, 0xFF	; 255
    3658:	8f 4f       	sbci	r24, 0xFF	; 255
    365a:	9f 4f       	sbci	r25, 0xFF	; 255
    365c:	08 95       	ret

0000365e <__fp_split3>:
    365e:	57 fd       	sbrc	r21, 7
    3660:	90 58       	subi	r25, 0x80	; 128
    3662:	44 0f       	add	r20, r20
    3664:	55 1f       	adc	r21, r21
    3666:	59 f0       	breq	.+22     	; 0x367e <__fp_splitA+0x10>
    3668:	5f 3f       	cpi	r21, 0xFF	; 255
    366a:	71 f0       	breq	.+28     	; 0x3688 <__fp_splitA+0x1a>
    366c:	47 95       	ror	r20

0000366e <__fp_splitA>:
    366e:	88 0f       	add	r24, r24
    3670:	97 fb       	bst	r25, 7
    3672:	99 1f       	adc	r25, r25
    3674:	61 f0       	breq	.+24     	; 0x368e <__fp_splitA+0x20>
    3676:	9f 3f       	cpi	r25, 0xFF	; 255
    3678:	79 f0       	breq	.+30     	; 0x3698 <__fp_splitA+0x2a>
    367a:	87 95       	ror	r24
    367c:	08 95       	ret
    367e:	12 16       	cp	r1, r18
    3680:	13 06       	cpc	r1, r19
    3682:	14 06       	cpc	r1, r20
    3684:	55 1f       	adc	r21, r21
    3686:	f2 cf       	rjmp	.-28     	; 0x366c <__fp_split3+0xe>
    3688:	46 95       	lsr	r20
    368a:	f1 df       	rcall	.-30     	; 0x366e <__fp_splitA>
    368c:	08 c0       	rjmp	.+16     	; 0x369e <__fp_splitA+0x30>
    368e:	16 16       	cp	r1, r22
    3690:	17 06       	cpc	r1, r23
    3692:	18 06       	cpc	r1, r24
    3694:	99 1f       	adc	r25, r25
    3696:	f1 cf       	rjmp	.-30     	; 0x367a <__fp_splitA+0xc>
    3698:	86 95       	lsr	r24
    369a:	71 05       	cpc	r23, r1
    369c:	61 05       	cpc	r22, r1
    369e:	08 94       	sec
    36a0:	08 95       	ret

000036a2 <__fp_zero>:
    36a2:	e8 94       	clt

000036a4 <__fp_szero>:
    36a4:	bb 27       	eor	r27, r27
    36a6:	66 27       	eor	r22, r22
    36a8:	77 27       	eor	r23, r23
    36aa:	cb 01       	movw	r24, r22
    36ac:	97 f9       	bld	r25, 7
    36ae:	08 95       	ret

000036b0 <__gesf2>:
    36b0:	0e 94 e3 1a 	call	0x35c6	; 0x35c6 <__fp_cmp>
    36b4:	08 f4       	brcc	.+2      	; 0x36b8 <__gesf2+0x8>
    36b6:	8f ef       	ldi	r24, 0xFF	; 255
    36b8:	08 95       	ret

000036ba <__mulsf3>:
    36ba:	0e 94 70 1b 	call	0x36e0	; 0x36e0 <__mulsf3x>
    36be:	0c 94 1e 1b 	jmp	0x363c	; 0x363c <__fp_round>
    36c2:	0e 94 10 1b 	call	0x3620	; 0x3620 <__fp_pscA>
    36c6:	38 f0       	brcs	.+14     	; 0x36d6 <__mulsf3+0x1c>
    36c8:	0e 94 17 1b 	call	0x362e	; 0x362e <__fp_pscB>
    36cc:	20 f0       	brcs	.+8      	; 0x36d6 <__mulsf3+0x1c>
    36ce:	95 23       	and	r25, r21
    36d0:	11 f0       	breq	.+4      	; 0x36d6 <__mulsf3+0x1c>
    36d2:	0c 94 07 1b 	jmp	0x360e	; 0x360e <__fp_inf>
    36d6:	0c 94 0d 1b 	jmp	0x361a	; 0x361a <__fp_nan>
    36da:	11 24       	eor	r1, r1
    36dc:	0c 94 52 1b 	jmp	0x36a4	; 0x36a4 <__fp_szero>

000036e0 <__mulsf3x>:
    36e0:	0e 94 2f 1b 	call	0x365e	; 0x365e <__fp_split3>
    36e4:	70 f3       	brcs	.-36     	; 0x36c2 <__mulsf3+0x8>

000036e6 <__mulsf3_pse>:
    36e6:	95 9f       	mul	r25, r21
    36e8:	c1 f3       	breq	.-16     	; 0x36da <__mulsf3+0x20>
    36ea:	95 0f       	add	r25, r21
    36ec:	50 e0       	ldi	r21, 0x00	; 0
    36ee:	55 1f       	adc	r21, r21
    36f0:	62 9f       	mul	r22, r18
    36f2:	f0 01       	movw	r30, r0
    36f4:	72 9f       	mul	r23, r18
    36f6:	bb 27       	eor	r27, r27
    36f8:	f0 0d       	add	r31, r0
    36fa:	b1 1d       	adc	r27, r1
    36fc:	63 9f       	mul	r22, r19
    36fe:	aa 27       	eor	r26, r26
    3700:	f0 0d       	add	r31, r0
    3702:	b1 1d       	adc	r27, r1
    3704:	aa 1f       	adc	r26, r26
    3706:	64 9f       	mul	r22, r20
    3708:	66 27       	eor	r22, r22
    370a:	b0 0d       	add	r27, r0
    370c:	a1 1d       	adc	r26, r1
    370e:	66 1f       	adc	r22, r22
    3710:	82 9f       	mul	r24, r18
    3712:	22 27       	eor	r18, r18
    3714:	b0 0d       	add	r27, r0
    3716:	a1 1d       	adc	r26, r1
    3718:	62 1f       	adc	r22, r18
    371a:	73 9f       	mul	r23, r19
    371c:	b0 0d       	add	r27, r0
    371e:	a1 1d       	adc	r26, r1
    3720:	62 1f       	adc	r22, r18
    3722:	83 9f       	mul	r24, r19
    3724:	a0 0d       	add	r26, r0
    3726:	61 1d       	adc	r22, r1
    3728:	22 1f       	adc	r18, r18
    372a:	74 9f       	mul	r23, r20
    372c:	33 27       	eor	r19, r19
    372e:	a0 0d       	add	r26, r0
    3730:	61 1d       	adc	r22, r1
    3732:	23 1f       	adc	r18, r19
    3734:	84 9f       	mul	r24, r20
    3736:	60 0d       	add	r22, r0
    3738:	21 1d       	adc	r18, r1
    373a:	82 2f       	mov	r24, r18
    373c:	76 2f       	mov	r23, r22
    373e:	6a 2f       	mov	r22, r26
    3740:	11 24       	eor	r1, r1
    3742:	9f 57       	subi	r25, 0x7F	; 127
    3744:	50 40       	sbci	r21, 0x00	; 0
    3746:	9a f0       	brmi	.+38     	; 0x376e <__mulsf3_pse+0x88>
    3748:	f1 f0       	breq	.+60     	; 0x3786 <__mulsf3_pse+0xa0>
    374a:	88 23       	and	r24, r24
    374c:	4a f0       	brmi	.+18     	; 0x3760 <__mulsf3_pse+0x7a>
    374e:	ee 0f       	add	r30, r30
    3750:	ff 1f       	adc	r31, r31
    3752:	bb 1f       	adc	r27, r27
    3754:	66 1f       	adc	r22, r22
    3756:	77 1f       	adc	r23, r23
    3758:	88 1f       	adc	r24, r24
    375a:	91 50       	subi	r25, 0x01	; 1
    375c:	50 40       	sbci	r21, 0x00	; 0
    375e:	a9 f7       	brne	.-22     	; 0x374a <__mulsf3_pse+0x64>
    3760:	9e 3f       	cpi	r25, 0xFE	; 254
    3762:	51 05       	cpc	r21, r1
    3764:	80 f0       	brcs	.+32     	; 0x3786 <__mulsf3_pse+0xa0>
    3766:	0c 94 07 1b 	jmp	0x360e	; 0x360e <__fp_inf>
    376a:	0c 94 52 1b 	jmp	0x36a4	; 0x36a4 <__fp_szero>
    376e:	5f 3f       	cpi	r21, 0xFF	; 255
    3770:	e4 f3       	brlt	.-8      	; 0x376a <__mulsf3_pse+0x84>
    3772:	98 3e       	cpi	r25, 0xE8	; 232
    3774:	d4 f3       	brlt	.-12     	; 0x376a <__mulsf3_pse+0x84>
    3776:	86 95       	lsr	r24
    3778:	77 95       	ror	r23
    377a:	67 95       	ror	r22
    377c:	b7 95       	ror	r27
    377e:	f7 95       	ror	r31
    3780:	e7 95       	ror	r30
    3782:	9f 5f       	subi	r25, 0xFF	; 255
    3784:	c1 f7       	brne	.-16     	; 0x3776 <__mulsf3_pse+0x90>
    3786:	fe 2b       	or	r31, r30
    3788:	88 0f       	add	r24, r24
    378a:	91 1d       	adc	r25, r1
    378c:	96 95       	lsr	r25
    378e:	87 95       	ror	r24
    3790:	97 f9       	bld	r25, 7
    3792:	08 95       	ret

00003794 <_exit>:
    3794:	f8 94       	cli

00003796 <__stop_program>:
    3796:	ff cf       	rjmp	.-2      	; 0x3796 <__stop_program>
